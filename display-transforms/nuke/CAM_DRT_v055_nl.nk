set cut_paste_input [stack 0]
version 14.1 v1
push $cut_paste_input
Group {
 name DRT_CAMv2
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 selected true
 xpos 87
 ypos -436
 addUserKnob {20 User}
 addUserKnob {26 input_div l "Input Decoding"}
 addUserKnob {41 Encoding T CAM_DRT_Decode.Encoding}
 addUserKnob {41 Primaries T CAM_DRT_Decode.Primaries}
 addUserKnob {41 referenceLuminance l "Reference Luminance" T CAM_DRT_Decode.referenceLuminance}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI XYZ "" "" ""}}
 primaries_in XYZ
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et Hellwig2022
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 100
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "Reach/Compression primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 "" ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit sRGB/Rec.709
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1.2}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.24
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 smoothJ 0.058
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.188
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {26 ""}
 addUserKnob {26 "" l " "}
 addUserKnob {41 Encoding_1 l Encoding T CAM_DRT_Encodie.Encoding}
 addUserKnob {41 Primaries_1 l Primaries T CAM_DRT_Encodie.Primaries}
 addUserKnob {41 referenceLuminance_1 l "Reference Luminance" T CAM_DRT_Encodie.referenceLuminance}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 Group {
  name CAM_DRT_Decode
  xpos -908
  ypos -235
  addUserKnob {20 User}
  addUserKnob {4 Direction M {Decode Encode}}
  addUserKnob {4 Primaries M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI XYZ}}
  addUserKnob {4 Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084}}
  addUserKnob {7 referenceLuminance l "Reference Luminance" R 0 200}
  referenceLuminance 100
 }
  Input {
   inputs 0
   name Input1
   xpos 228
   ypos -39
  }
  Constant {
   inputs 0
   channels rgb
   format "256 256 0 0 256 256 1 square_256"
   name Constant1
   xpos 110
   ypos 11
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input]"}}
   name Switch1
   xpos 228
   ypos 25
  }
  BlinkScript {
   kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/CAM_DRT_encoding.blink
   recompileCount 35
   ProgramGroup 1
   KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 8ec7b00fc474b7dec7b553cfae312d5d0b67d05ae2dfd24ac90ab9d923e874cc 2 \"src\" Read Point \"dst\" Write Point 4 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Primaries\" Int 1 AAAAAA== \"Reference Luminance\" Float 1 AADIQg== 4 \"invert\" 1 1 Default \"encoding\" 1 1 Default \"primaries\" 1 1 Default \"referenceLuminance\" 1 1 Default 10 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_L_p\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n  float3 st2084_L_p;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(primaries, \"Primaries\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 100.0f; // Scale so 100 is 1.0f for Nuke\n\n\n    // clang-format off\n    float identity_matrix\[] = \{\n       1.0f,  0.0f,  0.0f,\n       0.0f,  1.0f,  0.0f,\n       0.0f,  0.0f,  1.0f,\n    \};\n\n    float XYZ_to_AP0_ACES_matrix\[] = \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f,\n    \};\n\n    float XYZ_to_AP1_ACES_matrix\[] = \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f, \n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix\[] = \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix\[] = \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix\[] = \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix\[] = \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f,\n    \};\n    // clang-format on\n\n    // populate the input primaries matrix\n    if (primaries == 0)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_AP0_ACES_matrix);\n    \}\n    else if (primaries == 1)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_AP1_ACES_matrix);\n    \}\n    else if (primaries == 2)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_Rec709_D65_matrix);\n    \}\n    else if (primaries == 3)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_Rec2020_D65_matrix);\n    \}\n    else if (primaries == 4)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_P3_D65_matrix);\n    \}\n    else if (primaries == 5)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_P3_DCI_matrix);\n    \}\n    else\n    \{\n      XYZ_to_RGB.setArray(identity_matrix);\n    \}\n    RGB_to_XYZ = XYZ_to_RGB.invert();\n  \}\n\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  float3 linear_to_ST2084(float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f, 2.4f, 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f, 2.6f, 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * referenceLuminance;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v = v / referenceLuminance;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f, 1.0f / 2.6f, 1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
   rebuild ""
   DRT_CAM_Kernel_Direction {{parent.Direction}}
   DRT_CAM_Kernel_Encoding {{parent.Encoding}}
   DRT_CAM_Kernel_Primaries {{parent.Primaries}}
   "DRT_CAM_Kernel_Reference Luminance" {{parent.referenceLuminance}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 228
   ypos 78
  }
  Output {
   name Output1
   xpos 228
   ypos 149
  }
 end_group
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/CAM_DRT_v055_nl.blink
  recompileCount 4054
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise c2aee11fbf8c73174c082ba5d1054f1a6ebd93777078563665542b6289880a03 2 \"src\" Read Point \"dst\" Write Point 85 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"cc_et\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"gamutCuspTableSize\" Int 1 AAAAAA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== \"Non-linearity Mode\" Int 1 AAAAAA== \"Non-linearity Lower Break\" Float 1 uB6FPg== \"Non-linearity Upper Break\" Float 1 AAAWQw== \"Non-linearity intersection\" Float 1 AAAAAA== 85 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"cc_et\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"gamutCuspTableSize\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default \"nonlinearity_mode\" 1 1 Default \"ql\" 1 1 Default \"qu\" 1 1 Default \"qz\" 1 1 Default 75 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"smooth_cusp_scale\" Float 2 1 AAAAAAAAAAA= \"limitingGamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"reachGamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"D_RGB\" Float 3 3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"A_w\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"y_to_j_A_w\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"achromatic_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"nl_gamma\" Float 1 1 AAAAAA== \"nl_normalise\" Float 1 1 AAAAAA== \"nl_scale\" Float 1 1 AAAAAA== \"nl_offset\" Float 1 1 AAAAAA== \"nl_d_scale\" Float 1 1 AAAAAA== \"nl_Fl_scaled\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_derivative_scale\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_fql\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_fqu\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_lower_slope\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_upper_slope\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_a2\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_a1\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_a0\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_b_\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"nl_average_roots\" Float 1 3 AAAAAAAAAAAAAAAAAAAAAA== \"fitWhiteScale\" Float 1 1 AAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  cc_et;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  int gamutCuspTableSize;\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\n  int   nonlinearity_mode;\n  float ql;\n  float qu;\n  float qz;\n\nlocal:\n\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 refWhite;\n  float3 limitWhite;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float  model_gamma;\n  float  clamped_smoothness;\n  float2 smooth_cusp_scale;\n\n\n  // 361 - Adds an extra entry to wrap the hues without branching\n  // Non-uniform in h\n  float3 limitingGamutCuspTable\[361];\n  float3 cgamutCuspTable\[361];\n  // Uniform h\n  float3 reachGamutCuspTable\[361];\n  float2 gamutGammas\[361];\n\n  // Hellwig 2022 constants\n  float  F_L\[3];\n  float  z\[3];\n  float3 D_RGB\[3];\n  float  A_w\[3];\n  float  y_to_j_A_w\[3];\n  float3 achromatic_weights;\n  float3 a_weights;\n  float3 b_weights;\n\n  // Nonlinearity 'constants'\n  float nl_gamma;\n  float nl_normalise;\n  float nl_scale;\n  float nl_offset;\n  float nl_d_scale;\n\n  // Per \"stage\" precomputed nonlinearity function variables\n  float nl_Fl_scaled\[3];\n  float nl_derivative_scale\[3];\n  float nl_fql\[3];\n  float nl_fqu\[3];\n  float nl_lower_slope\[3];\n  float nl_upper_slope\[3];\n  float nl_a2\[3];\n  float nl_a1\[3];\n  float nl_a0\[3];\n  float nl_b_\[3];\n  float nl_average_roots\[3];\n\n  float fitWhiteScale;\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n\n    defineParam(nonlinearity_mode, \"Non-linearity Mode\", 0);\n    defineParam(ql, \"Non-linearity Lower Break\", 0.26f);\n    defineParam(qu, \"Non-linearity Upper Break\", 150.0f);\n    defineParam(qz, \"Non-linearity intersection\", 0.0f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    const float ach  = max(rgb.x, max(rgb.y, rgb.z));\n    const float fach = fabs(ach);\n\n    float3 d = 0.0f;\n    if (ach)\n    \{\n      d = (ach - rgb) / fach;\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fach;\n\n    return rgb;\n  \}\n\n  // Hellwig L, Stolitzka D,Fairchild MD.\n  // Extending CIECAM02 and CAM16 for the HelmholtzKohlrausch effect.\n  // Color Res Appl. 2022;1-9. doi:10.1002/col.22793\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward_original(float3 RGB, int stage)\n  \{\n    const float3 F_L_RGB = float3pow(F_L\[stage] / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float post_adaptation_non_linear_response_compression_forward_derivative_wheatley(float corresponding, int stage)\n  \{\n    const float val   = fabs(corresponding);\n    const float temp  = nl_derivative_scale\[stage] * pow(nl_Fl_scaled\[stage] * val, nl_gamma - 1.0f);\n    const float temp1 = nl_offset + pow(nl_Fl_scaled\[stage] * val, nl_gamma);\n    return sign(corresponding) * temp / (temp1 * temp1);\n  \}\n\n  float post_adaptation_non_linear_response_compression_forward_original_f(float corresponding, int stage)\n  \{\n    const float q      = fabs(corresponding);\n    const float sign_c = sign(corresponding);\n    const float temp   = pow(nl_Fl_scaled\[stage] * q, nl_gamma);\n    return sign_c * (nl_scale * (temp / (temp + nl_offset)));\n  \}\n\n  float post_adaptation_non_linear_response_compression_forward_wheatley_f(float corresponding, int stage)\n  \{\n    const float q      = fabs(corresponding);\n    const float sign_c = sign(corresponding);\n    if (q > qu)\n    \{\n      return sign_c * (nl_fqu\[stage] + nl_upper_slope\[stage] * (q - qu));\n    \}\n    if (q < ql)\n    \{\n      return sign_c * (nl_a2\[stage] * q * q + nl_a1\[stage] * q + nl_a0\[stage]);\n    \}\n    const float temp = pow(nl_Fl_scaled\[stage] * q, nl_gamma);\n    return sign_c * (nl_scale * (temp / (temp + nl_offset)));\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward_wheatley(float3 corresponding, int stage)\n  \{\n    float3 non_linear;\n    non_linear.x = post_adaptation_non_linear_response_compression_forward_wheatley_f(corresponding.x, stage);\n    non_linear.y = post_adaptation_non_linear_response_compression_forward_wheatley_f(corresponding.y, stage);\n    non_linear.z = post_adaptation_non_linear_response_compression_forward_wheatley_f(corresponding.z, stage);\n    return non_linear;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, int stage)\n  \{\n    if (nonlinearity_mode == 1)\n      return post_adaptation_non_linear_response_compression_forward_wheatley(RGB, stage);\n    return post_adaptation_non_linear_response_compression_forward_original(RGB, stage);\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse_original(float3 RGB, int stage)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L\[stage] * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  float post_adaptation_non_linear_response_compression_inverse_wheatley_f(float nl, int stage)\n  \{\n    if (nl >= nl_fqu\[stage])\n    \{\n      return (nl - nl_fqu\[stage]) / nl_upper_slope\[stage] + qu;\n    \}\n    if (nl <= nl_fql\[stage])\n    \{\n      // Quadratic solve\n      const float c_ = nl / nl_a2\[stage];        // TODO: no + a0\n      const float u  = sqrt(nl_average_roots\[stage] * nl_average_roots\[stage] + c_);\n      return float(nl_average_roots\[stage] - u); // (average_roots < u) ? average_roots + u : ... always take this root\n    \}\n\n    const float temp = (nl_offset * nl) / (nl_scale - nl);\n    return pow(temp, 1.0 / nl_gamma) / nl_Fl_scaled\[stage];\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse_wheatley(float3 nonlinear, int stage)\n  \{\n    const float3 nl     = fabs(nonlinear);\n    const float3 sign_c = sign(nonlinear);\n    float3       linear;\n    linear.x = post_adaptation_non_linear_response_compression_inverse_wheatley_f(nl.x, stage);\n    linear.y = post_adaptation_non_linear_response_compression_inverse_wheatley_f(nl.y, stage);\n    linear.z = post_adaptation_non_linear_response_compression_inverse_wheatley_f(nl.z, stage);\n    return sign_c * linear;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, int stage)\n  \{\n    if (nonlinearity_mode == 1)\n      return post_adaptation_non_linear_response_compression_inverse_wheatley(RGB, stage);\n    return post_adaptation_non_linear_response_compression_inverse_original(RGB, stage);\n  \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, int viewingConditions, bool HK_mode, int stage)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, viewingConditionsToSurround(viewingConditions), HK_mode, stage);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, int viewingConditions, bool HK_mode, int stage)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, viewingConditionsToSurround(viewingConditions), HK_mode, stage);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = pow(v, st2084_m_2_d);\n    return pow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = pow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return pow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return pow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return pow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return pow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, viewingConditions, HK_mode_out, 2);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, outputViewingConditions, HK_mode_out, 2);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ); // TODO combine into one, be careful with gamma finding\n    luminanceRGB *= fitWhiteScale;\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * peakLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, viewingConditions, HK_mode_mid, 1);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, viewingConditions, HK_mode_mid, 1);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / peakLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 surround, bool HK_mode, int stage)\n  \{\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB\[stage] * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, stage);\n\n    // # Step 6 and Step 4\n    // # Computing achromatic responses for the stimulus.\n    // # Converting to preliminary cartesian coordinates.\n    // basically a 3x3 matrix\n\n    const float A = dot(achromatic_weights, RGB_a);\n    const float a = dot(a_weights, RGB_a);\n    const float b = dot(b_weights, RGB_a);\n\n    // # Computing the *hue* angle :math:`h`.\n    const float hr = atan2(b, a);\n    const float h  = wrap_to_360(degrees(hr));\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w\[stage], surround.y * z\[stage]);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w\[stage];\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    const float et = eccentricity_factor(hr);\n    float       M  = 43.0f * surround.z * et * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * div(M, Q); // possible div by 0\n\n    if (HK_mode)\n    \{\n      // # Computing the correlate of *chroma* :math:`C`.\n      const float C = 35.0f * M / A_w\[stage];\n      // # *HelmholtzKohlrausch* Effect Extension.\n      J = sqrt(J * J + 66.0f * C); //J + hue_angle_dependency_Hellwig2022(hr) * pow(C, 0.587f); // TODO: Luke's PhD has updated HK calculation\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w\[stage];\n    \}\n\n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 surround, bool HK_mode, int stage)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n    const float hr = radians(JMh.z);\n\n    // # *HelmholtzKohlrausch* Effect Extension.\n    if (HK_mode)\n    \{\n      const float C = (M * 35.0f) / A_w\[stage];\n      J             = sqrt(J * J - 66.0f * C); //J - hue_angle_dependency_Hellwig2022(hr) * pow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float A = A_w\[stage] * pow(J / 100.0f, 1.0f / (surround.y * z\[stage]));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    const float et    = eccentricity_factor(hr);\n    const float P_p_1 = 43.0f * et * surround.z;\n    const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    const float gamma = M / P_p_1;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b));\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, stage);\n\n    // # Step 6\n    const float3 RGB = RGB_c / D_RGB\[stage];\n\n    // # Step 7\n    const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float wrapped_hue, float3* table, int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(wrapped_hue, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 limitingCuspFromTable(float wrapped_hue)\n  \{\n    float3 lo;\n    float3 hi;\n    if (wrapped_hue <= limitingGamutCuspTable\[0].z)\n    \{\n      lo   = limitingGamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = limitingGamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize; // Allowed as we have extra entry in the table\n      int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (wrapped_hue > limitingGamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = limitingGamutCuspTable\[high_i - 1];\n      hi = limitingGamutCuspTable\[high_i];\n    \}\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float wrapped_hue)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (wrapped_hue <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize; // Allowed as we have extra entry in the table\n      int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (wrapped_hue > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float wrapped_hue)\n  \{\n    const int i_lo = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n    const float3 lo = reachGamutCuspTable\[i_lo];\n    const float3 hi = reachGamutCuspTable\[i_lo + 1]; // Valid as we have added 1 to table length\n\n    const float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  inline float eccentricity_factor(float hr)\n  \{\n    float e_t = 1.0f;\n\n    // clang-format off\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      const float _h   = hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n      const float _2_h = 2 * hr;\n      const float _3_h = 3 * hr;\n      const float _4_h = 4 * hr;\n      e_t = (\n        - 0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      const float hr2 = hr * 2;\n      const float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    // clang-format on\n\n    return e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = ccuspFromTable(JMh.z).y;\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= Mnorm;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, nJ * compr, snJ, 0);\n\n      // Denormalize\n      M *= Mnorm;\n    \}\n    else\n    \{\n      M /= Mnorm;\n      M = toe(M, limit, nJ * compr, snJ, 1);\n      M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n      M *= Mnorm;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, viewingConditions, HK_mode_in, 0);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, viewingConditions, HK_mode_in, 0);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n  float Y_to_Hellwig_J(float Y, float3 surround, int stage)\n  \{\n    const float F_L_Y = pow(F_L\[stage] * fabs(Y) / 100.0f, 0.42f);\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / y_to_j_A_w\[stage], surround.y * z\[stage]);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround, int stage)\n  \{\n    const float A = y_to_j_A_w\[stage] * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z\[stage]));\n    return sign(J) * 100.0f / F_L\[stage] * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f); // TODO: fix me\n  \}\n\n  float3 forwardTonescale(float3 inputJMh, int stage)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround, stage) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround, stage);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh, int stage)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    float3 tonemappedJMh = JMh;\n    float3 surround      = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround, stage);\n\n    float linear;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ   = Y_to_Hellwig_J(linear, surround, stage);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float wrapped_hue)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = wrapped_hue - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float2 estimated_hull_gammas)\n  \{\n    float2      JM_source    = float2(JMh_s.x, JMh_s.y);\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    float slope;\n\n    JM_cusp *= smooth_cusp_scale; // TODO; could this be baked in?\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp) * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), gamma_top)\n      / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  float3 getReachBoundary(float3 Jmh)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    const float reachMaxM = cReachFromTable(Jmh.z);\n  \n    float2 JMcusp     = limitingCuspFromTable(Jmh.z);\n    float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n    float  slope_gain = compute_slope_gain(Jmh.x, JMcusp.x);\n    float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n    float  slope;\n    if (intersectJ < focusJ)\n    \{\n      slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n    \}\n    else\n    \{\n      slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n    \}\n    float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n    return float3(Jmh.x, boundaryNick, Jmh.z);\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold // TODO\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp // TODO is this comment correct\n      return 1.0f;\n    \}\n  \}\n\n  inline float compute_slope_gain(float J, float cuspJ)\n  \{\n    return limitJmax * focusDist * getFocusGain(J, cuspJ);\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = limitingCuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    const float2 project_from = float2(JMh.x, JMh.y);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f) // TODO: should this be lowerMlimit\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float2 JMcusp     = limitingCuspFromTable(JMh.z);\n    float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n    float  slope_gain = compute_slope_gain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    const float2 estimated_hull_gammas = hueDependantHullGammas(JMh.z);\n    float3 ganutBoundary = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n    float2 JMboundary    = float2(ganutBoundary.x, ganutBoundary.y);\n    float2 project_to    = float2(ganutBoundary.z, 0.0f);\n    float  projectJ      = ganutBoundary.z;\n\n    // Get hue dependent compression parameters\n    const float3 JMh_boundary = float3(JMboundary.x, JMboundary.y, JMh.z);\n    const float  locusMax     = getReachBoundary(JMh_boundary).y;\n    const float  difference   = max(1.0001f, locusMax / JMh_boundary.y); // TODO: magic threshold?\n    const float  threshold    = max(compressionFuncParams.x, 1.0f / difference);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed;\n\n    const float lowerMlimit = 0.0001f; // Testing a small value here // TODO\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)        // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, threshold, difference, compressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f); // TODO: should this be lowerMlimit\n    \}\n\n    if (diagnosticMode == 12) // TODO: do these diagnostics modes hint at functions we should make\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n\n    return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    // clang-format off\n    float panlrcm_data\[]=\n    \{\n      achromatic_weights.x, achromatic_weights.y, achromatic_weights.z,\n      a_weights.x, a_weights.y, a_weights.z, \n      b_weights.x, b_weights.y, b_weights.z,\n    \};\n    // clang-format on\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = (460.0f / panlrcm\[i]\[0]) / 1403.0f;\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z) // TODO: investigate uses\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n\n    clamped_smoothness  = max(0.000001f, smoothCusps);\n    smooth_cusp_scale.x = 1.0f + smoothJ * clamped_smoothness; // TODO Do we need to translate in J\n    smooth_cusp_scale.y = 1.0f + smoothM * clamped_smoothness;\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    // TODO; origin of numbers\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001f, -0.077f);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    refWhite   = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white); // TODO; could ref and limit be different?\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    achromatic_weights = float3(ra, 1.0f, ba);\n    a_weights          = float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_weights          = float3(1.0f, 1.0f, -2.0f) / 9.0f;\n    generate_panlrcm();\n\n    precompute_hellwig(inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, 0);\n    precompute_hellwig(refWhite, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, 1);\n    precompute_hellwig(limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, 2);\n    initialise_non_linearities();\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // Note this fails for HK mode as HK will be increased for highly saturated colours above white\n    limitJmax = RGB_to_JMh(float3(1.0f), RGB_to_XYZ_limit).x;\n\n    // Cusp table for Reach/chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_reach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(reachGamutCuspTable, gamutCuspTableSize, limitJmax, XYZ_to_RGB_reach);\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(limitingGamutCuspTable, gamutCuspTableSize, RGB_to_XYZ_limit);\n\n    midJ = XYZ_to_JMh(refWhite * daniele_c_t * mmScaleFactor, outputViewingConditions, HK_mode_mid, 1).x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n\n    fitWhiteScale = 1.0f;\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f));\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      fitWhiteScale           = 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, int viewingConditions, float _L_A, float Y_b, bool discountIlluminant, int stage)\n  \{\n    const float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround.x, _L_A), 0, 1);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k  = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4 = k * k * k * k;\n    F_L\[stage]     = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);\n\n    z\[stage] = compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, stage);\n    A_w\[stage]          = dot(achromatic_weights, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w\n    const float F_L_W = pow(F_L\[stage], 0.42f);\n    y_to_j_A_w\[stage]  = (400.0f * F_L_W) / (27.13f + F_L_W);\n  \}\n\n  void initialise_non_linearity(int stage)\n  \{\n    nl_Fl_scaled\[stage]        = F_L\[stage] * nl_normalise;\n    nl_derivative_scale\[stage] = nl_d_scale * nl_Fl_scaled\[stage];\n\n    // Break point calculations\n    nl_fql\[stage]             = post_adaptation_non_linear_response_compression_forward_wheatley_f(ql, stage);\n    nl_fqu\[stage]             = post_adaptation_non_linear_response_compression_forward_wheatley_f(qu, stage);\n    nl_lower_slope\[stage]     = nl_fql\[stage] / ql;\n    nl_upper_slope\[stage]     = post_adaptation_non_linear_response_compression_forward_derivative_wheatley(qu, stage);\n    const float ql_derivative = post_adaptation_non_linear_response_compression_forward_derivative_wheatley(ql, stage);\n\n    // precompute lower Quadratic parameters\n    nl_a2\[stage]            = (ql * ql_derivative - nl_fql\[stage]) / (ql * ql);\n    nl_a1\[stage]            = ql_derivative - 2 * ql * nl_a2\[stage];\n    nl_a0\[stage]            = 0.0; // TODO for now pass through origin\n    nl_b_\[stage]            = nl_a1\[stage] / nl_a2\[stage];\n    nl_average_roots\[stage] = -nl_b_\[stage] / 2;\n  \}\n\n  void initialise_non_linearities()\n  \{\n    nl_gamma     = 0.42f;\n    nl_normalise = 100.0f;\n    nl_scale     = 400.0f;\n    nl_offset    = 27.13f;\n    nl_d_scale   = nl_gamma * nl_scale * nl_offset;\n\n    for (int i = 0; i < 3; ++i)\n    \{\n      initialise_non_linearity(i);\n    \}\n  \}\n\n  void initialise_cusp_table(float3 * output_table, const int table_size, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[360];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[360] = output_table\[0];\n    output_table\[360].z = output_table\[360].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 * tableUnsorted, const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 * output_table, const int table_size, const float limitJ, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float2 estimated_hull_gammas = float2(1.0f / topGamma, 1.0f / lowerHullGamma);\n    const float  focusJ                = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = compute_slope_gain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x = 1.0f / upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = limitingCuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = 1.0f / testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize] = gamutGammas\[0];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, 1.0f / bottomGamma);\n    const float focusJ                 = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = compute_slope_gain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = 1.0f / lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y    = -5.0f;\n      const float2 JMcusp = limitingCuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].y = 1.0f / testGamma;\n    \}\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh, 2);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, 0);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        diagnostic = JMh_to_output_RGB(JMh);\n      else\n        diagnostic = JMh_to_output_RGB(srcRGB);\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if ((diagnosticMode == 14) || (diagnosticMode == 15))\n    \{\n      // output gamut cusp\n      const float2 JMcusp = limitingCuspFromTable(wrap_to_360(srcRGB.z));\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = getReachBoundary(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if ((diagnosticMode == 21) || (diagnosticMode == 27))\n    \{\n      const float2 estimated_hull_gammas = hueDependantHullGammas(wrap_to_360(srcRGB.z));\n      diagnostic                         = float3(estimated_hull_gammas.x, estimated_hull_gammas.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = limitingCuspFromTable(wrap_to_360(srcRGB.z));\n      // create test value halfway between the cusp and the Jmax\n      diagnostic = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if ((diagnosticMode == 23) || (diagnosticMode == 24))\n    \{\n      float2 JMcusp = limitingCuspFromTable(wrap_to_360(srcRGB.z));\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain = limitJmax * focusDist; // TODO: is this diagnostic correct no focus gain in calculation\n      float3 testJmh    = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n\n      const float2 estimated_hull_gammas = hueDependantHullGammas(wrap_to_360(JMh.z));\n      float3       approxLimit =\n        findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      diagnostic = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n      if (diagnosticMode == 24)\n      \{\n        diagnostic = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), XYZ_to_RGB_limit);\n      \}\n    \}\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp     = limitingCuspFromTable(wrap_to_360(srcRGB.z));\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = compute_slope_gain(JMh.x, JMcusp.x);\n\n      const float2 estimated_hull_gammas = hueDependantHullGammas(wrap_to_360(JMh.z));\n      float3       ganutBoundary =\n        findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      diagnostic = float3(srcRGB.x, ganutBoundary.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, outputViewingConditions, HK_mode_out, 2);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = limitingCuspFromTable(wrap_to_360(srcRGB.z));\n\n      const float2 estimated_hull_gammas = hueDependantHullGammas(wrap_to_360(JMh.z));\n      diagnostic =\n        findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.000001f, estimated_hull_gammas);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, viewingConditions, HK_mode_in, 0);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = forwardTonescale(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, outputViewingConditions, HK_mode_out, 2);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, viewingConditions, HK_mode_out, 2);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      srcRGB.z = wrap_to_360(srcRGB.z);\n      diagnostic = inverseTonescale(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, viewingConditions, HK_mode_in, 0);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 300)\n    \{\n      diagnostic = post_adaptation_non_linear_response_compression_forward(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 301)\n    \{\n      diagnostic = post_adaptation_non_linear_response_compression_inverse(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 302)\n    \{\n      diagnostic = float3(limitJmax, RGB_to_XYZ_limit\[0]\[0], RGB_to_XYZ_limit\[0]\[1]);\n    \}\n    else if (diagnosticMode == 303)\n    \{\n      diagnostic = float3(A_w\[0], A_w\[1], A_w\[2]);\n    \}\n    else if (diagnosticMode == 304)\n    \{\n      diagnostic = float3(y_to_j_A_w\[0], y_to_j_A_w\[1], y_to_j_A_w\[2]);\n    \}\n    else if (diagnosticMode == 305)\n    \{\n      const float value = cReachFromTable(wrap_to_360(srcRGB.z));\n      diagnostic = float3(value, value, srcRGB.z);\n    \}\n    else if (diagnosticMode == 306)\n    \{\n      const float2 value = ccuspFromTable(wrap_to_360(srcRGB.z));\n      diagnostic = float3(value.x, value.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 307)\n    \{\n      const float3 value = cgamutCuspTable\[int(wrap_to_360(srcRGB.z))];\n      diagnostic = float3(value.x, value.y, value.z);\n    \}\n    else if (diagnosticMode == 308)\n    \{\n      const float value = eccentricity_factor(radians(wrap_to_360(srcRGB.z)));\n      diagnostic = float3(value, cc_et, srcRGB.z);\n    \}\n \n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_gamutCuspTableSize 360
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.13 -0.14}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -200
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
set Nbffe730 [stack 0]
 Group {
  name CAM_DRT_Encodie
  xpos -784
  ypos -134
  addUserKnob {20 User}
  addUserKnob {4 Direction M {Decode Encode}}
  Direction Encode
  addUserKnob {4 Primaries M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI XYZ}}
  Primaries sRGB/Rec.709-D65
  addUserKnob {4 Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084}}
  Encoding "BT.1886 (Gamma 2.4)"
  addUserKnob {7 referenceLuminance l "Reference Luminance" R 0 200}
  referenceLuminance 100
 }
  Input {
   inputs 0
   name Input1
   xpos 228
   ypos -39
  }
  Constant {
   inputs 0
   channels rgb
   format "256 256 0 0 256 256 1 square_256"
   name Constant1
   xpos 110
   ypos 11
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input]"}}
   name Switch1
   xpos 228
   ypos 25
  }
  BlinkScript {
   kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/CAM_DRT_encoding.blink
   recompileCount 35
   ProgramGroup 1
   KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 8ec7b00fc474b7dec7b553cfae312d5d0b67d05ae2dfd24ac90ab9d923e874cc 2 \"src\" Read Point \"dst\" Write Point 4 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Primaries\" Int 1 AAAAAA== \"Reference Luminance\" Float 1 AADIQg== 4 \"invert\" 1 1 Default \"encoding\" 1 1 Default \"primaries\" 1 1 Default \"referenceLuminance\" 1 1 Default 10 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_L_p\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n  float3 st2084_L_p;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(primaries, \"Primaries\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 100.0f; // Scale so 100 is 1.0f for Nuke\n\n\n    // clang-format off\n    float identity_matrix\[] = \{\n       1.0f,  0.0f,  0.0f,\n       0.0f,  1.0f,  0.0f,\n       0.0f,  0.0f,  1.0f,\n    \};\n\n    float XYZ_to_AP0_ACES_matrix\[] = \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f,\n    \};\n\n    float XYZ_to_AP1_ACES_matrix\[] = \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f, \n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix\[] = \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix\[] = \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix\[] = \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix\[] = \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f,\n    \};\n    // clang-format on\n\n    // populate the input primaries matrix\n    if (primaries == 0)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_AP0_ACES_matrix);\n    \}\n    else if (primaries == 1)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_AP1_ACES_matrix);\n    \}\n    else if (primaries == 2)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_Rec709_D65_matrix);\n    \}\n    else if (primaries == 3)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_Rec2020_D65_matrix);\n    \}\n    else if (primaries == 4)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_P3_D65_matrix);\n    \}\n    else if (primaries == 5)\n    \{\n      XYZ_to_RGB.setArray(XYZ_to_P3_DCI_matrix);\n    \}\n    else\n    \{\n      XYZ_to_RGB.setArray(identity_matrix);\n    \}\n    RGB_to_XYZ = XYZ_to_RGB.invert();\n  \}\n\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  float3 linear_to_ST2084(float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f, 2.4f, 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f, 2.6f, 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * referenceLuminance;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v = v / referenceLuminance;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f, 1.0f / 2.6f, 1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
   rebuild ""
   DRT_CAM_Kernel_Direction {{parent.Direction}}
   DRT_CAM_Kernel_Encoding {{parent.Encoding}}
   DRT_CAM_Kernel_Primaries {{parent.Primaries}}
   "DRT_CAM_Kernel_Reference Luminance" {{parent.referenceLuminance}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 228
   ypos 78
  }
  Output {
   name Output1
   xpos 228
   ypos 149
  }
 end_group
push $Nbffe730
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
