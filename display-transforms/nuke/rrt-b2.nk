set cut_paste_input [stack 0]
version 13.0 v3
push $cut_paste_input
BlinkScript {
 kernelSourceFile /Users/afry/GitHub/ACES2_HuePreservingOT/rrt-b2.blink
 recompileCount 93
 KernelDescription "2 \"rrt_b2\" iterate pixelWise 8b7651aeadcdf336bb39150def37cb3d6a10ac850745e53da40db06430e882c2 2 \"src\" Read Point \"dst\" Write Point 20 \"inverse\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"restoreVsOriginal\" Bool 1 AA== \"useSmartClip\" Bool 1 AA== \"Lp\" Float 1 AAAAAA== \"su\" Float 1 AAAAAA== \"c0\" Float 1 AAAAAA== \"cs\" Float 1 AAAAAA== \"c1\" Float 1 AAAAAA== \"p\" Float 1 AAAAAA== \"w1\" Float 1 AAAAAA== \"s1\" Float 1 AAAAAA== \"ex\" Float 1 AAAAAA== \"eb\" Float 1 AAAAAA== \"e0\" Float 1 AAAAAA== \"s0\" Float 1 AAAAAA== \"fl\" Float 1 AAAAAA== \"dch\" Float 1 AAAAAA== \"sat\" Float 1 AAAAAA== 20 \"inverse\" 1 1 \"primariesIn\" 1 1 \"primariesOut\" 1 1 \"restoreVsOriginal\" 1 1 \"useSmartClip\" 1 1 \"Lp\" 1 1 \"su\" 1 1 \"c0\" 1 1 \"cs\" 1 1 \"c1\" 1 1 \"p\" 1 1 \"w1\" 1 1 \"s1\" 1 1 \"ex\" 1 1 \"eb\" 1 1 \"e0\" 1 1 \"s0\" 1 1 \"fl\" 1 1 \"dch\" 1 1 \"sat\" 1 1 8 \"XYZ_to_AP0_ACES_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_2_RENDERING_PRI_MAT\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_2_DISPLAY_PRI_MAT\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"D60_2_D65_CAT\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"HALF_MIN\" Float 1 1 AAAAAA== \"HALF_MAX\" Float 1 1 AAAAAA=="
 kernelSource "\nkernel rrt_b2 : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    bool inverse;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Tonescale select\n\n    bool restoreVsOriginal;\n    bool useSmartClip;\n    // OpenDRT tonescale parameters\n    float Lp;\n    float su;\n    float c0;\n    float cs;\n    float c1;\n    float p;\n    float w1;\n    float s1;\n    float ex;\n    float eb;\n    float e0;\n    float s0;\n    float fl;\n    float dch;\n    float sat;\n\n  local:\n    float3x3 XYZ_to_AP0_ACES_matrix;\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_output;\n    float3x3 XYZ_2_RENDERING_PRI_MAT;\n    float3x3 XYZ_2_DISPLAY_PRI_MAT;\n    float3x3 D60_2_D65_CAT;\n    float HALF_MIN;\n    float HALF_MAX;\n    // constants\n  void define()\n  \{\n\n\n  \}\n\n\n\n\n  // get the y value of f(x) where the fuction is defined as a line between two points\n  // the two points as passed as an array \[a.x, a.y, b.x, b.y]\n  float lerp1D( float4 table, float x)\n  \{\n    float m = (table.w-table.y) / (table.z-table.x);\n    float c = table.y - (m*table.x);\n    float y = x*m+c;\n    return y;\n  \}\n\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially retured -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  int3 order3( float r, float g, float b )\n  \{  \n    // Determine sort order, highest to lowest\n    // float r = inRGB.x;\n    // float g = inRGB.y;\n    // float b = inRGB.z;\n\n     if (r > g) \{\n        if (g > b) \{                    // r g b, hue \[0,60]\n            int3 order = int3(0, 1, 2);\n           return order;\n        \} else \{\n           if (r > b) \{                 // r b g, hue \[300,360]\n            int3 order = int3(0, 2, 1);\n              return order;\n           \} else \{                     // b r g, hue \[240,300]\n            int3 order = int3(2, 0, 1);\n              return order;\n           \}\n        \}\n     \}\n     else \{\n        if (r > b) \{                    // g r b, hue \[60,120]\n            int3 order = int3(1, 0, 2);\n           return order;\n        \} else \{\n           if (g > b) \{                 // g b r, hue \[120,180]\n            int3 order = int3(1, 2, 0);\n              return order;\n           \} else \{                     // b g r, hue \[180,240]\n            int3 order = int3(2, 1, 0);\n              return order;\n           \}\n        \}\n     \}\n  \}\n\n  // Modify the hue of post_tone to match pre_tone\n   float3 restore_hue_dw3( float3 pre_tone, float3 post_tone)\n        \{\n        int3 inds = order3( pre_tone\[0], pre_tone\[1], pre_tone\[2]);\n\n        float orig_chroma = pre_tone\[ inds\[0]] - pre_tone\[ inds\[2]]; \n\n        float hue_factor = ( pre_tone\[ inds\[1] ] - pre_tone\[ inds\[2] ]) / orig_chroma;\n\n        if ( orig_chroma == 0.) hue_factor = 0.;\n\n        float new_chroma = post_tone\[ inds\[0] ] - post_tone\[ inds\[2] ];\n\n        float3 out;\n        out\[ inds\[ 0] ] = post_tone\[ inds\[0] ];\n        out\[ inds\[ 1] ] = hue_factor * new_chroma + post_tone\[ inds\[2] ];\n        out\[ inds\[ 2] ] = post_tone\[ inds\[2] ];\n\n        return out;\n    \}\n\n  float forwardMmTonescale(float x)\n  \{\n      float tc = 0.0f;\n      if (x<0.18)\n      \{\n          tc = cs*spow(x,c0);\n      \}\n      else\n      \{\n          tc = c0*(x-0.18)+0.18;\n      \}\n      \n      float ts = s1*spow((tc/(s0+tc)),p);\n      float tf = ts*ts/(ts+fl);\n      float ccf = spow(s0/(x+s0),dch)*sat;\n\n      return tf;\n  \}\n\n  float inverseMmTonescale(float x)\n  \{\n\n      float tf = (x+sqrt(x*(4*fl+x)))/2;\n      float ts = s0/(spow((s1/tf),(1/p))-1);\n      float tc = 0.0f;\n      if (ts<0.18)\n      \{\n          tc = spow((ts/cs),(1/c0));\n      \}\n      else\n      \{\n          tc = (ts-0.18)/c0+0.18;\n      \}\n      float ccf = spow(s0/(tc+s0),dch)*sat;\n\n      return tc;\n  \}\n\n\n  void init()\n  \{\n\n    HALF_MIN = 0.0000000596046448f;\n    HALF_MAX = 65504.0f;\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n  \n    float XYZ_to_ScottsRenderPrimsA_data\[]=\n    \{\n        1.06474f, 0.035824f, -0.0496937f,\n        -0.476653f, 1.3328f, 0.120238f,\n        0.0857931f, 0.0623069f, 0.848677f,\n    \};\n  \n    float D60_2_D65_CAT_data\[]=\n    \{\n        0.987239f, -0.00610704f, 0.0159267f,\n        -0.00759181f, 1.00186f, 0.00532147f,\n        0.003067f, -0.00508641f, 1.08154f,\n    \};\n    \n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n        0.0f, 0.0f, 1.0f \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n        XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n        XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n        XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n        XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n        XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n        XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n        XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n        XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n        XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n        XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n        XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n        XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n        XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n        XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    XYZ_to_AP0_ACES_matrix.setArray(XYZ_to_AP0_ACES_matrix_data);\n    XYZ_2_RENDERING_PRI_MAT.setArray(XYZ_to_ScottsRenderPrimsA_data);\n    XYZ_2_DISPLAY_PRI_MAT.setArray(XYZ_to_Rec709_D65_matrix_data);\n    D60_2_D65_CAT.setArray(D60_2_D65_CAT_data);\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 mappedVals;\n    \n    float3 aces(source.x, source.y, source.z);\n    \n    float3 rgbPre  = vector_dot(XYZ_to_RGB_input.invert(), aces);\n    rgbPre  = vector_dot(XYZ_2_RENDERING_PRI_MAT, rgbPre);\n    float3 rgbPre_clamped = clamp3(rgbPre, 0.0f, HALF_MAX);\n\n    // Apply the tone scale\n\t  float3 rgbPost;\n\t  rgbPost.x = forwardMmTonescale(rgbPre_clamped.x);\n      rgbPost.y = forwardMmTonescale(rgbPre_clamped.y);\n      rgbPost.z = forwardMmTonescale(rgbPre_clamped.z);\n\n      rgbPost = restore_hue_dw3( rgbPre, rgbPost);\n\n    // Switch to see if there is any effect of doing the ratio-restore based on the\n    // pre-clamped or clamped RGB input.\n    if (restoreVsOriginal) \{ // Restore the hue to the pre-tonescale hue\n        rgbPost = restore_hue_dw3( rgbPre, rgbPost);\n    \} else \{ // otherwise, restore using the RGB rendering space values clamped\n        // Restore the hue to the pre-tonescale hue\n        rgbPost = restore_hue_dw3( rgbPre_clamped, rgbPost);\t  \n    \}\n    \n    // --- ODT ---\n    // Convert from rendering primaries RGB encoding to display encoding primaries\n    float3 XYZ = vector_dot( XYZ_2_RENDERING_PRI_MAT.invert(),rgbPost);\n\n    // Apply CAT from ACES white point to assumed observer adapted white point\n    XYZ = vector_dot( D60_2_D65_CAT, XYZ); \n\n    // CIE XYZ to display primaries\n    float3 lin_displayRGB = vector_dot( XYZ_to_RGB_output, XYZ);\n\n    float3 lin_displayRGB_clamped = clamp3( lin_displayRGB, 0.0, Lp/100.0f);\n    // This is a useful toggle to see impact on how saturated OOG values clamp to the \n    // display gamut boundary triangle.\n    if (useSmartClip) \{\n        lin_displayRGB = restore_hue_dw3( lin_displayRGB, lin_displayRGB_clamped); \n    \} else \{\n        lin_displayRGB = lin_displayRGB_clamped;\n    \}\n\n    float3 dstRGB;\n    dstRGB = lin_displayRGB;\n\n    dst() = float4(dstRGB.x, dstRGB.y, dstRGB.z, source.w); \n  \}\n\};\n"
 rebuild ""
 rrt_b2_primariesOut 2
 rrt_b2_Lp 100
 rrt_b2_su 2
 rrt_b2_c0 1.2
 rrt_b2_cs {{0.18**(1-rrt_b2_c0)}}
 rrt_b2_c1 1.1
 rrt_b2_p {{rrt_b2_c1*(0.9+0.05*rrt_b2_su)}}
 rrt_b2_w1 {{(0.595*rrt_b2_Lp/10000)**0.931+1.037}}
 rrt_b2_s1 {{rrt_b2_w1*rrt_b2_Lp/100}}
 rrt_b2_ex -0.26
 rrt_b2_eb 0.08
 rrt_b2_e0 {{2**(rrt_b2_ex+rrt_b2_eb*log(rrt_b2_s1)/log(2))}}
 rrt_b2_s0 {{(rrt_b2_s1/rrt_b2_e0)**(1/rrt_b2_c1)}}
 rrt_b2_fl 0.01
 rrt_b2_dch 0.55
 rrt_b2_sat {{max(1,1.125-0.00025*rrt_b2_Lp)}}
 rebuild_finalise ""
 name BlinkScript3
 selected true
 xpos -1526
 ypos 492
}
