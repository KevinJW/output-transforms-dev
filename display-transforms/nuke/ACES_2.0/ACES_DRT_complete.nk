#! /opt/foundry/nuke-14.1v1/libnuke-14.1.1.so -nx
version 14.1 v1
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="27" w="1920" h="1028" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="1214"/>
            <splitter orientation="1">
                <split size="40"/>
                <dock id="" hideTitles="1" activePageId="Toolbar.1">
                    <page id="Toolbar.1"/>
                </dock>
                <split size="1170"/>
                <splitter orientation="2">
                    <split size="578"/>
                    <dock id="" activePageId="Viewer.1">
                        <page id="Viewer.1"/>
                        <page id="uk.co.framestore.CompSaverWidget"/>
                        <page id="Viewer.2"/>
                    </dock>
                    <split size="407"/>
                    <dock id="" activePageId="DAG.1" focus="true">
                        <page id="DAG.1"/>
                        <page id="Curve Editor.1"/>
                        <page id="DopeSheet.1"/>
                        <page id="uk.co.thefoundry.scripteditor.1"/>
                        <page id="DAG.2"/>
                    </dock>
                </splitter>
            </splitter>
            <split size="702"/>
            <splitter orientation="2">
                <split size="888"/>
                <dock id="" activePageId="Properties.1">
                    <page id="Properties.1"/>
                </dock>
                <split size="97"/>
                <dock id="" activePageId="Progress.1">
                    <page id="Progress.1"/>
                </dock>
            </splitter>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_complete.nk
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Read {
 inputs 0
 file_type exr
 file /net/homes/kwheatle/shows/main/colour/images/SonyF35.StillLife.exr
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 origset true
 raw true
 name Read1
 xpos 149
 ypos -288
}
set Nc37b150 [stack 0]
Group {
 name DRT_CAMv11
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 345
 ypos -195
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 500
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit sRGB/Rec.709
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out Rec.2020-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4095
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *HelmholtzKohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *HelmholtzKohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {94 49}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
push $Nc37b150
Group {
 name ACES_DRT_FULL
 xpos 146
 ypos -179
 addUserKnob {20 User}
 addUserKnob {26 Input}
 addUserKnob {4 InEncoding l Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "" "" ""}}
 addUserKnob {4 InPrimaries l Primaries -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI XYZ "" "" "" "" "" ""}}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 Limit l "Limiting Gamut"}
 addUserKnob {4 LimitingWhitePoint l "White point" -STARTLINE M {"ACES White" D65 "" ""}}
 LimitingWhitePoint D65
 addUserKnob {4 LimitPrimaries l Primaries -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" "" ""}}
 LimitPrimaries sRGB/Rec.709
 addUserKnob {7 PeakLuminance l " Peak Luminance" R 10 10000}
 PeakLuminance 500
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 Limiter l Scale/Clipping}
 addUserKnob {6 WhiteScale l "White Scaling" +STARTLINE}
 WhiteScale true
 addUserKnob {6 HardClip l "Hard Clip" +STARTLINE}
 HardClip true
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 Encoding l "Encoding Space"}
 addUserKnob {4 OutPrimaries l Primaries M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI XYZ}}
 OutPrimaries Rec.2020-D65
 addUserKnob {4 OutEncoding l EOTF -STARTLINE M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "" ""}}
 OutEncoding "BT.1886 (Gamma 2.4)"
 addUserKnob {26 "" +STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  color {0.801596 0.176808 -0.198404 0}
  color_panelDropped true
  format "256 256 0 0 256 256 1 square_256"
  name NoInput
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 41
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d124d2c8ae9c6120f9eb8be3b6785b14dded8d16d68f1f96ad31364aff64fd5d 2 \"src\" Read Point \"dst\" Write Point 4 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Primaries\" Int 1 AAAAAA== \"Reference Luminance\" Float 1 AADIQg== 4 \"invert\" 1 1 Default \"encoding\" 1 1 Default \"primaries\" 1 1 Default \"referenceLuminance\" 1 1 Default 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_L_p\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: XYZ\n  int primaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n  float3 st2084_L_p;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(primaries, \"Primaries\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 100.0f; // Scale so 100 is 1.0f for Nuke\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    RGB_to_XYZ = generate_RGB_to_XYZ_matrix(primaries);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n  \}\n\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  float3 linear_to_ST2084(float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f, 2.4f, 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f, 2.6f, 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * referenceLuminance;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v = v / referenceLuminance;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f, 1.0f / 2.6f, 1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Encoding {{parent.InEncoding}}
  ACES_DRT_Encoding_Kernel_Primaries {{parent.InPrimaries}}
  rebuild_finalise ""
  name Decode
  xpos 228
  ypos 49
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 215
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Kernel\" iterate pixelWise 348cf901d5414c89a8f2a65bb7a411d8188ff06b585dc6eb5664875dbcf0bd9f 2 \"src\" Read Point \"dst\" Write Point 43 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 1 AABAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 43 \"invert\" 1 1 Default \"AP1Clamp\" 1 1 Default \"_peakLuminance\" 1 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"_inputViewingConditions\" 1 1 Default \"L_A_in\" 1 1 Default \"Y_b_in\" 1 1 Default \"_outputViewingConditions\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default \"_userSurround\" 3 1 Default \"_XYZ_w_scaler\" 1 1 Default \"diagnosticMode\" 1 1 Default \"_smoothCusps\" 1 1 Default \"_smoothOffset\" 2 1 Default \"_cuspMidBlend\" 1 1 Default \"_focusGainBlend\" 1 1 Default \"_focusAdjustGain\" 1 1 Default \"_focusDistance\" 1 1 Default \"_focusDistanceScaling\" 1 1 Default \"_compressionFuncParams\" 1 1 Default \"LMS_rxy\" 2 1 Default \"LMS_gxy\" 2 1 Default \"LMS_bxy\" 2 1 Default \"LMS_wxy\" 2 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"aces_ts_n_r\" 1 1 Default \"aces_ts_g\" 1 1 Default \"aces_ts_c\" 1 1 Default \"aces_ts_c_d\" 1 1 Default \"aces_ts_w_g\" 1 1 Default \"aces_ts_t_1\" 1 1 Default \"aces_ts_r_hit_min\" 1 1 Default \"aces_ts_r_hit_max\" 1 1 Default 55 \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"DL_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DL_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"achromatic_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"A_w\" Float 1 2 AAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"hueTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"limitingGamutCuspTable\" Float 4 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachMTable\" Float 2 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"reach_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"inputWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"smooth_cusp_scale\" Float 2 1 AAAAAAAAAAA= \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_base_slope\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"aces_ts_n\" Float 1 1 AAAAAA== \"aces_ts_u\" Float 1 1 AAAAAA== \"aces_ts_m\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_u_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"aces_ts_inv_upper_limit\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#define DEBUG_limitingGamutCuspTableRaw 60\n#define DEBUG_limitingGamutCuspTableRaw2 61\n#define DEBUG_reachMTableRaw 62\n\n\n#define DEBUG_Jconstants 70\n#define DEBUG_FocusConstants 71\n#define DEBUG_limitingFocusJ 72\n#define DEBUG_reachMConditions 73\n\n#define DEBUG_gamutCompressAlphaFORWARDS 80\n#define DEBUG_gamutCompressAlphaINVERSE 81\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold\n  float _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3x3 identity_matrix;\n\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n\n  float3 DL_weights\[NUMBER_CONDITIONS];\n  float3 DM_weights\[NUMBER_CONDITIONS];\n  float3 DS_weights\[NUMBER_CONDITIONS];\n  \n  float3 DL_weights_inv\[NUMBER_CONDITIONS];\n  float3 DM_weights_inv\[NUMBER_CONDITIONS];\n  float3 DS_weights_inv\[NUMBER_CONDITIONS];\n\n  float3 achromatic_w;\n  float3 a_w;\n  float3 b_w;\n\n  float3 achromatic_weights\[NUMBER_CONDITIONS];\n  float3 a_weights\[NUMBER_CONDITIONS];\n  float3 b_weights\[NUMBER_CONDITIONS];\n\n  float3 achromatic_weights_inv\[NUMBER_CONDITIONS];\n  float3 a_weights_inv\[NUMBER_CONDITIONS];\n  float3 b_weights_inv\[NUMBER_CONDITIONS];\n\n  float3x3 panlrcm;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Reference Luminance in Cd/sqm\n#define referenceLuminance 100.0f\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n\n#define j_scale      100.0f\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  A_w\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n\n//#define USE_DEGREES\n#ifdef USE_DEGREES\n#define hue_limit 360.0f\n#else\n#define hue_limit (2 * PI)\n#endif\n#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range \[0.0, hue_limit) needs to be a multiple of 6 to sample hull corners\n#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases\n#define totalTableSize gamutCuspTableSize + additonal_entries\n#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle\n\n#define gammaAccuracy 5e-6\n#define gammaMinimum 0.4f\n#define gammaMaximum 2.0f\n#define gammaSearchStep 0.2f\n#define badGammaTollerance 1e-2f\n#define hueFindingTollerance 1e-7f\n\n  // Non-uniform in h\n  float  hueTable\[totalTableSize];\n  float4 limitingGamutCuspTable\[totalTableSize];    // \{ J, M, Upper gamma, Lower gamma \}\n  float2 reachMTable\[totalTableSize];               // \{ reachCuspM, reachM \}\n\n// Note reuse of Hue channel 2\n#define UPPER_GAMMA 2\n#define LOWER_GAMMA 3\n\n#define REACHCUSPM 0\n#define REACHM 1\n\n  float3 reach_cusp_corners\[8];\n  float3 reach_JMh_corners\[8];\n\n  float3 display_cusp_corners\[8];\n  float3 display_JMh_corners\[8];\n\n  float3 inputWhite;\n  float3 limitWhite;\n\n  float  clamped_smoothness;\n  float2 smooth_cusp_scale;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma; // TODO: investigate uses of this\n  float _base_slope;\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n\n  float aces_ts_n;         // peak white\n  float aces_ts_u;\n  float aces_ts_m;\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_u_2;\n  float aces_ts_m_2;\n  float aces_ts_inv_upper_limit;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9, 0.59, 0.9));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", 0.75f);\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(1.0f / 3.0f, 1.0f / 3.0f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (PRIMARIES_AP0 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_AP1 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_Rec709 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, FORWARDS);\n    \}\n    else if (PRIMARIES_Rec2020 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3D65 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3DCI == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, FORWARDS);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_w = nl_scale * float3(ra, 1.0f, ba);\n    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;\n\n    panlrcm =  constuct_inverse_matrix(achromatic_w, a_w, b_w);\n\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = (460.0f / panlrcm\[i]\[0]) / 1403.0f;\n      panlrcm\[i]\[0] *= n / nl_scale;\n      panlrcm\[i]\[1] *= n / nl_scale;\n      panlrcm\[i]\[2] *= n / nl_scale;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  float2 get_whitepoint(int which)\n  \{\n    if (which == 0)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which == 1)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n\n    return  float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void init_matrices()\n  \{\n    identity_matrix.setIdentity();\n\n    CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(PRIMARIES_AP1);\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix = get_whitepoint(whiteLimit);\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001f, -0.077f);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    inputWhite = vector_dot(AP1_to_XYZ, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n  \}\n\n  void init_chroma_compression(float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / aces_ts_n;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  void init_gamut_mapper(float log_peak)\n  \{\n    clamped_smoothness  = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?\n    smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(limitWhite * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = linear_RGB_to_JMh(float3(_peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n    _base_slope = _limitJmax * _focusDist;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  void build_cusp_corners_tables(float3 RGB_corners\[8], float3 JMh_corners\[8], const int rgb_conditions, const float3x3& rgb_matrix, const float peak)\n  \{\n    // Calculate hues for corners\n#define cuspCornerCount 6\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      // Generage order R, Y, G, C, B, M\n      temp_cusp_corners\[i] = peak * float3(int(((i+1)%cuspCornerCount) < 3), int(((i+5)%cuspCornerCount) < 3), int(((i+3)%cuspCornerCount) < 3));\n      temp_JMh_corners\[i] = linear_RGB_to_JMh(temp_cusp_corners\[i], rgb_matrix, rgb_conditions);\n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      RGB_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n    RGB_corners\[0]                   = RGB_corners\[cuspCornerCount];\n    RGB_corners\[cuspCornerCount+1]   = RGB_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  float2 find_reach_cusp_for_hue(float hue, const float3x3& rgb_matrix, const int rgb_conditions, const float peak, const float tollerance)\n  \{\n    int upper_corner = 1;\n    for (int i = 1; i != 8; ++i) // TODO: binary search?\n    \{\n       if (reach_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // search by lerping between corners for the hue\n    const float3 cusp_lower = reach_cusp_corners\[lower_corner];\n    const float3 cusp_upper = reach_cusp_corners\[upper_corner];\n\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n    if (reach_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(reach_JMh_corners\[lower_corner].x, reach_JMh_corners\[lower_corner].y);\n    \}\n    float3 sample;\n    float sample_t;\n    if (upper_corner > 6)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = linear_RGB_to_JMh(sample, rgb_matrix, rgb_conditions);\n        if ((JMh.z < reach_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = linear_RGB_to_JMh(sample, rgb_matrix, rgb_conditions);\n        if ((JMh.z > reach_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = linear_RGB_to_JMh(sample, rgb_matrix, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  void initialise_cusp_table(float4 * output_table, const float3x3& matrix, const float luminance, const int conditions)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    const int table_size = gamutCuspTableSize;\n    float4 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f)) * float3(luminance);\n      const float3 cusp    = linear_RGB_to_JMh(RGB, matrix, conditions);\n      tempTableUnsorted\[i] = float4(cusp.x, cusp.y, cusp.z, 0.0f);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex, baseIndex);\n\n    // Copy extra entries to ease the code to handle hues wrapping around\n    output_table\[0]                              = output_table\[baseIndex + gamutCuspTableSize - 1];\n    output_table\[baseIndex + gamutCuspTableSize] = output_table\[baseIndex];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    output_table\[0].z = output_table\[0].z - hue_limit;\n    output_table\[baseIndex + gamutCuspTableSize].z = output_table\[baseIndex + gamutCuspTableSize].z + hue_limit;\n  \}\n\n  void copy_table_rotated(float4 * tableUnsorted, const int tableSize, float4 output_table\[], const int offsetIndex, const int baseOffset)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i+baseOffset] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void extract_hue_table(const float4 * table, float * hueTable)\n  \{\n    for (int i = 0; i < totalTableSize; ++i)\n    \{\n      hueTable\[i] = table\[i].z;\n    \}\n  \}\n\n  void smooth_cusp_table(float4 * table, const float2 scale)\n  \{\n    for (int i = 0; i < totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      table\[i].x      = table\[i].x * scale.x;\n      table\[i].y      = table\[i].y * scale.y;\n    \}\n  \}\n\n  void precompute_reach_table(float2 * reachMTable, float4 * reach_table, const float limitJ, const float3x3& xyz_matrix,\n                              const float3x3& rgb_matrix, const int conditions, const float peak)\n  \{\n    for (int i = 0; i < totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      //float2 JM = find_reach_cusp_for_hue(hue, rgb_matrix, conditions, peak, hueFindingTollerance);\n      reachMTable\[i]\[REACHCUSPM] = compressionCuspFromTable(hue, reach_table).y; // Resample compression cusp for Disply hues save on extra binary search \n      reachMTable\[i]\[REACHM]     = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);\n    \}\n  \}\n\n  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)\n  \{\n    const float search_range = 100.0;\n    float low     = 0.0;\n    float high    = low + search_range;\n    bool  outside = false;\n\n    while (!outside && high < 1400.0)\n    \{\n      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));\n      if (!outside)\n      \{\n        low  = high;\n        high = high + search_range;\n      \}\n    \}\n\n    while ((high - low) > threshold)\n    \{\n      const float sampleM = midpoint(low, high);\n      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));\n      if (outside)\n      \{\n        high = sampleM;\n      \}\n      else\n      \{\n        low = sampleM;\n      \}\n    \}\n    return high;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||\n        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,\n                               const float cuspMidBlend, const float focusAdjustGain, const float2 estimated_hull_gammas, const int conditions)\n  \{\n    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);\n    const float analytical_threshold = compute_analytical_threshold(JMcusp.x);\n    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);\n\n    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float approxLimit =\n        findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);\n    const float J_boundary       = slope * approxLimit + intersectJ;\n\n    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);\n    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);\n    return newLimitRGB;\n  \}\n\n  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float2 estimated_hull_gammas,\n                                     const float limitJmax, const float base_slope, const float midJ,\n                                     const float cuspMidBlend, const float focusAdjustGain,\n                                     const float luminance, const int conditions)\n  \{\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh\[testIndex], limitJmax, base_slope,\n                                                       midJ, cuspMidBlend, focusAdjustGain, estimated_hull_gammas, conditions);\n\n      if (!outside_hull(newLimitRGB, luminance))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(float4 * table, const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain,\n                                   const float luminance, const int conditions)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    const float fixed_gamma = 1.0f / upperHullGamma;\n    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)\n    \{\n      table\[i]\[UPPER_GAMMA] = -1.0f;\n      if (disableUpperHullGamma)\n      \{\n        table\[i]\[UPPER_GAMMA] = fixed_gamma;\n        continue;\n      \}\n\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      const float  hue                 = hueTable\[i];\n      const float4 cusp                = table\[i];\n      const float2 JMcusp              = float2(cusp.x, cusp.y);\n\n      float3 testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = gammaSearchStep;\n      float       low          = gammaMinimum;\n      float       high         = low + search_range;\n      bool        all_inside   = true;\n\n      while (all_inside && high < gammaMaximum)\n      \{\n        const float2 estimated_hull_gammas = float2(high, 1.0f / lowerHullGamma);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > gammaAccuracy)\n      \{\n        testGamma  = midpoint(low, high);\n        const float2 estimated_hull_gammas = float2(testGamma, 1.0f / lowerHullGamma);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (!all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      table\[i]\[UPPER_GAMMA] = testGamma;\n    \}\n    // Wrap the end entries\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  void initialise_lower_hull_gamma(float4 * table, const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain,\n                                   const float luminance, const int conditions)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n    const float fixed_gamma = 1.0f / lowerHullGamma;\n    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        table\[i]\[LOWER_GAMMA] = fixed_gamma;\n        continue;\n      \}\n\n      table\[i]\[LOWER_GAMMA]    = -5.0f;\n      const float4 cusp   = table\[i];\n      const float2 JMcusp = float2(cusp.x, cusp.y);\n      const float  hue    = hueTable\[i];\n\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = gammaSearchStep;\n      float       low          = gammaMinimum;\n      float       high         = low + search_range;\n      bool        all_inside   = true;\n\n      while (all_inside && high < gammaMaximum)\n      \{\n        const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, high);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > gammaAccuracy)\n      \{\n        testGamma  = midpoint(low, high);\n        const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, testGamma);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (!all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      table\[i]\[LOWER_GAMMA] = testGamma;\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  float replace_gamma_entry(float4 * table, int entry, int channel)\n  \{\n    // Very simple patch up, try to find good values either side and lerp a new value\n    int lower = entry - 1;\n    while (lower >= 0)\n    \{\n      if (!bad_gamma_value(table\[lower]\[channel]))\n        break;\n      lower = lower - 1;\n    \}\n    if (lower < 0)\n      return -1.0f; // Give up if we can't find a good entry below\n\n    int upper = entry + 1;\n    while (upper < baseIndex + gamutCuspTableSize)\n    \{\n      if (!bad_gamma_value(table\[upper]\[channel]))\n        break;\n      upper = upper + 1;\n    \}\n    if (upper == totalTableSize)\n      return -2.0f; // Give up nothing above us\n\n    float lower_hue = hueTable\[lower];\n    float upper_hue = hueTable\[upper];\n    float entry_hue = hueTable\[entry];\n    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);\n    return lerp(table\[lower]\[channel], table\[upper]\[channel], lerp_loc);\n  \}\n\n  bool bad_gamma_value(const float value)\n  \{\n    return ((value <= 0.0f) || (value <= gammaMinimum+badGammaTollerance) || (value >= gammaMaximum-badGammaTollerance));\n  \}\n\n  void repair_broken_gamma_values(float4 * table)\n  \{\n    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)\n    \{\n      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)\n      \{\n        if (bad_gamma_value(table\[i]\[channel]))\n        \{\n          table\[i]\[channel] = replace_gamma_entry(table, i, channel);\n        \}\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  inline float3 extract_row(const float3x3 matrix, int row)\n  \{\n    return \{matrix\[row]\[0], matrix\[row]\[1], matrix\[row]\[2]\};\n  \}\n\n  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)\n  \{\n    return weight * extract_row(matrix, row);\n  \}\n\n  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)\n  \{\n    float3x3 matrix;\n    matrix\[0]\[0] = a.x;\n    matrix\[0]\[1] = a.y;\n    matrix\[0]\[2] = a.z;\n    matrix\[1]\[0] = b.x;\n    matrix\[1]\[1] = b.y;\n    matrix\[1]\[2] = b.z;\n    matrix\[2]\[0] = c.x;\n    matrix\[2]\[1] = c.y;\n    matrix\[2]\[2] = c.z;\n    return matrix.invert();\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK, bool discountIlluminant, int stage)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0.0f, 1.0f);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k    = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4   = k * k * k * k;\n    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f); // TODO 0.2 * 5 ... pow(, s)\n    F_L\[stage]       = _F_L / nl_normalise; //TODO white scale?\n\n    // # FWd Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    //float3 RGB = vector_dot(CAT_CAT16, XYZ);\n    //float3 RGB_c = D_RGB\[conditions] * RGB; // combine with CAT16\n\n    // Pre weight CAT16 matrix by D\n    DL_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].x, CAT_CAT16, 0);\n    DM_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].y, CAT_CAT16, 1);\n    DS_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].z, CAT_CAT16, 2);\n\n    // # Inv Step 6\n    //const float3 RGB = RGB_c / D_RGB\[conditions];\n    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n    const float3x3 tempmat = constuct_inverse_matrix(DL_weights\[stage], DM_weights\[stage], DS_weights\[stage]);\n    DL_weights_inv\[stage] = extract_row(tempmat, 0);\n    DM_weights_inv\[stage] = extract_row(tempmat, 1);\n    DS_weights_inv\[stage] = extract_row(tempmat, 2);\n\n    // Prescale values\n    surround\[stage].y = surround\[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n    surround\[stage].z = surround\[stage].z * 43.0f;\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L\[stage] * RGB_wc);\n    A_w\[stage]          = dot(achromatic_w, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    y_to_j_A_w\[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);\n\n    achromatic_weights\[stage] = achromatic_w / A_w\[stage];\n    a_weights\[stage]          = surround\[stage].z * a_w;\n    b_weights\[stage]          = surround\[stage].z * b_w;\n\n    const float3 column_weights = float3(A_w\[stage], 1.0f / surround\[stage].z, 1.0f / surround\[stage].z);\n    achromatic_weights_inv\[stage]   = extract_row(panlrcm, 0) * column_weights;\n    a_weights_inv\[stage]            = extract_row(panlrcm, 1) * column_weights;\n    b_weights_inv\[stage]            = extract_row(panlrcm, 2) * column_weights;\n  \}\n\n  void init()\n  \{\n    init_tonescale_constants(_peakLuminance);\n\n    const float log_peak = log10(aces_ts_n / aces_ts_n_r);\n\n    init_matrices();\n\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS);\n\n    init_chroma_compression(log_peak);\n    init_gamut_mapper(log_peak);\n\n    build_cusp_corners_tables(reach_cusp_corners, reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _peakLuminance);\n    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);\n\n    initialise_cusp_table(limitingGamutCuspTable, RGB_to_XYZ_limit, _peakLuminance, DISPLAY_CONDITIONS);\n    extract_hue_table(limitingGamutCuspTable, hueTable);\n    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);\n    initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _peakLuminance, DISPLAY_CONDITIONS);\n    initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _peakLuminance, DISPLAY_CONDITIONS);\n    repair_broken_gamma_values(limitingGamutCuspTable);\n\n    float4 compressionGamutCuspTable\[totalTableSize];\n    initialise_cusp_table(compressionGamutCuspTable, AP1_to_XYZ, _peakLuminance, SOURCE_CONDITIONS);\n    precompute_reach_table(reachMTable, compressionGamutCuspTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS, _peakLuminance);\n  \}\n\n#ifdef USE_DEGREES\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float to_radians(float hue)\n  \{\n    return hue / 180.0f * PI;\n  \}\n#endif\n\n  inline float wrap_hue(float hue)\n  \{\n    float y = fmod(hue, hue_limit);\n    if (y < 0.0)\n    \{\n      y = y + hue_limit;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB        = clamp(RGB, float3\{0.0f\}, float3(16384.0f)); // limit to nice power of 2 above that needed to max out a 10000 Nit output transform\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_forward(float L)\n  \{\n    const float F_L_L = pow(L, float(nl_gamma));\n    return F_L_L / (nl_offset + F_L_L);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));\n    return F_L_RGB / (nl_offset + F_L_RGB);\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_inverse(float A)\n  \{\n    const float F_L_A = (nl_offset * A) / (1.0 - A);\n    return pow(F_L_A, 1.0f / nl_gamma);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 F_L_RGB = (nl_offset * RGB) / (1.0 - RGB);\n    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);\n    return RGB_c;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);\n    return RGB_p;\n  \}\n\n//  // Return compression gamut cusp M scaled with an eccentricity factor\n//  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n//  \{\n//    if (!apply_eccentricity)\n//    \{\n//        return 1.0f;\n//    \}\n//\n//    // Hellwig2022/Helles2023\n//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n//    const float _2_hr = 2 * hr;\n//    const float _3_hr = 3 * hr;\n//    const float _4_hr = 4 * hr;\n//    // clang-format off\n//    return (\n//        - 0.0582f * cos(_1_hr)\n//        - 0.0258f * cos(_2_hr)\n//        - 0.1347f * cos(_3_hr)\n//        + 0.0289f * cos(_4_hr)\n//        - 0.1475f * sin(_1_hr)\n//        - 0.0308f * sin(_2_hr)\n//        + 0.0385f * sin(_3_hr)\n//        + 0.0096f * sin(_4_hr)\n//        + 1.0f\n//      );\n//    // clang-format on\n//  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float _J_from_Achromatic(float A, int conditions)\n  \{\n    return j_scale * pow(A, surround\[conditions].y);\n  \}\n\n  inline float _Achromatic_from_J(float J, int conditions)\n  \{\n    return pow(J / j_scale, 1.0f / surround\[conditions].y);\n  \}\n\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * _J_from_Achromatic(fabs(A), conditions);\n  \}\n\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * _Achromatic_from_J(fabs(J), conditions);\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    float3 RGB_c;\n    RGB_c.x = dot(DL_weights\[conditions], XYZ);\n    RGB_c.y = dot(DM_weights\[conditions], XYZ);\n    RGB_c.z = dot(DS_weights\[conditions], XYZ);\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);\n\n    const float A = dot(achromatic_weights\[conditions], RGB_a);\n    const float a = dot(a_weights\[conditions], RGB_a);\n    const float b = dot(b_weights\[conditions], RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n#ifdef USE_DEGREES\n    const float h  = wrap_hue(degrees(hr));\n#else\n    const float h  = wrap_hue(hr);\n#endif\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    //const float et = eccentricity_factor(hr, false);\n    //float       M  = surround\[conditions].z * et * sqrt(a * a + b * b);\n    float M = sqrt(a * a + b * b); // Valid as et == 1.0\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n#ifdef USE_DEGREES\n    const float hr = to_radians(JMh.z);\n#else\n    const float hr = JMh.z;\n#endif\n\n    // # *HelmholtzKohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float _A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    //const float et    = eccentricity_factor(hr, false);\n    //const float P_p_1 = surround\[conditions].z; // * et;\n    //const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 Aab = float3(_A, a, b);\n    //const float3 RGB_a = vector_dot(panlrcm, Aab);\n    float3 RGB_a;\n    RGB_a.x = dot(achromatic_weights_inv\[conditions], Aab);\n    RGB_a.y = dot(a_weights_inv\[conditions], Aab);\n    RGB_a.z = dot(b_weights_inv\[conditions], Aab);\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);\n\n    float3 XYZ;\n    XYZ.x = dot(DL_weights_inv\[conditions], RGB_c);\n    XYZ.y = dot(DM_weights_inv\[conditions], RGB_c);\n    XYZ.z = dot(DS_weights_inv\[conditions], RGB_c);\n\n    return XYZ;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / hue_limit * table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b (cubic polynomial)\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline float smin_s(float a, float b, float s, float normalise)\n  \{\n    const float s_scaled     = s * normalise;\n    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;\n    const float h            = max(scaled_delta, 0.0f);\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  inline float midpoint(float low, float high)\n  \{\n    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document\n    return (high + low) * 0.5f;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  int lookupLimitingCuspHue(float wrapped_hue)\n  \{\n    int low_i  = 0;\n    int high_i = baseIndex + gamutCuspTableSize; // Allowed as we have extra entries in the table\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > hueTable\[i])\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float limiting_lerp_fraction(float wrapped_hue, int pos)\n  \{\n    return (wrapped_hue - hueTable\[pos - 1])\n          / (hueTable\[pos] - hueTable\[pos - 1]);\n  \}\n\n  inline float4 limitingCuspFromTable(int pos, float t)\n  \{\n    return lerp(limitingGamutCuspTable\[pos - 1], limitingGamutCuspTable\[pos], t);\n  \}\n\n  float4 compressionCuspFromTable(float wrapped_hue, float4 * compressionGamutCuspTable)\n  \{\n    // Avoid use within main pixel loop\n    float4 lo;\n    float4 hi;\n\n    int low_i  = 0;\n    int high_i = baseIndex + gamutCuspTableSize; // Allowed as we have extra entry in the table\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > compressionGamutCuspTable\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    lo = compressionGamutCuspTable\[high_i - 1];\n    hi = compressionGamutCuspTable\[high_i];\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    return lerp(lo, hi, t);\n  \}\n\n  inline float2 reachMFromTable(int pos, float t)\n  \{\n    return lerp(reachMTable\[pos - 1], reachMTable\[pos], t);\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)\n  \{\n    // Assume J (0.0, limitJmax)\n    \n    if (J <= analytical_threshold)\n      return 1.0f; // makes the analytic inverse possible below cusp\n\n    // Approximate inverse required above threshold TODO: explain why\n    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n  \}\n\n  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,\n                                  const float focusAdjustGain, const float analytical_threshold)\n  \{\n    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)\n  \{\n    float direction_scaler;\n    if (intersectJ <= focusJ)\n    \{\n      direction_scaler = intersectJ;\n    \}\n    else\n    \{\n       direction_scaler = (limitJmax - intersectJ);\n    \}\n\n    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);\n  \}\n\n  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,\n                                                         const float inv_gamma, const float J_max, const float M_max,\n                                                         const float J_intersection_reference)\n  \{\n    // Line defined by     J = slope * x + J_axis_intersect\n    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)\n    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential\n    \n    // We calculate a shifted intersection from the original intersection using the inverse of the exponential\n    // and the provided reference\n    const float normalised_J        = J_axis_intersect / J_intersection_reference;\n    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);\n\n    // Now we find the M intersection of two lines\n    // line from origin to J,M Max       l1(x) = J/M * x\n    // line from J Intersect' with slope l2(x) = slope * x + Intersect'\n\n    return shifted_intersecion / ((J_max / M_max) - slope);\n    //return shifted_intersecion * M_max / (J_max - slope * M_max);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,\n                                      float2 estimated_hull_gammas, const float slope)\n  \{\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);\n\n    // The upper hull is flipped and thus 'zerod' at J_max\n    // Also note we negate the slope\n    const float f_J_intersect_cusp = J_max - J_intersect_cusp;\n    const float f_J_intersect_source = J_max - J_intersect_source;\n    const float f_JM_cusp_J = J_max - JM_cusp.x;\n    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);\n\n    // Smooth minimum between the two calculated values for the M component\n    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n    return M_boundary;\n    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);\n  \}\n\n  inline float reinhard_compress(const float scale, const float factor, bool direction)\n  \{\n    if (INVERSE == direction)\n    \{\n      if (factor >= 1.0f)\n        return scale;\n      else\n        return scale * (-(factor / (factor - 1.0f)));\n    \}\n    return scale * (factor) / (1.0f + factor);\n  \}\n\n  inline float gamut_mapped_location(float location, const float gamutBoundary, const float reachBoundary, bool direction)\n  \{\n    // Assumes _compressionFuncParams in \[0.0, 1.0]\n    const float threshold = max(_compressionFuncParams, gamutBoundary / reachBoundary) * gamutBoundary;\n\n    // Values upto the threshold or when both boundaries are the same remain as is\n    if (location <= threshold || threshold == gamutBoundary)\n      return location;\n\n    // Translate to place threshold at zero\n    const float location_offset = location - threshold;\n    const float boundary_offset = gamutBoundary - threshold;\n    const float reach_offset    = reachBoundary - threshold;\n\n    // Assumes boundary != reach\n    // Generaly speaking boundary should be < reach\n    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);\n    const float factor = location_offset / scale;\n\n    const float relative_location = reinhard_compress(scale, factor, direction);\n\n    return (threshold + relative_location); // shift back to absolute\n  \}\n\n  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,\n                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,\n                    float reachMaxM, float model_gamma)\n  \{\n    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float ganutBoundaryM   = findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,\n                                                                  smoothness, estimated_hull_gammas, slope);\n\n    if (ganutBoundaryM <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)\n    \{\n      //return float2(999, ganutBoundaryM);\n      return float2(JM.x, 0.0f);\n    \}\n      //return float2(JM.x, ganutBoundaryM);\n\n    // Compress the out of gamut color along the projection line\n    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);\n    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);\n    const float mappedJ  = slope * mappedM + intersectJ;\n\n    return float2\{mappedJ, mappedM\};\n  \}\n\n  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));\n  \}\n\n  inline float compute_analytical_threshold(float cuspJ)\n  \{\n    return lerp(cuspJ, _limitJmax, _focusGainBlend);\n  \}\n\n  float3 gamutMapper(float3 JMh, const float4 cusp, const float2 reachM, bool direction)\n  \{\n    // Limit to +ve values // TODO test this is neededS\n    if (JMh.x <= 0.0f)\n    \{\n      JMh.x = 0.0f;\n      JMh.y = 0.0f;\n    \}\n    // Above the expected maximum we explicitly map to 0 M\n    if (JMh.x >= _limitJmax)\n    \{\n      JMh.y = 0.0f;\n    \}\n\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f)\n      return JMh;\n\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n\n    const float2 JMcusp                = float2(cusp.x, cusp.y);\n    const float  reachMaxM             = reachM\[REACHM];\n    const float2 estimated_hull_gammas = float2\{cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA]\};\n    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x); \n    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);\n\n    float  Jx         = JMh.x;\n    float2 JM         = float2\{JMh.x, JMh.y\};\n    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);\n \n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > analytical_threshold)\n      \{\n        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                        clamped_smoothness, reachMaxM, _model_gamma).x;\n        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);\n      \}\n    \}\n    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                    clamped_smoothness, reachMaxM, _model_gamma);\n\n    return \{JM.x, JM.y, JMh.z\};\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, int conditions)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, conditions);\n    return JMh;\n  \}\n\n  float3 JMh_to_linear_RGB(float3 JMh, const float3x3& matrix, int conditions)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, conditions);\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  void init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions\n    aces_ts_n = peakLuminance;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_n / aces_ts_n_r) / log(10000.0f / 100.0f));\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    aces_ts_u                  = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    aces_ts_m                  = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1) * referenceLuminance; // Factor in our reference\n    aces_ts_u_2                = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(const float Y)\n  \{\n    // Assumes Y is >= +0.0\n    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);\n    const float h = max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility\n    return h * _XYZ_w_scaler; // TODO: another normalised number\n  \}\n\n  inline float aces_ts_rev(const float Y)\n  \{\n    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?\n    const float h = Y / _XYZ_w_scaler;\n    const float f = (h + sqrt(h * (4.0f * aces_ts_t_1 + h))) / 2.0f;\n    return  aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float _Y_to_Hellwig_J(float Y, int conditions)\n  \{\n    // Assumes Y is >= +0.0\n    const float A = _post_adaptation_non_linear_response_compression_forward(F_L\[conditions] * Y) / y_to_j_A_w\[conditions];\n    return _J_from_Achromatic(A, conditions);\n  \}\n\n  inline float _Hellwig_J_to_Y(float J, int conditions)\n  \{\n    // Assumes J is >= +0.0\n    const float A = y_to_j_A_w\[conditions] * _Achromatic_from_J(J, conditions);\n    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L\[conditions];\n  \}\n\n//  inline float Y_to_Hellwig_J(float Y, int conditions)\n//  \{\n//    const float absY = fabs(Y);\n//    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?\n//  \}\n//\n//  inline float Hellwig_J_to_Y(float J, int conditions)\n//  \{\n//    const float absJ = fabs(J);\n//    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?\n//  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions)\n  \{\n    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below\n    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);\n    const float  luminanceTS   = aces_ts_fwd(inputY);\n    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);\n    return float3(tonemappedJ, inputJMh.y, inputJMh.z);\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);\n    const float  linear          = aces_ts_rev(luminance);\n    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);\n    return float3(untonemappedJ, JMh.y, JMh.z);\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, bool inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2             = max(k2, 0.001f); // TODO; magic constant\n    k1             = sqrt(k1 * k1 + k2 * k2);\n    const float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n    \{\n      const float minus_b = k3 * x - k1;\n      const float minus_c = k2 * k3 * x;\n      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2\n    \}\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  inline float chromaCompression(float3 JMh, const float origJ, const float reachCuspM, const float reachMMax, const bool inverse,\n                                 const float limitJmax, const float model_gamma,\n                                 const float sat, const float sat_thr, const float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    const float nJ                   = JMh.x / limitJmax;\n    const float snJ                  = max(0.0f, 1.0f - nJ);\n\n    const float normalisation_factor = reachCuspM; // pow(nJ, model_gamma) * reachMMax; //\n    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor; // 1.0f; //\n\n    const float toe_limit           = limit - 0.001f;  // TODO; magic constantl\n    const float toe_snJ_sat         = snJ * sat;\n    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);\n    const float toe_nJ_compr        = nJ * compr;\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= normalisation_factor;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);\n\n      // Denormalize\n      M *= normalisation_factor;\n    \}\n    else\n    \{\n      M /= normalisation_factor;\n      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);\n      M *= normalisation_factor;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 compressChroma(float3 JMh, const float originalJ, const float2 reachM, const bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, reachM\[REACHCUSPM], reachM\[REACHM], inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse)\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);\n        const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);\n        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);\n        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped      = clamp_to_AP1(src);\n        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(JMh.z);\n        const float  t      = limiting_lerp_fraction(JMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);\n        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);\n        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float2 reachM = reachMFromTable(pos, t);\n        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);\n        output              = compressChroma(src, JMh.x, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        const int    pos  = lookupLimitingCuspHue(src.z);\n        const float  t    = limiting_lerp_fraction(src.z, pos);\n        const float2 reachM = reachMFromTable(pos, t);\n        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);\n        output            = compressChroma(src, JMh.x, reachM, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA], t);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float2 reachM      = reachMFromTable(pos, t);\n        output = float3(reachM\[REACHCUSPM], reachM\[REACHM], wrapped_hue);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.z);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.w);\n    \}\n    else if (DEBUG_reachMTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float2 reachM = reachMTable\[index];\n        output = float3(reachM.x, reachM.y, index);\n    \}\n    \n    else if (DEBUG_Jconstants == diagnosticMode)\n    \{\n        output = float3(_midJ, _limitJmax, _focusDist);\n    \}\n    else if (DEBUG_FocusConstants == diagnosticMode)\n    \{\n        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);\n    \}\n    else if (DEBUG_reachMConditions == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);\n        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);\n\n        output = float3(sM, dM, wrapped_hue); \n    \}\n    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (100 == diagnosticMode)\n    \{\n        const float sm  = src.z * smin(src.x / src.z, src.y / src.z, clamped_smoothness);\n        const float sms = smin_s(src.x, src.y, clamped_smoothness, src.z);\n        output = float3(sm, sms, src.z); \n    \}\n    else if (102 == diagnosticMode)\n    \{\n        float2 found = find_reach_cusp_for_hue(src.z, AP1_to_XYZ, SOURCE_CONDITIONS, src.x, hueFindingTollerance);\n        output = float3(found.x, found.y, src.z);\n    \}\n    else if (103 == diagnosticMode)\n    \{\n        const int index = int(src.z) % 8;\n        output = reach_JMh_corners\[index];\n    \}\n    else if (104 == diagnosticMode)\n    \{\n        const int index = int(src.z) % 8;\n        output = reach_cusp_corners\[index];\n    \}\n    else if (105 == diagnosticMode)\n    \{\n        const int index = int(src.z) % 8;\n        output = display_JMh_corners\[index];\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_Peak Luminance" {{parent.PeakLuminance}}
  "ACES_DRT_Kernel_Limiting primaries" {{parent.LimitPrimaries}}
  "ACES_DRT_Kernel_Limiting Whitepoint" {{parent.LimitingWhitePoint}}
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name DRT
  xpos 228
  ypos 85
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_limiter.blink
  recompileCount 213
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise aded22e6d0409fb40b5846604c55c0a77327dd2df74b7262e197dd98de5443ea 2 \"src\" Read Point \"dst\" Write Point 6 \"Direction\" Bool 1 AA== \"Limiting Primaries\" Int 1 AgAAAA== \"Encoding Primaries\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Clamp to limiting space\" Bool 1 AQ== \"White point scale\" Bool 1 AQ== 6 \"invert\" 1 1 Default \"limitingPrimaries\" 1 1 Default \"encodingPrimaries\" 1 1 Default \"referenceLuminance\" 1 1 Default \"limitClamp\" 1 1 Default \"whitepoint_scale\" 1 1 Default 3 \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: XYZ\n  int limitingPrimaries;\n  int encodingPrimaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  bool limitClamp;\n  bool whitepoint_scale;\n\nlocal:\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(limitingPrimaries, \"Limiting Primaries\", 2);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 2);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(limitClamp, \"Clamp to limiting space\", true);\n    defineParam(whitepoint_scale, \"White point scale\", true);\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    RGB_to_XYZ = generate_RGB_to_XYZ_matrix(limitingPrimaries);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 apply_limiting_clamp(float3 XYZ)\n  \{\n    if (limitClamp)\n    \{\n      XYZ = vector_dot(XYZ_to_RGB, XYZ);\n      XYZ = clamp(XYZ, float3\{0.0f\}, float3\{referenceLuminance\});\n      XYZ = vector_dot(RGB_to_XYZ, XYZ);\n    \}\n    return XYZ;\n  \}\n\n  float3 apply_whitepoint_scale(float3 XYZ)\n  \{\n    if (whitepoint_scale)\n    \{\n      // TODO something\n    \}\n    return XYZ;\n  \}\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 out;\n\n    if (invert)\n    \{\n      out = input; // TODO\n    \}\n    else\n    \{\n      out = apply_limiting_clamp(input);\n      out = apply_whitepoint_scale(out);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Encoding_Kernel_Limiting Primaries" {{parent.LimitPrimaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.OutPrimaries}}
  "ACES_DRT_Encoding_Kernel_Reference Luminance" {{parent.PeakLuminance}}
  "ACES_DRT_Encoding_Kernel_Clamp to limiting space" {{parent.HardClip}}
  "ACES_DRT_Encoding_Kernel_White point scale" {{parent.WhiteScale}}
  rebuild_finalise ""
  name Limiter
  xpos 228
  ypos 121
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 41
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d124d2c8ae9c6120f9eb8be3b6785b14dded8d16d68f1f96ad31364aff64fd5d 2 \"src\" Read Point \"dst\" Write Point 4 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Primaries\" Int 1 AAAAAA== \"Reference Luminance\" Float 1 AADIQg== 4 \"invert\" 1 1 Default \"encoding\" 1 1 Default \"primaries\" 1 1 Default \"referenceLuminance\" 1 1 Default 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_L_p\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: XYZ\n  int primaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n  float3 st2084_L_p;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(primaries, \"Primaries\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 100.0f; // Scale so 100 is 1.0f for Nuke\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    RGB_to_XYZ = generate_RGB_to_XYZ_matrix(primaries);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n  \}\n\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  float3 linear_to_ST2084(float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f, 2.4f, 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f, 2.6f, 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * referenceLuminance;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v = v / referenceLuminance;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f, 1.0f / 2.6f, 1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction true
  ACES_DRT_Encoding_Kernel_Encoding {{parent.OutEncoding}}
  ACES_DRT_Encoding_Kernel_Primaries {{parent.OutPrimaries}}
  rebuild_finalise ""
  name Encode
  selected true
  xpos 228
  ypos 157
 }
set Nc28d200 [stack 0]
 Output {
  name Output1
  xpos 228
  ypos 224
 }
 StickyNote {
  inputs 0
  name params
  label "params\n"
  xpos 370
  ypos 34
 }
push $Nc28d200
 Viewer {
  frame_range 1-100
  viewerProcess None
  monitorOutOutputTransform rec709
  name Viewer1
  xpos 338
  ypos 85
 }
end_group
push $Nc37b150
Group {
 name ACES_DRT_Encoding2
 xpos -165
 ypos -220
 addUserKnob {20 User}
 addUserKnob {4 Direction M {Decode Encode}}
 addUserKnob {4 Primaries M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI XYZ}}
 addUserKnob {4 Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084}}
 addUserKnob {7 referenceLuminance l "Reference Luminance" R 0 200}
 referenceLuminance 100
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 40
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d124d2c8ae9c6120f9eb8be3b6785b14dded8d16d68f1f96ad31364aff64fd5d 2 \"src\" Read Point \"dst\" Write Point 4 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Primaries\" Int 1 AAAAAA== \"Reference Luminance\" Float 1 AADIQg== 4 \"invert\" 1 1 Default \"encoding\" 1 1 Default \"primaries\" 1 1 Default \"referenceLuminance\" 1 1 Default 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_L_p\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: XYZ\n  int primaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n  float3 st2084_L_p;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(primaries, \"Primaries\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 100.0f; // Scale so 100 is 1.0f for Nuke\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    RGB_to_XYZ = generate_RGB_to_XYZ_matrix(primaries);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n  \}\n\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  float3 linear_to_ST2084(float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f, 2.4f, 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f, 2.6f, 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * referenceLuminance;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v = v / referenceLuminance;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f, 1.0f / 2.6f, 1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction {{parent.Direction}}
  ACES_DRT_Encoding_Kernel_Encoding {{parent.Encoding}}
  ACES_DRT_Encoding_Kernel_Primaries {{parent.Primaries}}
  "ACES_DRT_Encoding_Kernel_Reference Luminance" {{parent.referenceLuminance}}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 228
  ypos 78
 }
 Output {
  name Output1
  xpos 228
  ypos 149
 }
end_group
Group {
 name ACESDRT
 xpos -165
 ypos -188
 addUserKnob {20 User}
 addUserKnob {41 ACES_DRT_Kernel_Invert l Invert T BlinkScript1.ACES_DRT_Kernel_Invert}
 addUserKnob {41 "ACES_DRT_Kernel_Peak Luminance" l "Peak Luminance" T "BlinkScript1.ACES_DRT_Kernel_Peak Luminance"}
 addUserKnob {4 limiting_whitepoint l "White Point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." M {"ACES White" D65 ""}}
 limiting_whitepoint D65
 addUserKnob {4 limiting_primaries l Primaries t "the limiting primaries of the gamut to which to compress to" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 limiting_primaries sRGB/Rec.709
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
 addUserKnob {41 "ACES_DRT_Kernel_Disagnostics Mode" l "Disagnostics Mode" T "BlinkScript1.ACES_DRT_Kernel_Disagnostics Mode"}
}
 Input {
  inputs 0
  name Input1
  xpos 130
  ypos -203
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 7
  ypos -187
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 130
  ypos -163
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 216
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Kernel\" iterate pixelWise 348cf901d5414c89a8f2a65bb7a411d8188ff06b585dc6eb5664875dbcf0bd9f 2 \"src\" Read Point \"dst\" Write Point 43 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 1 AABAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 43 \"invert\" 1 1 Default \"AP1Clamp\" 1 1 Default \"_peakLuminance\" 1 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"_inputViewingConditions\" 1 1 Default \"L_A_in\" 1 1 Default \"Y_b_in\" 1 1 Default \"_outputViewingConditions\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default \"_userSurround\" 3 1 Default \"_XYZ_w_scaler\" 1 1 Default \"diagnosticMode\" 1 1 Default \"_smoothCusps\" 1 1 Default \"_smoothOffset\" 2 1 Default \"_cuspMidBlend\" 1 1 Default \"_focusGainBlend\" 1 1 Default \"_focusAdjustGain\" 1 1 Default \"_focusDistance\" 1 1 Default \"_focusDistanceScaling\" 1 1 Default \"_compressionFuncParams\" 1 1 Default \"LMS_rxy\" 2 1 Default \"LMS_gxy\" 2 1 Default \"LMS_bxy\" 2 1 Default \"LMS_wxy\" 2 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"aces_ts_n_r\" 1 1 Default \"aces_ts_g\" 1 1 Default \"aces_ts_c\" 1 1 Default \"aces_ts_c_d\" 1 1 Default \"aces_ts_w_g\" 1 1 Default \"aces_ts_t_1\" 1 1 Default \"aces_ts_r_hit_min\" 1 1 Default \"aces_ts_r_hit_max\" 1 1 Default 55 \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"DL_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DL_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"achromatic_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"A_w\" Float 1 2 AAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"hueTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"limitingGamutCuspTable\" Float 4 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachMTable\" Float 2 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"reach_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"inputWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"smooth_cusp_scale\" Float 2 1 AAAAAAAAAAA= \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_base_slope\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"aces_ts_n\" Float 1 1 AAAAAA== \"aces_ts_u\" Float 1 1 AAAAAA== \"aces_ts_m\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_u_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"aces_ts_inv_upper_limit\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#define DEBUG_limitingGamutCuspTableRaw 60\n#define DEBUG_limitingGamutCuspTableRaw2 61\n#define DEBUG_reachMTableRaw 62\n\n\n#define DEBUG_Jconstants 70\n#define DEBUG_FocusConstants 71\n#define DEBUG_limitingFocusJ 72\n#define DEBUG_reachMConditions 73\n\n#define DEBUG_gamutCompressAlphaFORWARDS 80\n#define DEBUG_gamutCompressAlphaINVERSE 81\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold\n  float _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3x3 identity_matrix;\n\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n\n  float3 DL_weights\[NUMBER_CONDITIONS];\n  float3 DM_weights\[NUMBER_CONDITIONS];\n  float3 DS_weights\[NUMBER_CONDITIONS];\n  \n  float3 DL_weights_inv\[NUMBER_CONDITIONS];\n  float3 DM_weights_inv\[NUMBER_CONDITIONS];\n  float3 DS_weights_inv\[NUMBER_CONDITIONS];\n\n  float3 achromatic_w;\n  float3 a_w;\n  float3 b_w;\n\n  float3 achromatic_weights\[NUMBER_CONDITIONS];\n  float3 a_weights\[NUMBER_CONDITIONS];\n  float3 b_weights\[NUMBER_CONDITIONS];\n\n  float3 achromatic_weights_inv\[NUMBER_CONDITIONS];\n  float3 a_weights_inv\[NUMBER_CONDITIONS];\n  float3 b_weights_inv\[NUMBER_CONDITIONS];\n\n  float3x3 panlrcm;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Reference Luminance in Cd/sqm\n#define referenceLuminance 100.0f\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n\n#define j_scale      100.0f\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  A_w\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n\n//#define USE_DEGREES\n#ifdef USE_DEGREES\n#define hue_limit 360.0f\n#else\n#define hue_limit (2 * PI)\n#endif\n#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range \[0.0, hue_limit) needs to be a multiple of 6 to sample hull corners\n#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases\n#define totalTableSize gamutCuspTableSize + additonal_entries\n#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle\n\n#define gammaAccuracy 5e-6\n#define gammaMinimum 0.4f\n#define gammaMaximum 2.0f\n#define gammaSearchStep 0.2f\n#define badGammaTollerance 1e-2f\n#define hueFindingTollerance 1e-7f\n\n  // Non-uniform in h\n  float  hueTable\[totalTableSize];\n  float4 limitingGamutCuspTable\[totalTableSize];    // \{ J, M, Upper gamma, Lower gamma \}\n  float2 reachMTable\[totalTableSize];               // \{ reachCuspM, reachM \}\n\n// Note reuse of Hue channel 2\n#define UPPER_GAMMA 2\n#define LOWER_GAMMA 3\n\n#define REACHCUSPM 0\n#define REACHM 1\n\n  float3 reach_cusp_corners\[8];\n  float3 reach_JMh_corners\[8];\n\n  float3 display_cusp_corners\[8];\n  float3 display_JMh_corners\[8];\n\n  float3 inputWhite;\n  float3 limitWhite;\n\n  float  clamped_smoothness;\n  float2 smooth_cusp_scale;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma; // TODO: investigate uses of this\n  float _base_slope;\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n\n  float aces_ts_n;         // peak white\n  float aces_ts_u;\n  float aces_ts_m;\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_u_2;\n  float aces_ts_m_2;\n  float aces_ts_inv_upper_limit;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9, 0.59, 0.9));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", 0.75f);\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(1.0f / 3.0f, 1.0f / 3.0f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (PRIMARIES_AP0 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_AP1 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_Rec709 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, FORWARDS);\n    \}\n    else if (PRIMARIES_Rec2020 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3D65 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3DCI == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, FORWARDS);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_w = nl_scale * float3(ra, 1.0f, ba);\n    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;\n\n    panlrcm =  constuct_inverse_matrix(achromatic_w, a_w, b_w);\n\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = (460.0f / panlrcm\[i]\[0]) / 1403.0f;\n      panlrcm\[i]\[0] *= n / nl_scale;\n      panlrcm\[i]\[1] *= n / nl_scale;\n      panlrcm\[i]\[2] *= n / nl_scale;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  float2 get_whitepoint(int which)\n  \{\n    if (which == 0)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which == 1)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n\n    return  float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void init_matrices()\n  \{\n    identity_matrix.setIdentity();\n\n    CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(PRIMARIES_AP1);\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix = get_whitepoint(whiteLimit);\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001f, -0.077f);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    inputWhite = vector_dot(AP1_to_XYZ, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n  \}\n\n  void init_chroma_compression(float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / aces_ts_n;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  void init_gamut_mapper(float log_peak)\n  \{\n    clamped_smoothness  = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?\n    smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(limitWhite * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = linear_RGB_to_JMh(float3(_peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n    _base_slope = _limitJmax * _focusDist;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  void build_cusp_corners_tables(float3 RGB_corners\[8], float3 JMh_corners\[8], const int rgb_conditions, const float3x3& rgb_matrix, const float peak)\n  \{\n    // Calculate hues for corners\n#define cuspCornerCount 6\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      // Generage order R, Y, G, C, B, M\n      temp_cusp_corners\[i] = peak * float3(int(((i+1)%cuspCornerCount) < 3), int(((i+5)%cuspCornerCount) < 3), int(((i+3)%cuspCornerCount) < 3));\n      temp_JMh_corners\[i] = linear_RGB_to_JMh(temp_cusp_corners\[i], rgb_matrix, rgb_conditions);\n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      RGB_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n    RGB_corners\[0]                   = RGB_corners\[cuspCornerCount];\n    RGB_corners\[cuspCornerCount+1]   = RGB_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  float2 find_reach_cusp_for_hue(float hue, const float3x3& rgb_matrix, const int rgb_conditions, const float peak, const float tollerance)\n  \{\n    int upper_corner = 1;\n    for (int i = 1; i != 8; ++i) // TODO: binary search?\n    \{\n       if (reach_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // search by lerping between corners for the hue\n    const float3 cusp_lower = reach_cusp_corners\[lower_corner];\n    const float3 cusp_upper = reach_cusp_corners\[upper_corner];\n\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n    if (reach_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(reach_JMh_corners\[lower_corner].x, reach_JMh_corners\[lower_corner].y);\n    \}\n    float3 sample;\n    float sample_t;\n    if (upper_corner > 6)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = linear_RGB_to_JMh(sample, rgb_matrix, rgb_conditions);\n        if ((JMh.z < reach_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = linear_RGB_to_JMh(sample, rgb_matrix, rgb_conditions);\n        if ((JMh.z > reach_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = linear_RGB_to_JMh(sample, rgb_matrix, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  void initialise_cusp_table(float4 * output_table, const float3x3& matrix, const float luminance, const int conditions)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    const int table_size = gamutCuspTableSize;\n    float4 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f)) * float3(luminance);\n      const float3 cusp    = linear_RGB_to_JMh(RGB, matrix, conditions);\n      tempTableUnsorted\[i] = float4(cusp.x, cusp.y, cusp.z, 0.0f);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex, baseIndex);\n\n    // Copy extra entries to ease the code to handle hues wrapping around\n    output_table\[0]                              = output_table\[baseIndex + gamutCuspTableSize - 1];\n    output_table\[baseIndex + gamutCuspTableSize] = output_table\[baseIndex];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    output_table\[0].z = output_table\[0].z - hue_limit;\n    output_table\[baseIndex + gamutCuspTableSize].z = output_table\[baseIndex + gamutCuspTableSize].z + hue_limit;\n  \}\n\n  void copy_table_rotated(float4 * tableUnsorted, const int tableSize, float4 output_table\[], const int offsetIndex, const int baseOffset)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i+baseOffset] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void extract_hue_table(const float4 * table, float * hueTable)\n  \{\n    for (int i = 0; i < totalTableSize; ++i)\n    \{\n      hueTable\[i] = table\[i].z;\n    \}\n  \}\n\n  void smooth_cusp_table(float4 * table, const float2 scale)\n  \{\n    for (int i = 0; i < totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      table\[i].x      = table\[i].x * scale.x;\n      table\[i].y      = table\[i].y * scale.y;\n    \}\n  \}\n\n  void precompute_reach_table(float2 * reachMTable, float4 * reach_table, const float limitJ, const float3x3& xyz_matrix,\n                              const float3x3& rgb_matrix, const int conditions, const float peak)\n  \{\n    for (int i = 0; i < totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      //float2 JM = find_reach_cusp_for_hue(hue, rgb_matrix, conditions, peak, hueFindingTollerance);\n      reachMTable\[i]\[REACHCUSPM] = compressionCuspFromTable(hue, reach_table).y; // Resample compression cusp for Disply hues save on extra binary search \n      reachMTable\[i]\[REACHM]     = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);\n    \}\n  \}\n\n  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)\n  \{\n    const float search_range = 100.0;\n    float low     = 0.0;\n    float high    = low + search_range;\n    bool  outside = false;\n\n    while (!outside && high < 1400.0)\n    \{\n      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));\n      if (!outside)\n      \{\n        low  = high;\n        high = high + search_range;\n      \}\n    \}\n\n    while ((high - low) > threshold)\n    \{\n      const float sampleM = midpoint(low, high);\n      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));\n      if (outside)\n      \{\n        high = sampleM;\n      \}\n      else\n      \{\n        low = sampleM;\n      \}\n    \}\n    return high;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||\n        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,\n                               const float cuspMidBlend, const float focusAdjustGain, const float2 estimated_hull_gammas, const int conditions)\n  \{\n    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);\n    const float analytical_threshold = compute_analytical_threshold(JMcusp.x);\n    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);\n\n    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float approxLimit =\n        findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);\n    const float J_boundary       = slope * approxLimit + intersectJ;\n\n    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);\n    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);\n    return newLimitRGB;\n  \}\n\n  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float2 estimated_hull_gammas,\n                                     const float limitJmax, const float base_slope, const float midJ,\n                                     const float cuspMidBlend, const float focusAdjustGain,\n                                     const float luminance, const int conditions)\n  \{\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh\[testIndex], limitJmax, base_slope,\n                                                       midJ, cuspMidBlend, focusAdjustGain, estimated_hull_gammas, conditions);\n\n      if (!outside_hull(newLimitRGB, luminance))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(float4 * table, const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain,\n                                   const float luminance, const int conditions)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    const float fixed_gamma = 1.0f / upperHullGamma;\n    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)\n    \{\n      table\[i]\[UPPER_GAMMA] = -1.0f;\n      if (disableUpperHullGamma)\n      \{\n        table\[i]\[UPPER_GAMMA] = fixed_gamma;\n        continue;\n      \}\n\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      const float  hue                 = hueTable\[i];\n      const float4 cusp                = table\[i];\n      const float2 JMcusp              = float2(cusp.x, cusp.y);\n\n      float3 testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = gammaSearchStep;\n      float       low          = gammaMinimum;\n      float       high         = low + search_range;\n      bool        all_inside   = true;\n\n      while (all_inside && high < gammaMaximum)\n      \{\n        const float2 estimated_hull_gammas = float2(high, 1.0f / lowerHullGamma);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > gammaAccuracy)\n      \{\n        testGamma  = midpoint(low, high);\n        const float2 estimated_hull_gammas = float2(testGamma, 1.0f / lowerHullGamma);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (!all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      table\[i]\[UPPER_GAMMA] = testGamma;\n    \}\n    // Wrap the end entries\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  void initialise_lower_hull_gamma(float4 * table, const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain,\n                                   const float luminance, const int conditions)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n    const float fixed_gamma = 1.0f / lowerHullGamma;\n    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        table\[i]\[LOWER_GAMMA] = fixed_gamma;\n        continue;\n      \}\n\n      table\[i]\[LOWER_GAMMA]    = -5.0f;\n      const float4 cusp   = table\[i];\n      const float2 JMcusp = float2(cusp.x, cusp.y);\n      const float  hue    = hueTable\[i];\n\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = gammaSearchStep;\n      float       low          = gammaMinimum;\n      float       high         = low + search_range;\n      bool        all_inside   = true;\n\n      while (all_inside && high < gammaMaximum)\n      \{\n        const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, high);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > gammaAccuracy)\n      \{\n        testGamma  = midpoint(low, high);\n        const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, testGamma);\n        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,\n                                             luminance, conditions);\n        if (!all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      table\[i]\[LOWER_GAMMA] = testGamma;\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  float replace_gamma_entry(float4 * table, int entry, int channel)\n  \{\n    // Very simple patch up, try to find good values either side and lerp a new value\n    int lower = entry - 1;\n    while (lower >= 0)\n    \{\n      if (!bad_gamma_value(table\[lower]\[channel]))\n        break;\n      lower = lower - 1;\n    \}\n    if (lower < 0)\n      return -1.0f; // Give up if we can't find a good entry below\n\n    int upper = entry + 1;\n    while (upper < baseIndex + gamutCuspTableSize)\n    \{\n      if (!bad_gamma_value(table\[upper]\[channel]))\n        break;\n      upper = upper + 1;\n    \}\n    if (upper == totalTableSize)\n      return -2.0f; // Give up nothing above us\n\n    float lower_hue = hueTable\[lower];\n    float upper_hue = hueTable\[upper];\n    float entry_hue = hueTable\[entry];\n    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);\n    return lerp(table\[lower]\[channel], table\[upper]\[channel], lerp_loc);\n  \}\n\n  bool bad_gamma_value(const float value)\n  \{\n    return ((value <= 0.0f) || (value <= gammaMinimum+badGammaTollerance) || (value >= gammaMaximum-badGammaTollerance));\n  \}\n\n  void repair_broken_gamma_values(float4 * table)\n  \{\n    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)\n    \{\n      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)\n      \{\n        if (bad_gamma_value(table\[i]\[channel]))\n        \{\n          table\[i]\[channel] = replace_gamma_entry(table, i, channel);\n        \}\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  inline float3 extract_row(const float3x3 matrix, int row)\n  \{\n    return \{matrix\[row]\[0], matrix\[row]\[1], matrix\[row]\[2]\};\n  \}\n\n  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)\n  \{\n    return weight * extract_row(matrix, row);\n  \}\n\n  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)\n  \{\n    float3x3 matrix;\n    matrix\[0]\[0] = a.x;\n    matrix\[0]\[1] = a.y;\n    matrix\[0]\[2] = a.z;\n    matrix\[1]\[0] = b.x;\n    matrix\[1]\[1] = b.y;\n    matrix\[1]\[2] = b.z;\n    matrix\[2]\[0] = c.x;\n    matrix\[2]\[1] = c.y;\n    matrix\[2]\[2] = c.z;\n    return matrix.invert();\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK, bool discountIlluminant, int stage)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0.0f, 1.0f);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k    = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4   = k * k * k * k;\n    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f); // TODO 0.2 * 5 ... pow(, s)\n    F_L\[stage]       = _F_L / nl_normalise; //TODO white scale?\n\n    // # FWd Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    //float3 RGB = vector_dot(CAT_CAT16, XYZ);\n    //float3 RGB_c = D_RGB\[conditions] * RGB; // combine with CAT16\n\n    // Pre weight CAT16 matrix by D\n    DL_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].x, CAT_CAT16, 0);\n    DM_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].y, CAT_CAT16, 1);\n    DS_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].z, CAT_CAT16, 2);\n\n    // # Inv Step 6\n    //const float3 RGB = RGB_c / D_RGB\[conditions];\n    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n    const float3x3 tempmat = constuct_inverse_matrix(DL_weights\[stage], DM_weights\[stage], DS_weights\[stage]);\n    DL_weights_inv\[stage] = extract_row(tempmat, 0);\n    DM_weights_inv\[stage] = extract_row(tempmat, 1);\n    DS_weights_inv\[stage] = extract_row(tempmat, 2);\n\n    // Prescale values\n    surround\[stage].y = surround\[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n    surround\[stage].z = surround\[stage].z * 43.0f;\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L\[stage] * RGB_wc);\n    A_w\[stage]          = dot(achromatic_w, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    y_to_j_A_w\[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);\n\n    achromatic_weights\[stage] = achromatic_w / A_w\[stage];\n    a_weights\[stage]          = surround\[stage].z * a_w;\n    b_weights\[stage]          = surround\[stage].z * b_w;\n\n    const float3 column_weights = float3(A_w\[stage], 1.0f / surround\[stage].z, 1.0f / surround\[stage].z);\n    achromatic_weights_inv\[stage]   = extract_row(panlrcm, 0) * column_weights;\n    a_weights_inv\[stage]            = extract_row(panlrcm, 1) * column_weights;\n    b_weights_inv\[stage]            = extract_row(panlrcm, 2) * column_weights;\n  \}\n\n  void init()\n  \{\n    init_tonescale_constants(_peakLuminance);\n\n    const float log_peak = log10(aces_ts_n / aces_ts_n_r);\n\n    init_matrices();\n\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS);\n\n    init_chroma_compression(log_peak);\n    init_gamut_mapper(log_peak);\n\n    build_cusp_corners_tables(reach_cusp_corners, reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _peakLuminance);\n    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);\n\n    initialise_cusp_table(limitingGamutCuspTable, RGB_to_XYZ_limit, _peakLuminance, DISPLAY_CONDITIONS);\n    extract_hue_table(limitingGamutCuspTable, hueTable);\n    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);\n    initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _peakLuminance, DISPLAY_CONDITIONS);\n    initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _peakLuminance, DISPLAY_CONDITIONS);\n    repair_broken_gamma_values(limitingGamutCuspTable);\n\n    float4 compressionGamutCuspTable\[totalTableSize];\n    initialise_cusp_table(compressionGamutCuspTable, AP1_to_XYZ, _peakLuminance, SOURCE_CONDITIONS);\n    precompute_reach_table(reachMTable, compressionGamutCuspTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS, _peakLuminance);\n  \}\n\n#ifdef USE_DEGREES\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float to_radians(float hue)\n  \{\n    return hue / 180.0f * PI;\n  \}\n#endif\n\n  inline float wrap_hue(float hue)\n  \{\n    float y = fmod(hue, hue_limit);\n    if (y < 0.0)\n    \{\n      y = y + hue_limit;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB        = clamp(RGB, float3\{0.0f\}, float3(16384.0f)); // limit to nice power of 2 above that needed to max out a 10000 Nit output transform\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_forward(float L)\n  \{\n    const float F_L_L = pow(L, float(nl_gamma));\n    return F_L_L / (nl_offset + F_L_L);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));\n    return F_L_RGB / (nl_offset + F_L_RGB);\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_inverse(float A)\n  \{\n    const float F_L_A = (nl_offset * A) / (1.0 - A);\n    return pow(F_L_A, 1.0f / nl_gamma);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 F_L_RGB = (nl_offset * RGB) / (1.0 - RGB);\n    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);\n    return RGB_c;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);\n    return RGB_p;\n  \}\n\n//  // Return compression gamut cusp M scaled with an eccentricity factor\n//  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n//  \{\n//    if (!apply_eccentricity)\n//    \{\n//        return 1.0f;\n//    \}\n//\n//    // Hellwig2022/Helles2023\n//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n//    const float _2_hr = 2 * hr;\n//    const float _3_hr = 3 * hr;\n//    const float _4_hr = 4 * hr;\n//    // clang-format off\n//    return (\n//        - 0.0582f * cos(_1_hr)\n//        - 0.0258f * cos(_2_hr)\n//        - 0.1347f * cos(_3_hr)\n//        + 0.0289f * cos(_4_hr)\n//        - 0.1475f * sin(_1_hr)\n//        - 0.0308f * sin(_2_hr)\n//        + 0.0385f * sin(_3_hr)\n//        + 0.0096f * sin(_4_hr)\n//        + 1.0f\n//      );\n//    // clang-format on\n//  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float _J_from_Achromatic(float A, int conditions)\n  \{\n    return j_scale * pow(A, surround\[conditions].y);\n  \}\n\n  inline float _Achromatic_from_J(float J, int conditions)\n  \{\n    return pow(J / j_scale, 1.0f / surround\[conditions].y);\n  \}\n\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * _J_from_Achromatic(fabs(A), conditions);\n  \}\n\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * _Achromatic_from_J(fabs(J), conditions);\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    float3 RGB_c;\n    RGB_c.x = dot(DL_weights\[conditions], XYZ);\n    RGB_c.y = dot(DM_weights\[conditions], XYZ);\n    RGB_c.z = dot(DS_weights\[conditions], XYZ);\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);\n\n    const float A = dot(achromatic_weights\[conditions], RGB_a);\n    const float a = dot(a_weights\[conditions], RGB_a);\n    const float b = dot(b_weights\[conditions], RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n#ifdef USE_DEGREES\n    const float h  = wrap_hue(degrees(hr));\n#else\n    const float h  = wrap_hue(hr);\n#endif\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    //const float et = eccentricity_factor(hr, false);\n    //float       M  = surround\[conditions].z * et * sqrt(a * a + b * b);\n    float M = sqrt(a * a + b * b); // Valid as et == 1.0\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n#ifdef USE_DEGREES\n    const float hr = to_radians(JMh.z);\n#else\n    const float hr = JMh.z;\n#endif\n\n    // # *HelmholtzKohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float _A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    //const float et    = eccentricity_factor(hr, false);\n    //const float P_p_1 = surround\[conditions].z; // * et;\n    //const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 Aab = float3(_A, a, b);\n    //const float3 RGB_a = vector_dot(panlrcm, Aab);\n    float3 RGB_a;\n    RGB_a.x = dot(achromatic_weights_inv\[conditions], Aab);\n    RGB_a.y = dot(a_weights_inv\[conditions], Aab);\n    RGB_a.z = dot(b_weights_inv\[conditions], Aab);\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);\n\n    float3 XYZ;\n    XYZ.x = dot(DL_weights_inv\[conditions], RGB_c);\n    XYZ.y = dot(DM_weights_inv\[conditions], RGB_c);\n    XYZ.z = dot(DS_weights_inv\[conditions], RGB_c);\n\n    return XYZ;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / hue_limit * table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b (cubic polynomial)\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline float smin_s(float a, float b, float s, float normalise)\n  \{\n    const float s_scaled     = s * normalise;\n    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;\n    const float h            = max(scaled_delta, 0.0f);\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  inline float midpoint(float low, float high)\n  \{\n    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document\n    return (high + low) * 0.5f;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  int lookupLimitingCuspHue(float wrapped_hue)\n  \{\n    int low_i  = 0;\n    int high_i = baseIndex + gamutCuspTableSize; // Allowed as we have extra entries in the table\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > hueTable\[i])\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float limiting_lerp_fraction(float wrapped_hue, int pos)\n  \{\n    return (wrapped_hue - hueTable\[pos - 1])\n          / (hueTable\[pos] - hueTable\[pos - 1]);\n  \}\n\n  inline float4 limitingCuspFromTable(int pos, float t)\n  \{\n    return lerp(limitingGamutCuspTable\[pos - 1], limitingGamutCuspTable\[pos], t);\n  \}\n\n  float4 compressionCuspFromTable(float wrapped_hue, float4 * compressionGamutCuspTable)\n  \{\n    // Avoid use within main pixel loop\n    float4 lo;\n    float4 hi;\n\n    int low_i  = 0;\n    int high_i = baseIndex + gamutCuspTableSize; // Allowed as we have extra entry in the table\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > compressionGamutCuspTable\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    lo = compressionGamutCuspTable\[high_i - 1];\n    hi = compressionGamutCuspTable\[high_i];\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    return lerp(lo, hi, t);\n  \}\n\n  inline float2 reachMFromTable(int pos, float t)\n  \{\n    return lerp(reachMTable\[pos - 1], reachMTable\[pos], t);\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)\n  \{\n    // Assume J (0.0, limitJmax)\n    \n    if (J <= analytical_threshold)\n      return 1.0f; // makes the analytic inverse possible below cusp\n\n    // Approximate inverse required above threshold TODO: explain why\n    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n  \}\n\n  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,\n                                  const float focusAdjustGain, const float analytical_threshold)\n  \{\n    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)\n  \{\n    float direction_scaler;\n    if (intersectJ <= focusJ)\n    \{\n      direction_scaler = intersectJ;\n    \}\n    else\n    \{\n       direction_scaler = (limitJmax - intersectJ);\n    \}\n\n    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);\n  \}\n\n  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,\n                                                         const float inv_gamma, const float J_max, const float M_max,\n                                                         const float J_intersection_reference)\n  \{\n    // Line defined by     J = slope * x + J_axis_intersect\n    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)\n    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential\n    \n    // We calculate a shifted intersection from the original intersection using the inverse of the exponential\n    // and the provided reference\n    const float normalised_J        = J_axis_intersect / J_intersection_reference;\n    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);\n\n    // Now we find the M intersection of two lines\n    // line from origin to J,M Max       l1(x) = J/M * x\n    // line from J Intersect' with slope l2(x) = slope * x + Intersect'\n\n    return shifted_intersecion / ((J_max / M_max) - slope);\n    //return shifted_intersecion * M_max / (J_max - slope * M_max);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,\n                                      float2 estimated_hull_gammas, const float slope)\n  \{\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);\n\n    // The upper hull is flipped and thus 'zerod' at J_max\n    // Also note we negate the slope\n    const float f_J_intersect_cusp = J_max - J_intersect_cusp;\n    const float f_J_intersect_source = J_max - J_intersect_source;\n    const float f_JM_cusp_J = J_max - JM_cusp.x;\n    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);\n\n    // Smooth minimum between the two calculated values for the M component\n    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n    return M_boundary;\n    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);\n  \}\n\n  inline float reinhard_compress(const float scale, const float factor, bool direction)\n  \{\n    if (INVERSE == direction)\n    \{\n      if (factor >= 1.0f)\n        return scale;\n      else\n        return scale * (-(factor / (factor - 1.0f)));\n    \}\n    return scale * (factor) / (1.0f + factor);\n  \}\n\n  inline float gamut_mapped_location(float location, const float gamutBoundary, const float reachBoundary, bool direction)\n  \{\n    // Assumes _compressionFuncParams in \[0.0, 1.0]\n    const float threshold = max(_compressionFuncParams, gamutBoundary / reachBoundary) * gamutBoundary;\n\n    // Values upto the threshold or when both boundaries are the same remain as is\n    if (location <= threshold || threshold == gamutBoundary)\n      return location;\n\n    // Translate to place threshold at zero\n    const float location_offset = location - threshold;\n    const float boundary_offset = gamutBoundary - threshold;\n    const float reach_offset    = reachBoundary - threshold;\n\n    // Assumes boundary != reach\n    // Generaly speaking boundary should be < reach\n    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);\n    const float factor = location_offset / scale;\n\n    const float relative_location = reinhard_compress(scale, factor, direction);\n\n    return (threshold + relative_location); // shift back to absolute\n  \}\n\n  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,\n                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,\n                    float reachMaxM, float model_gamma)\n  \{\n    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float ganutBoundaryM   = findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,\n                                                                  smoothness, estimated_hull_gammas, slope);\n\n    if (ganutBoundaryM <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)\n    \{\n      //return float2(999, ganutBoundaryM);\n      return float2(JM.x, 0.0f);\n    \}\n      //return float2(JM.x, ganutBoundaryM);\n\n    // Compress the out of gamut color along the projection line\n    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);\n    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);\n    const float mappedJ  = slope * mappedM + intersectJ;\n\n    return float2\{mappedJ, mappedM\};\n  \}\n\n  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));\n  \}\n\n  inline float compute_analytical_threshold(float cuspJ)\n  \{\n    return lerp(cuspJ, _limitJmax, _focusGainBlend);\n  \}\n\n  float3 gamutMapper(float3 JMh, const float4 cusp, const float2 reachM, bool direction)\n  \{\n    // Limit to +ve values // TODO test this is neededS\n    if (JMh.x <= 0.0f)\n    \{\n      JMh.x = 0.0f;\n      JMh.y = 0.0f;\n    \}\n    // Above the expected maximum we explicitly map to 0 M\n    if (JMh.x >= _limitJmax)\n    \{\n      JMh.y = 0.0f;\n    \}\n\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f)\n      return JMh;\n\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n\n    const float2 JMcusp                = float2(cusp.x, cusp.y);\n    const float  reachMaxM             = reachM\[REACHM];\n    const float2 estimated_hull_gammas = float2\{cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA]\};\n    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x); \n    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);\n\n    float  Jx         = JMh.x;\n    float2 JM         = float2\{JMh.x, JMh.y\};\n    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);\n \n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > analytical_threshold)\n      \{\n        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                        clamped_smoothness, reachMaxM, _model_gamma).x;\n        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);\n      \}\n    \}\n    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                    clamped_smoothness, reachMaxM, _model_gamma);\n\n    return \{JM.x, JM.y, JMh.z\};\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, int conditions)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, conditions);\n    return JMh;\n  \}\n\n  float3 JMh_to_linear_RGB(float3 JMh, const float3x3& matrix, int conditions)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, conditions);\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  void init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions\n    aces_ts_n = peakLuminance;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_n / aces_ts_n_r) / log(10000.0f / 100.0f));\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    aces_ts_u                  = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    aces_ts_m                  = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1) * referenceLuminance; // Factor in our reference\n    aces_ts_u_2                = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(const float Y)\n  \{\n    // Assumes Y is >= +0.0\n    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);\n    const float h = max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility\n    return h * _XYZ_w_scaler; // TODO: another normalised number\n  \}\n\n  inline float aces_ts_rev(const float Y)\n  \{\n    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?\n    const float h = Y / _XYZ_w_scaler;\n    const float f = (h + sqrt(h * (4.0f * aces_ts_t_1 + h))) / 2.0f;\n    return  aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float _Y_to_Hellwig_J(float Y, int conditions)\n  \{\n    // Assumes Y is >= +0.0\n    const float A = _post_adaptation_non_linear_response_compression_forward(F_L\[conditions] * Y) / y_to_j_A_w\[conditions];\n    return _J_from_Achromatic(A, conditions);\n  \}\n\n  inline float _Hellwig_J_to_Y(float J, int conditions)\n  \{\n    // Assumes J is >= +0.0\n    const float A = y_to_j_A_w\[conditions] * _Achromatic_from_J(J, conditions);\n    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L\[conditions];\n  \}\n\n//  inline float Y_to_Hellwig_J(float Y, int conditions)\n//  \{\n//    const float absY = fabs(Y);\n//    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?\n//  \}\n//\n//  inline float Hellwig_J_to_Y(float J, int conditions)\n//  \{\n//    const float absJ = fabs(J);\n//    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?\n//  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions)\n  \{\n    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below\n    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);\n    const float  luminanceTS   = aces_ts_fwd(inputY);\n    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);\n    return float3(tonemappedJ, inputJMh.y, inputJMh.z);\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);\n    const float  linear          = aces_ts_rev(luminance);\n    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);\n    return float3(untonemappedJ, JMh.y, JMh.z);\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, bool inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2             = max(k2, 0.001f); // TODO; magic constant\n    k1             = sqrt(k1 * k1 + k2 * k2);\n    const float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n    \{\n      const float minus_b = k3 * x - k1;\n      const float minus_c = k2 * k3 * x;\n      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2\n    \}\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  inline float chromaCompression(float3 JMh, const float origJ, const float reachCuspM, const float reachMMax, const bool inverse,\n                                 const float limitJmax, const float model_gamma,\n                                 const float sat, const float sat_thr, const float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    const float nJ                   = JMh.x / limitJmax;\n    const float snJ                  = max(0.0f, 1.0f - nJ);\n\n    const float normalisation_factor = reachCuspM; // pow(nJ, model_gamma) * reachMMax; //\n    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor; // 1.0f; //\n\n    const float toe_limit           = limit - 0.001f;  // TODO; magic constantl\n    const float toe_snJ_sat         = snJ * sat;\n    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);\n    const float toe_nJ_compr        = nJ * compr;\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= normalisation_factor;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);\n\n      // Denormalize\n      M *= normalisation_factor;\n    \}\n    else\n    \{\n      M /= normalisation_factor;\n      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);\n      M *= normalisation_factor;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 compressChroma(float3 JMh, const float originalJ, const float2 reachM, const bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, reachM\[REACHCUSPM], reachM\[REACHM], inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse)\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);\n        const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);\n        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);\n        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped      = clamp_to_AP1(src);\n        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(JMh.z);\n        const float  t      = limiting_lerp_fraction(JMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);\n        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);\n        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float2 reachM = reachMFromTable(pos, t);\n        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);\n        output              = compressChroma(src, JMh.x, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float2 reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        const int    pos  = lookupLimitingCuspHue(src.z);\n        const float  t    = limiting_lerp_fraction(src.z, pos);\n        const float2 reachM = reachMFromTable(pos, t);\n        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);\n        output            = compressChroma(src, JMh.x, reachM, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA], t);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float2 reachM      = reachMFromTable(pos, t);\n        output = float3(reachM\[REACHCUSPM], reachM\[REACHM], wrapped_hue);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.z);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.w);\n    \}\n    else if (DEBUG_reachMTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float2 reachM = reachMTable\[index];\n        output = float3(reachM.x, reachM.y, index);\n    \}\n    \n    else if (DEBUG_Jconstants == diagnosticMode)\n    \{\n        output = float3(_midJ, _limitJmax, _focusDist);\n    \}\n    else if (DEBUG_FocusConstants == diagnosticMode)\n    \{\n        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);\n    \}\n    else if (DEBUG_reachMConditions == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);\n        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);\n\n        output = float3(sM, dM, wrapped_hue); \n    \}\n    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (100 == diagnosticMode)\n    \{\n        const float sm  = src.z * smin(src.x / src.z, src.y / src.z, clamped_smoothness);\n        const float sms = smin_s(src.x, src.y, clamped_smoothness, src.z);\n        output = float3(sm, sms, src.z); \n    \}\n    else if (102 == diagnosticMode)\n    \{\n        float2 found = find_reach_cusp_for_hue(src.z, AP1_to_XYZ, SOURCE_CONDITIONS, src.x, hueFindingTollerance);\n        output = float3(found.x, found.y, src.z);\n    \}\n    else if (103 == diagnosticMode)\n    \{\n        const int index = int(src.z) % 8;\n        output = reach_JMh_corners\[index];\n    \}\n    else if (104 == diagnosticMode)\n    \{\n        const int index = int(src.z) % 8;\n        output = reach_cusp_corners\[index];\n    \}\n    else if (105 == diagnosticMode)\n    \{\n        const int index = int(src.z) % 8;\n        output = display_JMh_corners\[index];\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_Peak Luminance" 500
  "ACES_DRT_Kernel_Limiting primaries" {{parent.limiting_primaries}}
  "ACES_DRT_Kernel_Limiting Whitepoint" {{parent.limiting_whitepoint}}
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 130
  ypos -110
 }
 Output {
  name Output1
  xpos 130
  ypos -10
 }
end_group
Group {
 name ACESDRT_EncodingLimiter
 xpos -165
 ypos -154
 addUserKnob {20 User}
 addUserKnob {4 limiting_primaries l Primaries t "the limiting primaries of the gamut to which to compress to" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 ""}}
 limiting_primaries sRGB/Rec.709
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Reference Luminance" l "Reference Luminance" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Reference Luminance"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Clamp to limiting space" l "Clamp to limiting space" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Clamp to limiting space"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_White point scale" l "White point scale" T "BlinkScript1.ACES_DRT_Encoding_Kernel_White point scale"}
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos 130
  ypos -203
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 7
  ypos -187
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 130
  ypos -163
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_limiter.blink
  recompileCount 214
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise aded22e6d0409fb40b5846604c55c0a77327dd2df74b7262e197dd98de5443ea 2 \"src\" Read Point \"dst\" Write Point 6 \"Direction\" Bool 1 AA== \"Limiting Primaries\" Int 1 AgAAAA== \"Encoding Primaries\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Clamp to limiting space\" Bool 1 AQ== \"White point scale\" Bool 1 AQ== 6 \"invert\" 1 1 Default \"limitingPrimaries\" 1 1 Default \"encodingPrimaries\" 1 1 Default \"referenceLuminance\" 1 1 Default \"limitClamp\" 1 1 Default \"whitepoint_scale\" 1 1 Default 3 \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: XYZ\n  int limitingPrimaries;\n  int encodingPrimaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  bool limitClamp;\n  bool whitepoint_scale;\n\nlocal:\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(limitingPrimaries, \"Limiting Primaries\", 2);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 2);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(limitClamp, \"Clamp to limiting space\", true);\n    defineParam(whitepoint_scale, \"White point scale\", true);\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    RGB_to_XYZ = generate_RGB_to_XYZ_matrix(limitingPrimaries);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 apply_limiting_clamp(float3 XYZ)\n  \{\n    if (limitClamp)\n    \{\n      XYZ = vector_dot(XYZ_to_RGB, XYZ);\n      XYZ = clamp(XYZ, float3\{0.0f\}, float3\{referenceLuminance\});\n      XYZ = vector_dot(RGB_to_XYZ, XYZ);\n    \}\n    return XYZ;\n  \}\n\n  float3 apply_whitepoint_scale(float3 XYZ)\n  \{\n    if (whitepoint_scale)\n    \{\n      // TODO something\n    \}\n    return XYZ;\n  \}\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 out;\n\n    if (invert)\n    \{\n      out = input; // TODO\n    \}\n    else\n    \{\n      out = apply_limiting_clamp(input);\n      out = apply_whitepoint_scale(out);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Encoding_Kernel_Limiting Primaries" {{parent.limiting_primaries}}
  "ACES_DRT_Encoding_Kernel_Reference Luminance" 500
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 130
  ypos -110
 }
 Output {
  name Output1
  xpos 130
  ypos -10
 }
end_group
Group {
 name ACES_DRT_Encoding1
 xpos -165
 ypos -123
 addUserKnob {20 User}
 addUserKnob {4 Direction M {Decode Encode}}
 Direction Encode
 addUserKnob {4 Primaries M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI XYZ}}
 Primaries Rec.2020-D65
 addUserKnob {4 Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084}}
 Encoding "BT.1886 (Gamma 2.4)"
 addUserKnob {7 referenceLuminance l "Reference Luminance" R 0 200}
 referenceLuminance 100
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 40
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d124d2c8ae9c6120f9eb8be3b6785b14dded8d16d68f1f96ad31364aff64fd5d 2 \"src\" Read Point \"dst\" Write Point 4 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Primaries\" Int 1 AAAAAA== \"Reference Luminance\" Float 1 AADIQg== 4 \"invert\" 1 1 Default \"encoding\" 1 1 Default \"primaries\" 1 1 Default \"referenceLuminance\" 1 1 Default 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_L_p\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: XYZ\n  int primaries;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n  float3 st2084_L_p;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(primaries, \"Primaries\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 100.0f; // Scale so 100 is 1.0f for Nuke\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    RGB_to_XYZ = generate_RGB_to_XYZ_matrix(primaries);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n  \}\n\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  float3 linear_to_ST2084(float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f, 2.4f, 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f, 2.6f, 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * referenceLuminance;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v = v / referenceLuminance;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f, 1.0f / 2.6f, 1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction {{parent.Direction}}
  ACES_DRT_Encoding_Kernel_Encoding {{parent.Encoding}}
  ACES_DRT_Encoding_Kernel_Primaries {{parent.Primaries}}
  "ACES_DRT_Encoding_Kernel_Reference Luminance" {{parent.referenceLuminance}}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 228
  ypos 78
 }
 Output {
  name Output1
  xpos 228
  ypos 149
 }
end_group
Viewer {
 inputs 3
 frame 1
 frame_range 1-100
 input_number 2
 viewerProcess None
 monitorOutOutputTransform rec709
 name Viewer1
 xpos 146
 ypos -121
}
