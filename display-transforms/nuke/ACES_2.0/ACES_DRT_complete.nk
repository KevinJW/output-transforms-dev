#! /opt/foundry/nuke-13.2v8/libnuke-13.2.8.so -nx
version 13.2 v8
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="27" w="1920" h="1027" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="1214"/>
            <splitter orientation="1">
                <split size="40"/>
                <dock id="" hideTitles="1" activePageId="Toolbar.1">
                    <page id="Toolbar.1"/>
                </dock>
                <split size="1170"/>
                <splitter orientation="2">
                    <split size="577"/>
                    <dock id="" activePageId="Viewer.1">
                        <page id="Viewer.1"/>
                        <page id="uk.co.framestore.CompSaverWidget"/>
                    </dock>
                    <split size="407"/>
                    <dock id="" activePageId="DAG.1" focus="true">
                        <page id="DAG.1"/>
                        <page id="Curve Editor.1"/>
                        <page id="DopeSheet.1"/>
                        <page id="uk.co.thefoundry.scripteditor.1"/>
                    </dock>
                </splitter>
            </splitter>
            <split size="702"/>
            <splitter orientation="2">
                <split size="887"/>
                <dock id="" activePageId="Properties.1">
                    <page id="Properties.1"/>
                </dock>
                <split size="97"/>
                <dock id="" activePageId="Progress.1">
                    <page id="Progress.1"/>
                </dock>
            </splitter>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_complete.nk
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Constant {
 inputs 0
 channels {-rgba.red -rgba.green rgba.blue none}
 color 100000
 name Constant1
 xpos 281
 ypos -353
}
Reformat {
 inputs 0
 type "to box"
 box_width 1000
 box_height 20
 box_fixed true
 name Reformat1
 xpos 146
 ypos -323
}
Expression {
 channel0 rgb
 expr0 100*x/(width-1)
 name Expression1
 xpos 146
 ypos -299
}
Read {
 inputs 0
 file_type exr
 file /net/homes/kwheatle/shows/main/colour/images/SonyF35.StillLife.exr
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 origset true
 raw true
 name Read1
 xpos -16
 ypos -353
}
Switch {
 inputs 3
 name Switch1
 xpos 146
 ypos -220
}
set N92925c0 [stack 0]
Group {
 name ACES_DRT_FULL1
 xpos 273
 ypos -176
 addUserKnob {20 User}
 addUserKnob {4 InEncoding l Input M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
 addUserKnob {4 InWhitepoint l "" -STARTLINE M {"Illuminant E" ACES D65 DCI Custom ""}}
 InWhitepoint ACES
 addUserKnob {4 InPrimaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" "" "" "" "" ""}}
 InPrimaries AP0-ACES
 addUserKnob {26 Limit l Limiting}
 addUserKnob {41 limiting_whitepoint l "Limiting Gamut" T params.limiting_whitepoint}
 addUserKnob {41 limiting_primaries l "" -STARTLINE T params.limiting_primaries}
 addUserKnob {20 Custom n 1}
 Custom 0
 addUserKnob {41 custom_red l "Custom red" T params.custom_red}
 addUserKnob {41 custom_green l "Custom Green" T params.custom_green}
 addUserKnob {41 custom_blue l "Custom Blue" T params.custom_blue}
 addUserKnob {41 custom_white l "Custom White" T params.custom_white}
 addUserKnob {20 endGroup n -1}
 addUserKnob {41 peakLuminance l Peak T params.peakLuminance}
 addUserKnob {26 Limiter l Scale/Clipping}
 addUserKnob {6 WhiteScale l "White Scaling" +STARTLINE}
 WhiteScale true
 addUserKnob {6 HardClip l "Hard Clip" +STARTLINE}
 HardClip true
 addUserKnob {26 Encoding}
 addUserKnob {4 OutEncoding l Output -STARTLINE M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
 OutEncoding "BT.1886 (Gamma 2.4)"
 addUserKnob {4 OutWhitepoint l "" -STARTLINE M {"Illuminant E" ACES D65 DCI Custom "" ""}}
 OutWhitepoint D65
 addUserKnob {4 OutPrimaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" ""}}
 OutPrimaries "Rec.709  (sRGB)"
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  color {0.801596 0.176808 -0.198404 0}
  color_panelDropped true
  format "256 256 0 0 256 256 1 square_256"
  name NoInput
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 51
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Encoding {{parent.InEncoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.InPrimaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.InWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Encoding_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Encoding_Kernel_Custom White" {0.3127000034 0.3289999962}
  rebuild_finalise ""
  name Decode
  xpos 228
  ypos 49
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 226
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Kernel\" iterate pixelWise a546cd9cba9682f370361c457308753c0b805750e9fad0cd6e79b12111e27470 2 \"src\" Read Point \"dst\" Write Point 47 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 1 AABAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 47 \"invert\" 1 1 \"AP1Clamp\" 1 1 \"_peakLuminance\" 1 1 \"primariesLimit\" 1 1 \"whiteLimit\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 \"_inputViewingConditions\" 1 1 \"L_A_in\" 1 1 \"Y_b_in\" 1 1 \"_outputViewingConditions\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 \"_userSurround\" 3 1 \"_XYZ_w_scaler\" 1 1 \"diagnosticMode\" 1 1 \"_smoothCusps\" 1 1 \"_smoothOffset\" 2 1 \"_cuspMidBlend\" 1 1 \"_focusGainBlend\" 1 1 \"_focusAdjustGain\" 1 1 \"_focusDistance\" 1 1 \"_focusDistanceScaling\" 1 1 \"_compressionFuncParams\" 1 1 \"LMS_rxy\" 2 1 \"LMS_gxy\" 2 1 \"LMS_bxy\" 2 1 \"LMS_wxy\" 2 1 \"chroma_compress\" 1 1 \"chroma_compress_fact\" 1 1 \"chroma_expand\" 1 1 \"chroma_expand_fact\" 1 1 \"chroma_expand_thr\" 1 1 \"lowerHullGamma\" 1 1 \"upperHullGamma\" 1 1 \"disableUpperHullGamma\" 1 1 \"disableLowerHullGamma\" 1 1 \"aces_ts_n_r\" 1 1 \"aces_ts_g\" 1 1 \"aces_ts_c\" 1 1 \"aces_ts_c_d\" 1 1 \"aces_ts_w_g\" 1 1 \"aces_ts_t_1\" 1 1 \"aces_ts_r_hit_min\" 1 1 \"aces_ts_r_hit_max\" 1 1 47 \"DL_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DL_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"achromatic_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"hueTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"limitingGamutCuspTable\" Float 4 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachMTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"cube_hues\" Float 1 12 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"unique_hues\" Int 1 1 AAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_base_slope\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"chromaCompressScale\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"aces_ts_inv_upper_limit\" Float 1 1 AAAAAA== \"input_upper_clamp\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int whiteLimit;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#define DEBUG_limitingGamutCuspTableRaw 60\n#define DEBUG_limitingGamutCuspTableRaw2 61\n#define DEBUG_reachMTableRaw 62\n\n\n#define DEBUG_Jconstants 70\n#define DEBUG_FocusConstants 71\n#define DEBUG_limitingFocusJ 72\n#define DEBUG_reachMConditions 73\n\n#define DEBUG_gamutCompressAlphaFORWARDS 80\n#define DEBUG_gamutCompressAlphaINVERSE 81\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold\n  float _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3 DL_weights\[NUMBER_CONDITIONS];\n  float3 DM_weights\[NUMBER_CONDITIONS];\n  float3 DS_weights\[NUMBER_CONDITIONS];\n  \n  float3 DL_weights_inv\[NUMBER_CONDITIONS];\n  float3 DM_weights_inv\[NUMBER_CONDITIONS];\n  float3 DS_weights_inv\[NUMBER_CONDITIONS];\n\n  float3 achromatic_w;\n  float3 a_w;\n  float3 b_w;\n\n  float3 achromatic_weights\[NUMBER_CONDITIONS];\n  float3 a_weights\[NUMBER_CONDITIONS];\n  float3 b_weights\[NUMBER_CONDITIONS];\n\n  float3 achromatic_weights_inv\[NUMBER_CONDITIONS];\n  float3 a_weights_inv\[NUMBER_CONDITIONS];\n  float3 b_weights_inv\[NUMBER_CONDITIONS];\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n\n#define j_scale      100.0f\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n\n//#define USE_DEGREES\n#ifdef USE_DEGREES\n#define hue_limit 360.0f\n#else\n#define hue_limit (2 * PI)\n#endif\n#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range \[0.0, hue_limit) needs to be a multiple of 6 to sample hull corners\n#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases\n#define totalTableSize gamutCuspTableSize + additonal_entries\n#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle\n\n#define gammaAccuracy 5e-6\n#define gammaMinimum 0.4f\n#define gammaMaximum 2.0f\n#define gammaSearchStep 0.2f\n#define badGammaTollerance 1e-2f\n#define hueFindingTollerance 1e-7f\n\n  // Non-uniform in h\n  float  hueTable\[totalTableSize];\n  float4 limitingGamutCuspTable\[totalTableSize];    // \{ J, M, Upper gamma, Lower gamma \}\n  float reachMTable\[totalTableSize];                // reachM \n\n// Note reuse of Hue channel 2\n#define UPPER_GAMMA 2\n#define LOWER_GAMMA 3\n\n#define cuspCornerCount 6\n#define totalCornerCount cuspCornerCount + additonal_entries\n\n  float3 reach_cusp_corners\[totalCornerCount];\n  float3 reach_JMh_corners\[totalCornerCount];\n\n  float3 display_cusp_corners\[totalCornerCount];\n  float3 display_JMh_corners\[totalCornerCount];\n\n  float cube_hues\[2*cuspCornerCount];\n  int unique_hues;\n\n  float  clamped_smoothness;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma; // TODO: investigate uses of this\n  float _base_slope;\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n  float chromaCompressScale; // Scaling foactor for 'cusp' normalisation factor\n\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_m_2;\n  float aces_ts_inv_upper_limit;\n  float input_upper_clamp;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9f, 0.59f, 0.9f));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", 0.75f);\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(1.0f / 3.0f, 1.0f / 3.0f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float3x3 newMatrix =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    if (direction == INVERSE)\n    \{\n      return newMatrix.invert();\n    \}\n    return newMatrix;\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  float3x3 generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_w = nl_scale * float3(ra, 1.0f, ba);\n    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;\n\n    float3x3 mat =  constuct_inverse_matrix(achromatic_w, a_w, b_w);\n\n    for (int i = 0; i != 3; ++i)\n    \{\n      float n = (460.0f / mat\[i]\[0]) / 1403.0f;\n      mat\[i]\[0] *= n / nl_scale;\n      mat\[i]\[1] *= n / nl_scale;\n      mat\[i]\[2] *= n / nl_scale;\n    \}\n    return mat;\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8f, 0.525f, 0.8f);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9f, 0.59f, 0.9f);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0f, 0.69f, 1.0f);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  void init_matrices(float3x3& CAT_CAT16)\n  \{\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n    float2 temp_primaries\[3] =\n    \{\n      LMS_rxy, LMS_gxy, LMS_bxy\n    \};\n  \n    float3x3 CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(temp_primaries, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE;  // Future Nuke versions make the inverse an inplace operator\n    CAT_CAT16 = CAT_CAT16.invert(); // So we copy it then invert, this extra assignment could be dropped in the future\n\n    // AP1 matrix\n    get_primaries(2, custom_primaries, temp_primaries);\n    float2 whitepoint = get_whitepoint(1, custom_white);\n    AP1_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_AP1 = AP1_to_XYZ;\n    XYZ_to_AP1 = XYZ_to_AP1.invert();\n\n    get_primaries(primariesLimit, custom_primaries, temp_primaries);\n    whitepoint = get_whitepoint(whiteLimit, custom_white);\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit;\n    XYZ_to_RGB_limit = XYZ_to_RGB_limit.invert();\n  \}\n\n  void init_chroma_compression(const float peakLuminance, const float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / peakLuminance;\n    chromaCompressScale = pow(0.03379f * peakLuminance, 0.30596f) - 0.45135f;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  float2 init_gamut_mapper(const float peakLuminance, const float log_peak, const float3 white)\n  \{\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(white * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = linear_RGB_to_JMh(float3(peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n    _base_slope = _limitJmax * _focusDist;\n\n    clamped_smoothness             = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?\n    const float2 smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n    return smooth_cusp_scale;\n  \}\n\n  inline float3 generate_unit_cube_corners(const int corner)\n  \{\n    // Generation order R, Y, G, C, B, M to ensure hues rotate in correct order\n    return float3(int(((corner+1)%cuspCornerCount) < 3), int(((corner+5)%cuspCornerCount) < 3), int(((corner+3)%cuspCornerCount) < 3));\n  \}\n\n  void build_cusp_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount], const int rgb_conditions, const float3x3& rgb_matrix, const float peakLuminance)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      temp_cusp_corners\[i] = vector_dot(rgb_matrix, peakLuminance * generate_unit_cube_corners(i));\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  void find_reach_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount],\n                                const int rgb_conditions, const float3x3& rgb_matrix, const float limitJ, const float maximum_source)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      const float3 xyz_vector = vector_dot(rgb_matrix, generate_unit_cube_corners(i));\n      float3 JMh = float3(0.0f);\n\n      float lower = 0.0f;\n      float upper = maximum_source;\n      while ((upper - lower) > 1e-3)\n      \{\n        float test = midpoint(lower, upper);\n        const float3 test_corner = test * xyz_vector;\n        JMh = XYZ_to_JMh(test_corner, rgb_conditions);\n        if (JMh.x < limitJ)\n        \{\n          lower = test;\n        \}\n        else\n        \{\n          upper = test;\n        \}\n        if (JMh.x == limitJ)\n          break;\n      \}\n      temp_cusp_corners\[i] = upper * xyz_vector;\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n \n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  int extract_sorted_cube_hues(float sorted_hues\[12], const float3 reach_JMh\[totalCornerCount], const float3 display_JMh\[totalCornerCount])\n  \{\n    // Basic merge of 2 sorted arrays, extracting the unique hues.\n    // Return the count of the unique hues\n    int idx = 0;\n    int reach_idx = 1;\n    int display_idx = 1;\n    while ((reach_idx < (cuspCornerCount + 1)) || (display_idx < (cuspCornerCount + 1)))\n    \{\n      const float reach_hue = reach_JMh\[reach_idx].z;\n      const float display_hue = display_JMh\[display_idx].z;\n      if (reach_hue == display_hue)\n      \{\n        sorted_hues\[idx] = reach_hue;\n        ++reach_idx;\n        ++display_idx; // When equal consume both\n      \}\n      else\n      \{\n        if (reach_hue < display_hue)\n        \{\n          sorted_hues\[idx] = reach_hue;\n          ++reach_idx;\n        \}\n        else\n        \{\n          sorted_hues\[idx] = display_hue;\n          ++display_idx;\n        \}\n      \}\n      ++idx;\n    \}\n    return idx;\n  \}\n\n  void build_hue_sample_interval(const int samples, const float lower, const float upper, float hueTable\[totalTableSize], const int base)\n  \{\n    const float delta = (upper - lower) / float(samples);\n    for (int i = 0; i != samples; ++i)\n    \{\n      hueTable\[base + i] = lower + float(i) * delta;\n    \}\n  \}\n\n  void build_hue_table(float hueTable\[totalTableSize], const float cube_hues\[2*cuspCornerCount], const int unique_hues)\n  \{\n    const float ideal_spacing = gamutCuspTableSize / hue_limit;\n    int samples_count\[2*cuspCornerCount+2];\n    int last_idx = -1;\n    int min_index = cube_hues\[0] == 0.0f ? 0 : 1; // Ensure we can always sample at 0.0 hue\n    for (int hue_idx = 0; hue_idx != unique_hues; ++hue_idx)\n    \{\n      // BUG: \"gamutCuspTableSize - 1\" will fail if we have multple hues mapping near the top of the table\n      int nominal_idx = clamp(int(round(cube_hues\[hue_idx] * ideal_spacing)), min_index, gamutCuspTableSize - 1);\n      if (last_idx == nominal_idx)\n      \{\n        // Last two hues should sample at same index, need to adjust them\n        // Adjust previous sample down if we can\n        if (hue_idx > 1 && samples_count\[hue_idx - 2] != (samples_count\[hue_idx - 1] - 1))\n        \{\n          samples_count\[hue_idx - 1] = samples_count\[hue_idx - 1] - 1;\n        \}\n        else\n        \{\n          nominal_idx = nominal_idx + 1;\n        \}\n      \}\n      samples_count\[hue_idx] = min(nominal_idx, gamutCuspTableSize - 1);\n      last_idx = min_index = nominal_idx;\n    \}\n\n    int total_samples = 0;\n    // Special cases for ends\n    int i = 0;\n    build_hue_sample_interval(samples_count\[i], 0.0f, cube_hues\[i], hueTable, total_samples+1);\n    total_samples += samples_count\[i];\n    for (++i; i != unique_hues; ++i)\n    \{\n      const int samples = samples_count\[i]-samples_count\[i-1];\n      build_hue_sample_interval(samples, cube_hues\[i-1], cube_hues\[i], hueTable, total_samples+1);\n      total_samples += samples;\n    \}\n    // BUG: could break if we are unlucky with samples all being used up by this point\n    build_hue_sample_interval(gamutCuspTableSize - total_samples, cube_hues\[i-1], hue_limit, hueTable, total_samples+1);\n\n    hueTable\[0] = hueTable\[totalTableSize - 2] - hue_limit;\n    hueTable\[totalTableSize - 1] = hueTable\[1] + hue_limit;\n  \}\n\n  float2 find_reach_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (reach_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (reach_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(reach_JMh_corners\[lower_corner].x, reach_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = reach_cusp_corners\[lower_corner];\n    const float3 cusp_upper = reach_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < reach_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > reach_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  float2 find_display_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (display_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (display_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(display_JMh_corners\[lower_corner].x, display_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = display_cusp_corners\[lower_corner];\n    const float3 cusp_upper = display_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < display_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > display_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  void initialise_cusp_table(float4 output_table\[totalTableSize], const float luminance, const int conditions)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    for (int i = 1; i != gamutCuspTableSize + 1; ++i)\n    \{\n      const float hue = hueTable\[i];\n      const float2 JM = find_display_cusp_for_hue(hue, conditions, hueFindingTollerance);\n      output_table\[i] = float4(JM.x, JM.y, hue, 0.0f);\n    \}\n\n    // Copy extra entries to ease the code to handle hues wrapping around\n    output_table\[0]                              = output_table\[baseIndex + gamutCuspTableSize - 1];\n    output_table\[baseIndex + gamutCuspTableSize] = output_table\[baseIndex];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    output_table\[0].z = output_table\[0].z - hue_limit;\n    output_table\[baseIndex + gamutCuspTableSize].z = output_table\[baseIndex + gamutCuspTableSize].z + hue_limit;\n  \}\n\n  void smooth_cusp_table(float4 table\[totalTableSize], const float2 scale)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      //table\[i].x      = table\[i].x * scale.x; // Not needed as the scale is unity\n      table\[i].y      = table\[i].y * scale.y;\n    \}\n  \}\n\n  void precompute_reach_table(float reachMTable\[totalTableSize], const float limitJ, const float3x3& xyz_matrix,\n                              const float3x3& rgb_matrix, const int conditions)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      reachMTable\[i] = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);\n    \}\n  \}\n\n  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)\n  \{\n    const float search_range = 100.0;\n    float low     = 0.0;\n    float high    = low + search_range;\n    bool  outside = false;\n\n    while (!outside && high < 1400.0)\n    \{\n      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));\n      if (!outside)\n      \{\n        low  = high;\n        high = high + search_range;\n      \}\n    \}\n\n    while ((high - low) > threshold)\n    \{\n      const float sampleM = midpoint(low, high);\n      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));\n      if (outside)\n      \{\n        high = sampleM;\n      \}\n      else\n      \{\n        low = sampleM;\n      \}\n    \}\n    return high;\n  \}\n\n  void fill_initial_hull_gammas(float4 table\[totalTableSize], float upperHullGamma, float lowerHullGamma)\n  \{\n    upperHullGamma = 1.0f / upperHullGamma;\n    lowerHullGamma = 1.0f / lowerHullGamma;\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      table\[i]\[UPPER_GAMMA] = upperHullGamma;\n      table\[i]\[LOWER_GAMMA] = lowerHullGamma;\n    \}\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||\n        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal);\n  \}\n\n  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,\n                               const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                               const float2 estimated_hull_gammas, const int conditions)\n  \{\n    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);\n    const float analytical_threshold = compute_analytical_threshold(JMcusp.x, limitJmax, focusGainBlend);\n    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);\n\n    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float approxLimit =\n        findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);\n    const float J_boundary       = slope * approxLimit + intersectJ;\n\n    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);\n    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);\n    return newLimitRGB;\n  \}\n\n  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float2 estimated_hull_gammas,\n                                     const float limitJmax, const float base_slope, const float midJ,\n                                     const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                                     const float luminance, const int conditions)\n  \{\n    for (int testIndex = 0; testIndex != test_count; ++testIndex)\n    \{\n      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh\[testIndex], limitJmax, base_slope,\n                                                       midJ, cuspMidBlend, focusAdjustGain, focusGainBlend, estimated_hull_gammas, conditions);\n\n      if (!outside_hull(newLimitRGB, luminance))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.5f, 0.8f, 0.99f\};\n    if (!disableUpperHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n        const float  hue                 = hueTable\[i];\n        const float4 cusp                = table\[i];\n        const float2 JMcusp              = float2(cusp.x, cusp.y);\n\n        float3 testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          // create test values between the cusp and the Jmax\n          testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(high, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(testGamma, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[UPPER_GAMMA] = testGamma;\n      \}\n    \}\n    // Wrap the end entries\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f);\n  \}\n\n  void initialise_lower_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.4f, 0.6f, 0.75f\};\n    const float fixed_gamma = 1.0f / lowerHullGamma;\n    if (!disableLowerHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        const float4 cusp   = table\[i];\n        const float2 JMcusp = float2(cusp.x, cusp.y);\n        const float  hue    = hueTable\[i];\n\n        float3       testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], high);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], testGamma);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[LOWER_GAMMA] = testGamma;\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  float replace_gamma_entry(float4 table\[totalTableSize], int entry, int channel)\n  \{\n    // Very simple patch up, try to find good values either side and lerp a new value\n    int lower = entry - 1;\n    while (lower >= 0)\n    \{\n      if (!bad_gamma_value(table\[lower]\[channel]))\n        break;\n      lower = lower - 1;\n    \}\n    if (lower < 0)\n      return -1.0f; // Give up if we can't find a good entry below\n\n    int upper = entry + 1;\n    while (upper < baseIndex + gamutCuspTableSize)\n    \{\n      if (!bad_gamma_value(table\[upper]\[channel]))\n        break;\n      upper = upper + 1;\n    \}\n    if (upper == totalTableSize)\n      return -2.0f; // Give up nothing above us\n\n    float lower_hue = hueTable\[lower];\n    float upper_hue = hueTable\[upper];\n    float entry_hue = hueTable\[entry];\n    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);\n    return lerp(table\[lower]\[channel], table\[upper]\[channel], lerp_loc);\n  \}\n\n  bool bad_gamma_value(const float value)\n  \{\n    return ((value <= 0.0f) || (value <= gammaMinimum+badGammaTollerance) || (value >= gammaMaximum-badGammaTollerance));\n  \}\n\n  void repair_broken_gamma_values(float4 table\[totalTableSize])\n  \{\n    for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n    \{\n      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)\n      \{\n        if (bad_gamma_value(table\[i]\[channel]))\n        \{\n          table\[i]\[channel] = replace_gamma_entry(table, i, channel);\n        \}\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  inline float3 extract_row(const float3x3 matrix, int row)\n  \{\n    return \{matrix\[row]\[0], matrix\[row]\[1], matrix\[row]\[2]\};\n  \}\n\n  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)\n  \{\n    return weight * extract_row(matrix, row);\n  \}\n\n  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)\n  \{\n    float3x3 matrix =\n    \{\n      a.x, a.y, a.z,\n      b.x, b.y, b.z,\n      c.x, c.y, c.z\n    \};\n    return matrix.invert();\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK,\n                          bool discountIlluminant, int stage, float3x3 CAT_CAT16, float3x3 panlrcm)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0.0f, 1.0f);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k    = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4   = k * k * k * k;\n    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);\n    F_L\[stage]       = _F_L / nl_normalise; //TODO white scale?\n\n    // # FWd Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    //float3 RGB = vector_dot(CAT_CAT16, XYZ);\n    //float3 RGB_c = D_RGB\[conditions] * RGB; // combine with CAT16\n\n    // Pre weight CAT16 matrix by D\n    DL_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].x, CAT_CAT16, 0);\n    DM_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].y, CAT_CAT16, 1);\n    DS_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].z, CAT_CAT16, 2);\n\n    // # Inv Step 6\n    //const float3 RGB = RGB_c / D_RGB\[conditions];\n    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n    const float3x3 tempmat = constuct_inverse_matrix(DL_weights\[stage], DM_weights\[stage], DS_weights\[stage]);\n    DL_weights_inv\[stage] = extract_row(tempmat, 0);\n    DM_weights_inv\[stage] = extract_row(tempmat, 1);\n    DS_weights_inv\[stage] = extract_row(tempmat, 2);\n\n    // Prescale values\n    surround\[stage].y = surround\[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n    surround\[stage].z = surround\[stage].z * 43.0f;\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L\[stage] * RGB_wc);\n    const float A_w     = dot(achromatic_w, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    y_to_j_A_w\[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);\n\n    F_L\[stage] *= _XYZ_w_scaler; // Allows tonescale multiplier to be removed\n\n    achromatic_weights\[stage] = achromatic_w / A_w;\n    a_weights\[stage]          = surround\[stage].z * a_w;\n    b_weights\[stage]          = surround\[stage].z * b_w;\n\n    const float3 column_weights = float3(A_w, 1.0f / surround\[stage].z, 1.0f / surround\[stage].z);\n    achromatic_weights_inv\[stage]   = extract_row(panlrcm, 0) * column_weights;\n    a_weights_inv\[stage]            = extract_row(panlrcm, 1) * column_weights;\n    b_weights_inv\[stage]            = extract_row(panlrcm, 2) * column_weights;\n  \}\n\n  void init()\n  \{\n    const float log_peak = init_tonescale_constants(_peakLuminance);\n\n    float3x3 CAT_CAT16;\n\n    init_matrices(CAT_CAT16);\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    const float3 inputWhite = vector_dot(AP1_to_XYZ, white);\n    const float3 limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n    const float3x3 panlrcm = generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS, CAT_CAT16, panlrcm);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS, CAT_CAT16, panlrcm);\n\n    init_chroma_compression(_peakLuminance, log_peak);\n    const float2 smooth_cusp_scale = init_gamut_mapper(_peakLuminance, log_peak, limitWhite);\n\n    // Fist find the unique hues for the cusp corners, then fill in the table uniformly between those hues\n    find_reach_corners_tables(reach_cusp_corners, reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _limitJmax, input_upper_clamp);\n    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);\n    unique_hues = extract_sorted_cube_hues(cube_hues, reach_JMh_corners, display_JMh_corners);\n    build_hue_table(hueTable, cube_hues, unique_hues);\n\n    initialise_cusp_table(limitingGamutCuspTable, _peakLuminance, DISPLAY_CONDITIONS);\n    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);\n    fill_initial_hull_gammas(limitingGamutCuspTable, upperHullGamma, lowerHullGamma);\n    // Iterate gamma finding based on previous values\n    for (int i = 0; i != 3; ++i)\n    \{\n      initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n      initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n    \}\n    repair_broken_gamma_values(limitingGamutCuspTable);\n\n    precompute_reach_table(reachMTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS);\n  \}\n\n#ifdef USE_DEGREES\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float to_radians(float hue)\n  \{\n    return hue / 180.0f * PI;\n  \}\n#endif\n\n  inline float wrap_hue(float hue)\n  \{\n    float y = fmod(hue, hue_limit);\n    if (y < 0.0)\n    \{\n      y = y + hue_limit;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB        = clamp(RGB, float3\{0.0f\}, float3(input_upper_clamp));\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_forward(float L)\n  \{\n    const float F_L_L = pow(L, float(nl_gamma));\n    return F_L_L / (nl_offset + F_L_L);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));\n    return F_L_RGB / (nl_offset + F_L_RGB);\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_inverse(float A)\n  \{\n    const float F_L_A = (nl_offset * A) / (1.0f - A);\n    return pow(F_L_A, 1.0f / nl_gamma);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 F_L_RGB = (nl_offset * RGB) / (1.0f - RGB);\n    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);\n    return RGB_c;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);\n    return RGB_p;\n  \}\n\n//  // Return compression gamut cusp M scaled with an eccentricity factor\n//  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n//  \{\n//    if (!apply_eccentricity)\n//    \{\n//        return 1.0f;\n//    \}\n//\n//    // Hellwig2022/Helles2023\n//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n//    const float _2_hr = 2 * hr;\n//    const float _3_hr = 3 * hr;\n//    const float _4_hr = 4 * hr;\n//    // clang-format off\n//    return (\n//        - 0.0582f * cos(_1_hr)\n//        - 0.0258f * cos(_2_hr)\n//        - 0.1347f * cos(_3_hr)\n//        + 0.0289f * cos(_4_hr)\n//        - 0.1475f * sin(_1_hr)\n//        - 0.0308f * sin(_2_hr)\n//        + 0.0385f * sin(_3_hr)\n//        + 0.0096f * sin(_4_hr)\n//        + 1.0f\n//      );\n//    // clang-format on\n//  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float _J_from_Achromatic(float A, int conditions)\n  \{\n    return j_scale * pow(A, surround\[conditions].y);\n  \}\n\n  inline float _Achromatic_from_J(float J, int conditions)\n  \{\n    return pow(J / j_scale, 1.0f / surround\[conditions].y);\n  \}\n\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * _J_from_Achromatic(fabs(A), conditions);\n  \}\n\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * _Achromatic_from_J(fabs(J), conditions);\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    float3 RGB_c;\n    RGB_c.x = dot(DL_weights\[conditions], XYZ);\n    RGB_c.y = dot(DM_weights\[conditions], XYZ);\n    RGB_c.z = dot(DS_weights\[conditions], XYZ);\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);\n\n    const float A = dot(achromatic_weights\[conditions], RGB_a);\n    const float a = dot(a_weights\[conditions], RGB_a);\n    const float b = dot(b_weights\[conditions], RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n#ifdef USE_DEGREES\n    const float h  = wrap_hue(degrees(hr));\n#else\n    const float h  = wrap_hue(hr);\n#endif\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    //const float et = eccentricity_factor(hr, false);\n    //float       M  = surround\[conditions].z * et * sqrt(a * a + b * b);\n    float M = sqrt(a * a + b * b); // Valid as et == 1.0\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n#ifdef USE_DEGREES\n    const float hr = to_radians(JMh.z);\n#else\n    const float hr = JMh.z;\n#endif\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float _A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    //const float et    = eccentricity_factor(hr, false);\n    //const float P_p_1 = surround\[conditions].z; // * et;\n    //const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 Aab = float3(_A, a, b);\n    //const float3 RGB_a = vector_dot(panlrcm, Aab);\n    float3 RGB_a;\n    RGB_a.x = dot(achromatic_weights_inv\[conditions], Aab);\n    RGB_a.y = dot(a_weights_inv\[conditions], Aab);\n    RGB_a.z = dot(b_weights_inv\[conditions], Aab);\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);\n\n    float3 XYZ;\n    XYZ.x = dot(DL_weights_inv\[conditions], RGB_c);\n    XYZ.y = dot(DM_weights_inv\[conditions], RGB_c);\n    XYZ.z = dot(DS_weights_inv\[conditions], RGB_c);\n\n    return XYZ;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / hue_limit * table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b (cubic polynomial)\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline float smin_s(float a, float b, float s, float normalise)\n  \{\n    const float s_scaled     = s * normalise;\n    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;\n    const float h            = max(scaled_delta, 0.0f);\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  inline float midpoint(float low, float high)\n  \{\n    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document\n    return (high + low) * 0.5f;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  int lookupLimitingCuspHue(float wrapped_hue)\n  \{\n    // samples are almost uniform should be able to find the correct entry +/- 6 entries from middle\n    // on average it is actually in a narrow range than this, left as an exersize for the reader to\n    // improve this, typically lies in upper half\n    // either way log2(search_range*2) is way smaller than log2(gamutCuspTableSize)\n    // BUG: needs checking if this range is too small should all the hues cluster together due to a\n    // pathelogical triangle formed by two primaries from one gamut closely bracketing one from the other\n#define search_range 2\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n    int low_i  = max(0, i - search_range);\n    int high_i = min(baseIndex + gamutCuspTableSize, i + search_range); // Allowed as we have extra entries in the table\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > hueTable\[i])\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float limiting_lerp_fraction(float wrapped_hue, int pos)\n  \{\n    return (wrapped_hue - hueTable\[pos - 1])\n          / (hueTable\[pos] - hueTable\[pos - 1]);\n  \}\n\n  inline float4 limitingCuspFromTable(int pos, float t)\n  \{\n    return lerp(limitingGamutCuspTable\[pos - 1], limitingGamutCuspTable\[pos], t);\n  \}\n\n  inline float reachMFromTable(int pos, float t)\n  \{\n    return lerp(reachMTable\[pos - 1], reachMTable\[pos], t);\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)\n  \{\n    // Assume J (0.0, limitJmax)\n    \n    if (J <= analytical_threshold)\n      return 1.0f; // makes the analytic inverse possible below cusp\n\n    // Approximate inverse required above threshold TODO: explain why\n    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n  \}\n\n  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,\n                                  const float focusAdjustGain, const float analytical_threshold)\n  \{\n    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)\n  \{\n    float direction_scaler;\n    if (intersectJ <= focusJ)\n    \{\n      direction_scaler = intersectJ;\n    \}\n    else\n    \{\n       direction_scaler = (limitJmax - intersectJ);\n    \}\n\n    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);\n  \}\n\n  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,\n                                                         const float inv_gamma, const float J_max, const float M_max,\n                                                         const float J_intersection_reference)\n  \{\n    // Line defined by     J = slope * x + J_axis_intersect\n    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)\n    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential\n    \n    // We calculate a shifted intersection from the original intersection using the inverse of the exponential\n    // and the provided reference\n    const float normalised_J        = J_axis_intersect / J_intersection_reference;\n    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);\n\n    // Now we find the M intersection of two lines\n    // line from origin to J,M Max       l1(x) = J/M * x\n    // line from J Intersect' with slope l2(x) = slope * x + Intersect'\n\n    return shifted_intersecion / ((J_max / M_max) - slope);\n    //return shifted_intersecion * M_max / (J_max - slope * M_max);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,\n                                       float2 estimated_hull_gammas, const float slope)\n  \{\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);\n\n    // The upper hull is flipped and thus 'zerod' at J_max\n    // Also note we negate the slope\n    const float f_J_intersect_cusp = J_max - J_intersect_cusp;\n    const float f_J_intersect_source = J_max - J_intersect_source;\n    const float f_JM_cusp_J = J_max - JM_cusp.x;\n    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);\n\n    // Smooth minimum between the two calculated values for the M component\n    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n    return M_boundary;\n    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);\n  \}\n\n  inline float reinhard_compress(const float scale, const float factor, const bool direction)\n  \{\n    if (INVERSE == direction)\n    \{\n      if (factor >= 1.0f)\n        return scale;\n      else\n        return scale * (-(factor / (factor - 1.0f)));\n    \}\n    return scale * (factor) / (1.0f + factor);\n  \}\n\n  inline float gamut_mapped_location(const float location, const float gamutBoundary, const float reachBoundary, const bool direction)\n  \{\n    // Assumes _compressionFuncParams in (0.0, 1.0)\n    const float threshold = clamp(gamutBoundary / reachBoundary, _compressionFuncParams, 0.99999f) * gamutBoundary;\n\n    // Values upto the threshold or when both boundaries are the same remain as is\n    if (location <= threshold || gamutBoundary == reachBoundary)\n      return location;\n\n    // Translate to place threshold at zero\n    const float location_offset = location - threshold;\n    const float boundary_offset = gamutBoundary - threshold;\n    const float reach_offset    = reachBoundary - threshold;\n\n    // Assumes boundary != reach\n    // Generaly speaking boundary should be < reach\n    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);\n    const float factor = location_offset / scale;\n\n    const float relative_location = reinhard_compress(scale, factor, direction);\n\n    return (threshold + relative_location); // shift back to absolute\n  \}\n\n  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,\n                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,\n                    float reachMaxM, float model_gamma)\n  \{\n    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float ganutBoundaryM   = findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,\n                                                                  smoothness, estimated_hull_gammas, slope);\n\n    if (ganutBoundaryM <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)\n    \{\n      return float2(JM.x, 0.0f);\n    \}\n\n    // Compress the out of gamut color along the projection line\n    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);\n    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);\n    const float mappedJ  = slope * mappedM + intersectJ;\n\n    return float2\{mappedJ, mappedM\};\n  \}\n\n  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));\n  \}\n\n  inline float compute_analytical_threshold(const float cuspJ, const float limitJmax, const float focusGainBlend)\n  \{\n    return lerp(cuspJ, limitJmax, focusGainBlend);\n  \}\n\n  float3 gamutMapper(float3 JMh, const float4 cusp, const float reachM, bool direction)\n  \{\n    // Limit to +ve values // TODO test this is neededS\n    if (JMh.x <= 0.0f)\n    \{\n      JMh.x = 0.0f;\n      JMh.y = 0.0f;\n    \}\n    // Above the expected maximum we explicitly map to 0 M\n    if (JMh.x >= _limitJmax)\n    \{\n      JMh.y = 0.0f;\n    \}\n\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f)\n      return JMh;\n\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n    const float2 JMcusp                = float2(cusp.x, cusp.y);\n    const float2 estimated_hull_gammas = float2\{cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA]\};\n    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x, _limitJmax, _focusGainBlend); \n    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);\n\n    float  Jx         = JMh.x;\n    float2 JM         = float2\{JMh.x, JMh.y\};\n    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);\n \n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > analytical_threshold)\n      \{\n        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                        clamped_smoothness, reachM, _model_gamma).x;\n        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);\n      \}\n    \}\n    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                    clamped_smoothness, reachM, _model_gamma);\n\n    return \{JM.x, JM.y, JMh.z\};\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, conditions);\n    return JMh;\n  \}\n\n  float3 JMh_to_linear_RGB(const float3 JMh, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, conditions);\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  float init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions\n\n    const float aces_ts_n      = peakLuminance;\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_m_0) / log(10000.0f / 100.0f));\n    input_upper_clamp = aces_ts_r_hit * 8.0f * _XYZ_w_scaler;  // limit to nice power of 2 (3 stops) above that needed to max out // TODO magic 8 ball factor needs assessing\n\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    const float aces_ts_u      = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    const float aces_ts_m      = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1);\n    const float aces_ts_u_2    = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?\n    return log10(aces_ts_m_0);\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(const float Y)\n  \{\n    // Assumes Y is >= +0.0\n    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);\n    return max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility\n  \}\n\n  inline float aces_ts_rev(const float Y)\n  \{\n    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?\n    const float f = (Y + sqrt(Y * (4.0f * aces_ts_t_1 + Y))) / 2.0f;\n    return aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float _Y_to_Hellwig_J(float Y, int conditions)\n  \{\n    // Assumes Y is >= +0.0\n    const float A = _post_adaptation_non_linear_response_compression_forward(F_L\[conditions] * Y) / y_to_j_A_w\[conditions];\n    return _J_from_Achromatic(A, conditions);\n  \}\n\n  inline float _Hellwig_J_to_Y(float J, int conditions)\n  \{\n    // Assumes J is >= +0.0\n    const float A = y_to_j_A_w\[conditions] * _Achromatic_from_J(J, conditions);\n    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L\[conditions];\n  \}\n\n//  inline float Y_to_Hellwig_J(float Y, int conditions)\n//  \{\n//    const float absY = fabs(Y);\n//    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?\n//  \}\n//\n//  inline float Hellwig_J_to_Y(float J, int conditions)\n//  \{\n//    const float absJ = fabs(J);\n//    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?\n//  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions)\n  \{\n    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below\n    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);\n    const float  luminanceTS   = aces_ts_fwd(inputY);\n    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);\n    return float3(tonemappedJ, inputJMh.y, inputJMh.z);\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);\n    const float  linear          = aces_ts_rev(luminance);\n    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);\n    return float3(untonemappedJ, JMh.y, JMh.z);\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, bool inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2             = max(k2, 0.001f); // TODO; magic constant\n    k1             = sqrt(k1 * k1 + k2 * k2);\n    const float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n    \{\n      const float minus_b = k3 * x - k1;\n      const float minus_c = k2 * k3 * x;\n      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2\n    \}\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompressionNorm(float h)\n  \{\n#ifdef USE_DEGREES\n    const float hr = to_radians(h);\n#else\n    const float hr = h;\n#endif\n    float a = cos(hr);\n    float b = sin(hr);\n    float cos_hr2 = a * a - b * b;\n    float sin_hr2 = 2.0f * a * b;\n    float cos_hr3 = 4.0f * a * a * a - 3.0f * a;\n    float sin_hr3 = 3.0f * b - 4.0f * b * b * b;\n\n    float M = 11.34072f * a +\n              16.46899f * cos_hr2 +\n               7.88380f * cos_hr3 +\n              14.66441f * b +\n              -6.37224f * sin_hr2 +\n               9.19364f * sin_hr3 +\n              77.12896f;\n\n    return M * chromaCompressScale;\n  \}\n\n  inline float chromaCompression(float3 JMh, const float origJ, const float reachMMax, const bool inverse,\n                                 const float limitJmax, const float model_gamma,\n                                 const float sat, const float sat_thr, const float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    const float nJ                   = JMh.x / limitJmax;\n    const float snJ                  = max(0.0f, 1.0f - nJ);\n\n    const float normalisation_factor = chromaCompressionNorm(JMh.z); // reachCuspM; // pow(nJ, model_gamma) * reachMMax; //\n    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor; // 1.0f; //\n\n    const float toe_limit           = limit - 0.001f;  // TODO; magic constantl\n    const float toe_snJ_sat         = snJ * sat;\n    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);\n    const float toe_nJ_compr        = nJ * compr;\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= normalisation_factor;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);\n\n      // Denormalize\n      M *= normalisation_factor;\n    \}\n    else\n    \{\n      M /= normalisation_factor;\n      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);\n      M *= normalisation_factor;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 compressChroma(float3 JMh, const float originalJ, const float reachM, const bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, reachM, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse)\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);\n        const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);\n        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);\n        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped      = clamp_to_AP1(src);\n        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(JMh.z);\n        const float  t      = limiting_lerp_fraction(JMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);\n        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);\n        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);\n        output              = compressChroma(src, JMh.x, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        const int    pos  = lookupLimitingCuspHue(src.z);\n        const float  t    = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);\n        output            = compressChroma(src, JMh.x, reachM, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA], t);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const int   pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float reachM      = reachMFromTable(pos, t);\n        output = float3(chromaCompressionNorm(src.z), reachM, wrapped_hue);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.z);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.w);\n    \}\n    else if (DEBUG_reachMTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float reachM = reachMTable\[index];\n        output = float3(reachM, src.z, index);\n    \}\n    \n    else if (DEBUG_Jconstants == diagnosticMode)\n    \{\n        output = float3(_midJ, _limitJmax, _focusDist);\n    \}\n    else if (DEBUG_FocusConstants == diagnosticMode)\n    \{\n        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);\n    \}\n    else if (DEBUG_reachMConditions == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);\n        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);\n\n        output = float3(sM, dM, wrapped_hue); \n    \}\n    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (100 == diagnosticMode)\n    \{\n        const float sm  = src.z * smin(src.x / src.z, src.y / src.z, clamped_smoothness);\n        const float sms = smin_s(src.x, src.y, clamped_smoothness, src.z);\n        output = float3(sm, sms, src.z); \n    \}\n    else if (102 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const float2 found       = find_reach_cusp_for_hue(wrapped_hue, SOURCE_CONDITIONS, hueFindingTollerance);\n        const float  norm        = chromaCompressionNorm(wrapped_hue);\n        output = float3(found.x, found.y, norm);\n    \}\n    else if (103 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_JMh_corners\[index];\n    \}\n    else if (104 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_cusp_corners\[index];\n    \}\n    else if (105 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = display_JMh_corners\[index];\n    \}\n    else if (106 == diagnosticMode)\n    \{\n        output = float3(input_upper_clamp / _XYZ_w_scaler);\n    \}\n    else if (107 == diagnosticMode)\n    \{\n        const int index = int(src.z) % (2 * cuspCornerCount);\n        output = float3(cube_hues\[index], index, unique_hues);\n    \}\n    else if (108 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const int    i           = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n        output = float3(float(pos), pos + t, float(i));\n    \}\n    else if (109 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float hue = hueTable\[index];\n        output = float3(float(index), hue, hue);\n    \}\n    else if (110 == diagnosticMode)\n    \{\n        const float wrapped_hue  = wrap_hue(src.z);\n        const int   pos          = lookupLimitingCuspHue(wrapped_hue);\n        const float t            = limiting_lerp_fraction(wrapped_hue, pos);\n        const float computed_hue = lerp(hueTable\[pos - 1], hueTable\[pos], t);\n        output = float3(computed_hue, wrapped_hue, src.z);\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_Peak Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Kernel_Limiting primaries" {{params.limiting_primaries}}
  "ACES_DRT_Kernel_Limiting Whitepoint" {{params.limiting_whitepoint}}
  "ACES_DRT_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name DRT
  selected true
  xpos 228
  ypos 85
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_limiter.blink
  recompileCount 222
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise 7487a34904160a1d2d4333cb1ceb64e5312c7856e9e5e054a0b0edbe91fa1f78 2 \"src\" Read Point \"dst\" Write Point 12 \"Direction\" Bool 1 AA== \"Limiting Primaries\" Int 1 AwAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Limiting Whitepoint\" Int 1 AgAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Limiting Peak Luminance\" Float 1 AADIQg== \"Clamp to limiting space\" Bool 1 AQ== \"White point scale\" Bool 1 AQ== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 12 \"invert\" 1 1 \"limitingPrimaries\" 1 1 \"encodingPrimaries\" 1 1 \"limitingWhite\" 1 1 \"encodingWhite\" 1 1 \"limitingLuminance\" 1 1 \"limitClamp\" 1 1 \"whitepoint_scale\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 5 \"XYZ_to_limiting_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"limiting_RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"white_scaling_factor\" Float 1 1 AAAAAA== \"white_scaled\" Bool 1 1 AA== \"has_effect\" Bool 1 1 AA=="
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int limitingPrimaries;\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int limitingWhite;\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float limitingLuminance;\n\n  bool limitClamp;\n  bool whitepoint_scale;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  float3x3 XYZ_to_limiting_RGB;\n  float3x3 limiting_RGB_to_XYZ;\n\n  float white_scaling_factor;\n  bool white_scaled;\n  bool has_effect;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(limitingLuminance, \"Limiting Peak Luminance\", 100.0f);\n    defineParam(limitingPrimaries, \"Limiting Primaries\", 3);\n    defineParam(limitingWhite, \"Limiting Whitepoint\", 2);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(limitClamp, \"Clamp to limiting space\", true);\n    defineParam(whitepoint_scale, \"White point scale\", true);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n \}\n\n  void init()\n  \{\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(limitingPrimaries, custom_primaries, temp_primaries);\n    const float2 limiting_whitepoint = get_whitepoint(limitingWhite, custom_white);\n    limiting_RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_limiting_RGB = limiting_RGB_to_XYZ.invert();\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2   encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    const float3x3 XYZ_to_encoding_RGB = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, INVERSE);\n\n    // Scale to fit maximum creative white channel value\n    const float3 creativeWhiteXYZ = vector_dot(limiting_RGB_to_XYZ, float3(1.0f));\n    const float3 creativeWhiteRGB = vector_dot(XYZ_to_encoding_RGB, creativeWhiteXYZ);\n    const float  max_channel      = max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    white_scaling_factor          = (whitepoint_scale) ? 1.0f / max_channel : 1.0f; // TODO: add scaling into reencoding matrix?\n    white_scaled                  = (white_scaling_factor != 1.0f);\n\n    has_effect = white_scaled;\n    if (!invert)\n    \{\n      has_effect |= limitClamp;\n    \}\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  inline float3 xyz_to_limiting(const float3 XYZ)\n  \{\n    return vector_dot(XYZ_to_limiting_RGB, XYZ);\n  \}\n\n  inline float3 limiting_to_xyz(const float3 RGB)\n  \{\n    return vector_dot(limiting_RGB_to_XYZ, RGB);\n  \}\n\n  inline float3 apply_limiting_clamp(float3 RGB)\n  \{\n    if (limitClamp)\n    \{\n      RGB = clamp(RGB, float3\{0.0f\}, float3\{limitingLuminance\});\n    \}\n    return RGB;\n  \}\n\n  inline float3 apply_whitepoint_scale(float3 RGB)\n  \{\n    if (white_scaled)\n    \{\n      RGB *= white_scaling_factor;\n    \}\n    return RGB;\n  \}\n\n  inline float3 remove_whitepoint_scale(float3 RGB)\n  \{\n    RGB /= white_scaling_factor;\n    return RGB;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 out(source.x, source.y, source.z);\n\n    if (has_effect)\n    \{\n      if (invert)\n      \{\n        out = xyz_to_limiting(out);\n        out = remove_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n      else\n      \{\n        out = xyz_to_limiting(out);\n        out = apply_limiting_clamp(out);\n        out = apply_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n    \}\n\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Encoding_Kernel_Limiting Primaries" {{params.limiting_primaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.OutPrimaries}}
  "ACES_DRT_Encoding_Kernel_Limiting Whitepoint" {{params.limiting_whitepoint}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.OutWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Limiting Peak Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Encoding_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Encoding_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  rebuild_finalise ""
  name Limiter
  xpos 228
  ypos 121
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 53
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction true
  ACES_DRT_Encoding_Kernel_Encoding {{parent.OutEncoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.OutPrimaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.OutWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Reference Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Encoding_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Encoding_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  rebuild_finalise ""
  name Encode
  xpos 228
  ypos 157
 }
 Output {
  name Output1
  xpos 228
  ypos 224
 }
 StickyNote {
  inputs 0
  name params
  label "params\n"
  xpos 339
  ypos 12
  addUserKnob {20 User}
  addUserKnob {4 limiting_whitepoint l "Limiting Gamut" M {"Illuminant E" ACES D65 DCI Custom "" ""}}
  limiting_whitepoint D65
  addUserKnob {4 limiting_primaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom ""}}
  limiting_primaries "Rec.709  (sRGB)"
  addUserKnob {20 Custom n 1}
  addUserKnob {12 custom_red l "Custom red"}
  custom_red {0.6399999857 0.3300000131}
  addUserKnob {12 custom_green l "Custom Green"}
  custom_green {0.3000000119 0.6000000238}
  addUserKnob {12 custom_blue l "Custom Blue"}
  custom_blue {0.150000006 0.05999999866}
  addUserKnob {12 custom_white l "Custom White"}
  custom_white {0.3127000034 0.3289999962}
  addUserKnob {20 endGroup n -1}
  addUserKnob {7 peakLuminance l Peak R 10 10000}
  peakLuminance 100
 }
end_group
set N929a680 [stack 0]
Colorspace {
 colorspace_in st2084
 primary_in Rec.2020
 primary_out Rec.2020
 name Colorspace1
 xpos 273
 ypos -120
}
push $N929a680
push $N92925c0
Group {
 name ACES_DRT_FULL
 xpos 146
 ypos -174
 addUserKnob {20 User}
 addUserKnob {4 InEncoding l Input M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
 addUserKnob {4 InWhitepoint l "" -STARTLINE M {"Illuminant E" ACES D65 DCI Custom ""}}
 InWhitepoint ACES
 addUserKnob {4 InPrimaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" "" "" "" "" ""}}
 InPrimaries AP0-ACES
 addUserKnob {26 Limit l Limiting}
 addUserKnob {41 limiting_whitepoint l "Limiting Gamut" T params.limiting_whitepoint}
 addUserKnob {41 limiting_primaries l "" -STARTLINE T params.limiting_primaries}
 addUserKnob {20 Custom n 1}
 Custom 0
 addUserKnob {41 custom_red l "Custom red" T params.custom_red}
 addUserKnob {41 custom_green l "Custom Green" T params.custom_green}
 addUserKnob {41 custom_blue l "Custom Blue" T params.custom_blue}
 addUserKnob {41 custom_white l "Custom White" T params.custom_white}
 addUserKnob {20 endGroup n -1}
 addUserKnob {41 peakLuminance l Peak T params.peakLuminance}
 addUserKnob {26 Limiter l Scale/Clipping}
 addUserKnob {6 WhiteScale l "White Scaling" +STARTLINE}
 WhiteScale true
 addUserKnob {6 HardClip l "Hard Clip" +STARTLINE}
 HardClip true
 addUserKnob {26 Encoding}
 addUserKnob {4 OutEncoding l Output -STARTLINE M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
 OutEncoding "BT.1886 (Gamma 2.4)"
 addUserKnob {4 OutWhitepoint l "" -STARTLINE M {"Illuminant E" ACES D65 DCI Custom "" ""}}
 OutWhitepoint D65
 addUserKnob {4 OutPrimaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" ""}}
 OutPrimaries "Rec.709  (sRGB)"
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  color {0.801596 0.176808 -0.198404 0}
  color_panelDropped true
  format "256 256 0 0 256 256 1 square_256"
  name NoInput
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 51
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Encoding {{parent.InEncoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.InPrimaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.InWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Encoding_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Encoding_Kernel_Custom White" {0.3127000034 0.3289999962}
  rebuild_finalise ""
  name Decode
  xpos 228
  ypos 49
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 227
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Kernel\" iterate pixelWise a546cd9cba9682f370361c457308753c0b805750e9fad0cd6e79b12111e27470 2 \"src\" Read Point \"dst\" Write Point 47 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 1 AABAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 47 \"invert\" 1 1 \"AP1Clamp\" 1 1 \"_peakLuminance\" 1 1 \"primariesLimit\" 1 1 \"whiteLimit\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 \"_inputViewingConditions\" 1 1 \"L_A_in\" 1 1 \"Y_b_in\" 1 1 \"_outputViewingConditions\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 \"_userSurround\" 3 1 \"_XYZ_w_scaler\" 1 1 \"diagnosticMode\" 1 1 \"_smoothCusps\" 1 1 \"_smoothOffset\" 2 1 \"_cuspMidBlend\" 1 1 \"_focusGainBlend\" 1 1 \"_focusAdjustGain\" 1 1 \"_focusDistance\" 1 1 \"_focusDistanceScaling\" 1 1 \"_compressionFuncParams\" 1 1 \"LMS_rxy\" 2 1 \"LMS_gxy\" 2 1 \"LMS_bxy\" 2 1 \"LMS_wxy\" 2 1 \"chroma_compress\" 1 1 \"chroma_compress_fact\" 1 1 \"chroma_expand\" 1 1 \"chroma_expand_fact\" 1 1 \"chroma_expand_thr\" 1 1 \"lowerHullGamma\" 1 1 \"upperHullGamma\" 1 1 \"disableUpperHullGamma\" 1 1 \"disableLowerHullGamma\" 1 1 \"aces_ts_n_r\" 1 1 \"aces_ts_g\" 1 1 \"aces_ts_c\" 1 1 \"aces_ts_c_d\" 1 1 \"aces_ts_w_g\" 1 1 \"aces_ts_t_1\" 1 1 \"aces_ts_r_hit_min\" 1 1 \"aces_ts_r_hit_max\" 1 1 47 \"DL_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DL_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"achromatic_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"hueTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"limitingGamutCuspTable\" Float 4 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachMTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"cube_hues\" Float 1 12 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"unique_hues\" Int 1 1 AAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_base_slope\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"chromaCompressScale\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"aces_ts_inv_upper_limit\" Float 1 1 AAAAAA== \"input_upper_clamp\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int whiteLimit;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#define DEBUG_limitingGamutCuspTableRaw 60\n#define DEBUG_limitingGamutCuspTableRaw2 61\n#define DEBUG_reachMTableRaw 62\n\n\n#define DEBUG_Jconstants 70\n#define DEBUG_FocusConstants 71\n#define DEBUG_limitingFocusJ 72\n#define DEBUG_reachMConditions 73\n\n#define DEBUG_gamutCompressAlphaFORWARDS 80\n#define DEBUG_gamutCompressAlphaINVERSE 81\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold\n  float _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3 DL_weights\[NUMBER_CONDITIONS];\n  float3 DM_weights\[NUMBER_CONDITIONS];\n  float3 DS_weights\[NUMBER_CONDITIONS];\n  \n  float3 DL_weights_inv\[NUMBER_CONDITIONS];\n  float3 DM_weights_inv\[NUMBER_CONDITIONS];\n  float3 DS_weights_inv\[NUMBER_CONDITIONS];\n\n  float3 achromatic_w;\n  float3 a_w;\n  float3 b_w;\n\n  float3 achromatic_weights\[NUMBER_CONDITIONS];\n  float3 a_weights\[NUMBER_CONDITIONS];\n  float3 b_weights\[NUMBER_CONDITIONS];\n\n  float3 achromatic_weights_inv\[NUMBER_CONDITIONS];\n  float3 a_weights_inv\[NUMBER_CONDITIONS];\n  float3 b_weights_inv\[NUMBER_CONDITIONS];\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n\n#define j_scale      100.0f\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n\n//#define USE_DEGREES\n#ifdef USE_DEGREES\n#define hue_limit 360.0f\n#else\n#define hue_limit (2 * PI)\n#endif\n#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range \[0.0, hue_limit) needs to be a multiple of 6 to sample hull corners\n#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases\n#define totalTableSize gamutCuspTableSize + additonal_entries\n#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle\n\n#define gammaAccuracy 5e-6\n#define gammaMinimum 0.4f\n#define gammaMaximum 2.0f\n#define gammaSearchStep 0.2f\n#define badGammaTollerance 1e-2f\n#define hueFindingTollerance 1e-7f\n\n  // Non-uniform in h\n  float  hueTable\[totalTableSize];\n  float4 limitingGamutCuspTable\[totalTableSize];    // \{ J, M, Upper gamma, Lower gamma \}\n  float reachMTable\[totalTableSize];                // reachM \n\n// Note reuse of Hue channel 2\n#define UPPER_GAMMA 2\n#define LOWER_GAMMA 3\n\n#define cuspCornerCount 6\n#define totalCornerCount cuspCornerCount + additonal_entries\n\n  float3 reach_cusp_corners\[totalCornerCount];\n  float3 reach_JMh_corners\[totalCornerCount];\n\n  float3 display_cusp_corners\[totalCornerCount];\n  float3 display_JMh_corners\[totalCornerCount];\n\n  float cube_hues\[2*cuspCornerCount];\n  int unique_hues;\n\n  float  clamped_smoothness;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma; // TODO: investigate uses of this\n  float _base_slope;\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n  float chromaCompressScale; // Scaling foactor for 'cusp' normalisation factor\n\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_m_2;\n  float aces_ts_inv_upper_limit;\n  float input_upper_clamp;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9f, 0.59f, 0.9f));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", 0.75f);\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(1.0f / 3.0f, 1.0f / 3.0f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float3x3 newMatrix =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    if (direction == INVERSE)\n    \{\n      return newMatrix.invert();\n    \}\n    return newMatrix;\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  float3x3 generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_w = nl_scale * float3(ra, 1.0f, ba);\n    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;\n\n    float3x3 mat =  constuct_inverse_matrix(achromatic_w, a_w, b_w);\n\n    for (int i = 0; i != 3; ++i)\n    \{\n      float n = (460.0f / mat\[i]\[0]) / 1403.0f;\n      mat\[i]\[0] *= n / nl_scale;\n      mat\[i]\[1] *= n / nl_scale;\n      mat\[i]\[2] *= n / nl_scale;\n    \}\n    return mat;\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8f, 0.525f, 0.8f);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9f, 0.59f, 0.9f);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0f, 0.69f, 1.0f);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  void init_matrices(float3x3& CAT_CAT16)\n  \{\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n    float2 temp_primaries\[3] =\n    \{\n      LMS_rxy, LMS_gxy, LMS_bxy\n    \};\n  \n    float3x3 CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(temp_primaries, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE;  // Future Nuke versions make the inverse an inplace operator\n    CAT_CAT16 = CAT_CAT16.invert(); // So we copy it then invert, this extra assignment could be dropped in the future\n\n    // AP1 matrix\n    get_primaries(2, custom_primaries, temp_primaries);\n    float2 whitepoint = get_whitepoint(1, custom_white);\n    AP1_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_AP1 = AP1_to_XYZ;\n    XYZ_to_AP1 = XYZ_to_AP1.invert();\n\n    get_primaries(primariesLimit, custom_primaries, temp_primaries);\n    whitepoint = get_whitepoint(whiteLimit, custom_white);\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit;\n    XYZ_to_RGB_limit = XYZ_to_RGB_limit.invert();\n  \}\n\n  void init_chroma_compression(const float peakLuminance, const float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / peakLuminance;\n    chromaCompressScale = pow(0.03379f * peakLuminance, 0.30596f) - 0.45135f;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  float2 init_gamut_mapper(const float peakLuminance, const float log_peak, const float3 white)\n  \{\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(white * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = linear_RGB_to_JMh(float3(peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n    _base_slope = _limitJmax * _focusDist;\n\n    clamped_smoothness             = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?\n    const float2 smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n    return smooth_cusp_scale;\n  \}\n\n  inline float3 generate_unit_cube_corners(const int corner)\n  \{\n    // Generation order R, Y, G, C, B, M to ensure hues rotate in correct order\n    return float3(int(((corner+1)%cuspCornerCount) < 3), int(((corner+5)%cuspCornerCount) < 3), int(((corner+3)%cuspCornerCount) < 3));\n  \}\n\n  void build_cusp_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount], const int rgb_conditions, const float3x3& rgb_matrix, const float peakLuminance)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      temp_cusp_corners\[i] = vector_dot(rgb_matrix, peakLuminance * generate_unit_cube_corners(i));\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  void find_reach_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount],\n                                const int rgb_conditions, const float3x3& rgb_matrix, const float limitJ, const float maximum_source)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      const float3 xyz_vector = vector_dot(rgb_matrix, generate_unit_cube_corners(i));\n      float3 JMh = float3(0.0f);\n\n      float lower = 0.0f;\n      float upper = maximum_source;\n      while ((upper - lower) > 1e-3)\n      \{\n        float test = midpoint(lower, upper);\n        const float3 test_corner = test * xyz_vector;\n        JMh = XYZ_to_JMh(test_corner, rgb_conditions);\n        if (JMh.x < limitJ)\n        \{\n          lower = test;\n        \}\n        else\n        \{\n          upper = test;\n        \}\n        if (JMh.x == limitJ)\n          break;\n      \}\n      temp_cusp_corners\[i] = upper * xyz_vector;\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n \n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  int extract_sorted_cube_hues(float sorted_hues\[12], const float3 reach_JMh\[totalCornerCount], const float3 display_JMh\[totalCornerCount])\n  \{\n    // Basic merge of 2 sorted arrays, extracting the unique hues.\n    // Return the count of the unique hues\n    int idx = 0;\n    int reach_idx = 1;\n    int display_idx = 1;\n    while ((reach_idx < (cuspCornerCount + 1)) || (display_idx < (cuspCornerCount + 1)))\n    \{\n      const float reach_hue = reach_JMh\[reach_idx].z;\n      const float display_hue = display_JMh\[display_idx].z;\n      if (reach_hue == display_hue)\n      \{\n        sorted_hues\[idx] = reach_hue;\n        ++reach_idx;\n        ++display_idx; // When equal consume both\n      \}\n      else\n      \{\n        if (reach_hue < display_hue)\n        \{\n          sorted_hues\[idx] = reach_hue;\n          ++reach_idx;\n        \}\n        else\n        \{\n          sorted_hues\[idx] = display_hue;\n          ++display_idx;\n        \}\n      \}\n      ++idx;\n    \}\n    return idx;\n  \}\n\n  void build_hue_sample_interval(const int samples, const float lower, const float upper, float hueTable\[totalTableSize], const int base)\n  \{\n    const float delta = (upper - lower) / float(samples);\n    for (int i = 0; i != samples; ++i)\n    \{\n      hueTable\[base + i] = lower + float(i) * delta;\n    \}\n  \}\n\n  void build_hue_table(float hueTable\[totalTableSize], const float cube_hues\[2*cuspCornerCount], const int unique_hues)\n  \{\n    const float ideal_spacing = gamutCuspTableSize / hue_limit;\n    int samples_count\[2*cuspCornerCount+2];\n    int last_idx = -1;\n    int min_index = cube_hues\[0] == 0.0f ? 0 : 1; // Ensure we can always sample at 0.0 hue\n    for (int hue_idx = 0; hue_idx != unique_hues; ++hue_idx)\n    \{\n      // BUG: \"gamutCuspTableSize - 1\" will fail if we have multple hues mapping near the top of the table\n      int nominal_idx = clamp(int(round(cube_hues\[hue_idx] * ideal_spacing)), min_index, gamutCuspTableSize - 1);\n      if (last_idx == nominal_idx)\n      \{\n        // Last two hues should sample at same index, need to adjust them\n        // Adjust previous sample down if we can\n        if (hue_idx > 1 && samples_count\[hue_idx - 2] != (samples_count\[hue_idx - 1] - 1))\n        \{\n          samples_count\[hue_idx - 1] = samples_count\[hue_idx - 1] - 1;\n        \}\n        else\n        \{\n          nominal_idx = nominal_idx + 1;\n        \}\n      \}\n      samples_count\[hue_idx] = min(nominal_idx, gamutCuspTableSize - 1);\n      last_idx = min_index = nominal_idx;\n    \}\n\n    int total_samples = 0;\n    // Special cases for ends\n    int i = 0;\n    build_hue_sample_interval(samples_count\[i], 0.0f, cube_hues\[i], hueTable, total_samples+1);\n    total_samples += samples_count\[i];\n    for (++i; i != unique_hues; ++i)\n    \{\n      const int samples = samples_count\[i]-samples_count\[i-1];\n      build_hue_sample_interval(samples, cube_hues\[i-1], cube_hues\[i], hueTable, total_samples+1);\n      total_samples += samples;\n    \}\n    // BUG: could break if we are unlucky with samples all being used up by this point\n    build_hue_sample_interval(gamutCuspTableSize - total_samples, cube_hues\[i-1], hue_limit, hueTable, total_samples+1);\n\n    hueTable\[0] = hueTable\[totalTableSize - 2] - hue_limit;\n    hueTable\[totalTableSize - 1] = hueTable\[1] + hue_limit;\n  \}\n\n  float2 find_reach_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (reach_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (reach_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(reach_JMh_corners\[lower_corner].x, reach_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = reach_cusp_corners\[lower_corner];\n    const float3 cusp_upper = reach_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < reach_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > reach_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  float2 find_display_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (display_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (display_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(display_JMh_corners\[lower_corner].x, display_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = display_cusp_corners\[lower_corner];\n    const float3 cusp_upper = display_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < display_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > display_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  void initialise_cusp_table(float4 output_table\[totalTableSize], const float luminance, const int conditions)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    for (int i = 1; i != gamutCuspTableSize + 1; ++i)\n    \{\n      const float hue = hueTable\[i];\n      const float2 JM = find_display_cusp_for_hue(hue, conditions, hueFindingTollerance);\n      output_table\[i] = float4(JM.x, JM.y, hue, 0.0f);\n    \}\n\n    // Copy extra entries to ease the code to handle hues wrapping around\n    output_table\[0]                              = output_table\[baseIndex + gamutCuspTableSize - 1];\n    output_table\[baseIndex + gamutCuspTableSize] = output_table\[baseIndex];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    output_table\[0].z = output_table\[0].z - hue_limit;\n    output_table\[baseIndex + gamutCuspTableSize].z = output_table\[baseIndex + gamutCuspTableSize].z + hue_limit;\n  \}\n\n  void smooth_cusp_table(float4 table\[totalTableSize], const float2 scale)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      //table\[i].x      = table\[i].x * scale.x; // Not needed as the scale is unity\n      table\[i].y      = table\[i].y * scale.y;\n    \}\n  \}\n\n  void precompute_reach_table(float reachMTable\[totalTableSize], const float limitJ, const float3x3& xyz_matrix,\n                              const float3x3& rgb_matrix, const int conditions)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      reachMTable\[i] = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);\n    \}\n  \}\n\n  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)\n  \{\n    const float search_range = 100.0;\n    float low     = 0.0;\n    float high    = low + search_range;\n    bool  outside = false;\n\n    while (!outside && high < 1400.0)\n    \{\n      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));\n      if (!outside)\n      \{\n        low  = high;\n        high = high + search_range;\n      \}\n    \}\n\n    while ((high - low) > threshold)\n    \{\n      const float sampleM = midpoint(low, high);\n      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));\n      if (outside)\n      \{\n        high = sampleM;\n      \}\n      else\n      \{\n        low = sampleM;\n      \}\n    \}\n    return high;\n  \}\n\n  void fill_initial_hull_gammas(float4 table\[totalTableSize], float upperHullGamma, float lowerHullGamma)\n  \{\n    upperHullGamma = 1.0f / upperHullGamma;\n    lowerHullGamma = 1.0f / lowerHullGamma;\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      table\[i]\[UPPER_GAMMA] = upperHullGamma;\n      table\[i]\[LOWER_GAMMA] = lowerHullGamma;\n    \}\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||\n        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal);\n  \}\n\n  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,\n                               const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                               const float2 estimated_hull_gammas, const int conditions)\n  \{\n    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);\n    const float analytical_threshold = compute_analytical_threshold(JMcusp.x, limitJmax, focusGainBlend);\n    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);\n\n    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float approxLimit =\n        findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);\n    const float J_boundary       = slope * approxLimit + intersectJ;\n\n    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);\n    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);\n    return newLimitRGB;\n  \}\n\n  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float2 estimated_hull_gammas,\n                                     const float limitJmax, const float base_slope, const float midJ,\n                                     const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                                     const float luminance, const int conditions)\n  \{\n    for (int testIndex = 0; testIndex != test_count; ++testIndex)\n    \{\n      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh\[testIndex], limitJmax, base_slope,\n                                                       midJ, cuspMidBlend, focusAdjustGain, focusGainBlend, estimated_hull_gammas, conditions);\n\n      if (!outside_hull(newLimitRGB, luminance))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.5f, 0.8f, 0.99f\};\n    if (!disableUpperHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n        const float  hue                 = hueTable\[i];\n        const float4 cusp                = table\[i];\n        const float2 JMcusp              = float2(cusp.x, cusp.y);\n\n        float3 testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          // create test values between the cusp and the Jmax\n          testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(high, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(testGamma, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[UPPER_GAMMA] = testGamma;\n      \}\n    \}\n    // Wrap the end entries\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f);\n  \}\n\n  void initialise_lower_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.4f, 0.6f, 0.75f\};\n    const float fixed_gamma = 1.0f / lowerHullGamma;\n    if (!disableLowerHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        const float4 cusp   = table\[i];\n        const float2 JMcusp = float2(cusp.x, cusp.y);\n        const float  hue    = hueTable\[i];\n\n        float3       testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], high);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], testGamma);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[LOWER_GAMMA] = testGamma;\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  float replace_gamma_entry(float4 table\[totalTableSize], int entry, int channel)\n  \{\n    // Very simple patch up, try to find good values either side and lerp a new value\n    int lower = entry - 1;\n    while (lower >= 0)\n    \{\n      if (!bad_gamma_value(table\[lower]\[channel]))\n        break;\n      lower = lower - 1;\n    \}\n    if (lower < 0)\n      return -1.0f; // Give up if we can't find a good entry below\n\n    int upper = entry + 1;\n    while (upper < baseIndex + gamutCuspTableSize)\n    \{\n      if (!bad_gamma_value(table\[upper]\[channel]))\n        break;\n      upper = upper + 1;\n    \}\n    if (upper == totalTableSize)\n      return -2.0f; // Give up nothing above us\n\n    float lower_hue = hueTable\[lower];\n    float upper_hue = hueTable\[upper];\n    float entry_hue = hueTable\[entry];\n    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);\n    return lerp(table\[lower]\[channel], table\[upper]\[channel], lerp_loc);\n  \}\n\n  bool bad_gamma_value(const float value)\n  \{\n    return ((value <= 0.0f) || (value <= gammaMinimum+badGammaTollerance) || (value >= gammaMaximum-badGammaTollerance));\n  \}\n\n  void repair_broken_gamma_values(float4 table\[totalTableSize])\n  \{\n    for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n    \{\n      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)\n      \{\n        if (bad_gamma_value(table\[i]\[channel]))\n        \{\n          table\[i]\[channel] = replace_gamma_entry(table, i, channel);\n        \}\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  inline float3 extract_row(const float3x3 matrix, int row)\n  \{\n    return \{matrix\[row]\[0], matrix\[row]\[1], matrix\[row]\[2]\};\n  \}\n\n  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)\n  \{\n    return weight * extract_row(matrix, row);\n  \}\n\n  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)\n  \{\n    float3x3 matrix =\n    \{\n      a.x, a.y, a.z,\n      b.x, b.y, b.z,\n      c.x, c.y, c.z\n    \};\n    return matrix.invert();\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK,\n                          bool discountIlluminant, int stage, float3x3 CAT_CAT16, float3x3 panlrcm)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0.0f, 1.0f);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k    = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4   = k * k * k * k;\n    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);\n    F_L\[stage]       = _F_L / nl_normalise; //TODO white scale?\n\n    // # FWd Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    //float3 RGB = vector_dot(CAT_CAT16, XYZ);\n    //float3 RGB_c = D_RGB\[conditions] * RGB; // combine with CAT16\n\n    // Pre weight CAT16 matrix by D\n    DL_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].x, CAT_CAT16, 0);\n    DM_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].y, CAT_CAT16, 1);\n    DS_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].z, CAT_CAT16, 2);\n\n    // # Inv Step 6\n    //const float3 RGB = RGB_c / D_RGB\[conditions];\n    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n    const float3x3 tempmat = constuct_inverse_matrix(DL_weights\[stage], DM_weights\[stage], DS_weights\[stage]);\n    DL_weights_inv\[stage] = extract_row(tempmat, 0);\n    DM_weights_inv\[stage] = extract_row(tempmat, 1);\n    DS_weights_inv\[stage] = extract_row(tempmat, 2);\n\n    // Prescale values\n    surround\[stage].y = surround\[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n    surround\[stage].z = surround\[stage].z * 43.0f;\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L\[stage] * RGB_wc);\n    const float A_w     = dot(achromatic_w, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    y_to_j_A_w\[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);\n\n    F_L\[stage] *= _XYZ_w_scaler; // Allows tonescale multiplier to be removed\n\n    achromatic_weights\[stage] = achromatic_w / A_w;\n    a_weights\[stage]          = surround\[stage].z * a_w;\n    b_weights\[stage]          = surround\[stage].z * b_w;\n\n    const float3 column_weights = float3(A_w, 1.0f / surround\[stage].z, 1.0f / surround\[stage].z);\n    achromatic_weights_inv\[stage]   = extract_row(panlrcm, 0) * column_weights;\n    a_weights_inv\[stage]            = extract_row(panlrcm, 1) * column_weights;\n    b_weights_inv\[stage]            = extract_row(panlrcm, 2) * column_weights;\n  \}\n\n  void init()\n  \{\n    const float log_peak = init_tonescale_constants(_peakLuminance);\n\n    float3x3 CAT_CAT16;\n\n    init_matrices(CAT_CAT16);\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    const float3 inputWhite = vector_dot(AP1_to_XYZ, white);\n    const float3 limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n    const float3x3 panlrcm = generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS, CAT_CAT16, panlrcm);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS, CAT_CAT16, panlrcm);\n\n    init_chroma_compression(_peakLuminance, log_peak);\n    const float2 smooth_cusp_scale = init_gamut_mapper(_peakLuminance, log_peak, limitWhite);\n\n    // Fist find the unique hues for the cusp corners, then fill in the table uniformly between those hues\n    find_reach_corners_tables(reach_cusp_corners, reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _limitJmax, input_upper_clamp);\n    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);\n    unique_hues = extract_sorted_cube_hues(cube_hues, reach_JMh_corners, display_JMh_corners);\n    build_hue_table(hueTable, cube_hues, unique_hues);\n\n    initialise_cusp_table(limitingGamutCuspTable, _peakLuminance, DISPLAY_CONDITIONS);\n    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);\n    fill_initial_hull_gammas(limitingGamutCuspTable, upperHullGamma, lowerHullGamma);\n    // Iterate gamma finding based on previous values\n    for (int i = 0; i != 3; ++i)\n    \{\n      initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n      initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n    \}\n    repair_broken_gamma_values(limitingGamutCuspTable);\n\n    precompute_reach_table(reachMTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS);\n  \}\n\n#ifdef USE_DEGREES\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float to_radians(float hue)\n  \{\n    return hue / 180.0f * PI;\n  \}\n#endif\n\n  inline float wrap_hue(float hue)\n  \{\n    float y = fmod(hue, hue_limit);\n    if (y < 0.0)\n    \{\n      y = y + hue_limit;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB        = clamp(RGB, float3\{0.0f\}, float3(input_upper_clamp));\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_forward(float L)\n  \{\n    const float F_L_L = pow(L, float(nl_gamma));\n    return F_L_L / (nl_offset + F_L_L);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));\n    return F_L_RGB / (nl_offset + F_L_RGB);\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_inverse(float A)\n  \{\n    const float F_L_A = (nl_offset * A) / (1.0f - A);\n    return pow(F_L_A, 1.0f / nl_gamma);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 F_L_RGB = (nl_offset * RGB) / (1.0f - RGB);\n    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);\n    return RGB_c;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);\n    return RGB_p;\n  \}\n\n//  // Return compression gamut cusp M scaled with an eccentricity factor\n//  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n//  \{\n//    if (!apply_eccentricity)\n//    \{\n//        return 1.0f;\n//    \}\n//\n//    // Hellwig2022/Helles2023\n//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n//    const float _2_hr = 2 * hr;\n//    const float _3_hr = 3 * hr;\n//    const float _4_hr = 4 * hr;\n//    // clang-format off\n//    return (\n//        - 0.0582f * cos(_1_hr)\n//        - 0.0258f * cos(_2_hr)\n//        - 0.1347f * cos(_3_hr)\n//        + 0.0289f * cos(_4_hr)\n//        - 0.1475f * sin(_1_hr)\n//        - 0.0308f * sin(_2_hr)\n//        + 0.0385f * sin(_3_hr)\n//        + 0.0096f * sin(_4_hr)\n//        + 1.0f\n//      );\n//    // clang-format on\n//  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float _J_from_Achromatic(float A, int conditions)\n  \{\n    return j_scale * pow(A, surround\[conditions].y);\n  \}\n\n  inline float _Achromatic_from_J(float J, int conditions)\n  \{\n    return pow(J / j_scale, 1.0f / surround\[conditions].y);\n  \}\n\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * _J_from_Achromatic(fabs(A), conditions);\n  \}\n\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * _Achromatic_from_J(fabs(J), conditions);\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    float3 RGB_c;\n    RGB_c.x = dot(DL_weights\[conditions], XYZ);\n    RGB_c.y = dot(DM_weights\[conditions], XYZ);\n    RGB_c.z = dot(DS_weights\[conditions], XYZ);\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);\n\n    const float A = dot(achromatic_weights\[conditions], RGB_a);\n    const float a = dot(a_weights\[conditions], RGB_a);\n    const float b = dot(b_weights\[conditions], RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n#ifdef USE_DEGREES\n    const float h  = wrap_hue(degrees(hr));\n#else\n    const float h  = wrap_hue(hr);\n#endif\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    //const float et = eccentricity_factor(hr, false);\n    //float       M  = surround\[conditions].z * et * sqrt(a * a + b * b);\n    float M = sqrt(a * a + b * b); // Valid as et == 1.0\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n#ifdef USE_DEGREES\n    const float hr = to_radians(JMh.z);\n#else\n    const float hr = JMh.z;\n#endif\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float _A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    //const float et    = eccentricity_factor(hr, false);\n    //const float P_p_1 = surround\[conditions].z; // * et;\n    //const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 Aab = float3(_A, a, b);\n    //const float3 RGB_a = vector_dot(panlrcm, Aab);\n    float3 RGB_a;\n    RGB_a.x = dot(achromatic_weights_inv\[conditions], Aab);\n    RGB_a.y = dot(a_weights_inv\[conditions], Aab);\n    RGB_a.z = dot(b_weights_inv\[conditions], Aab);\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);\n\n    float3 XYZ;\n    XYZ.x = dot(DL_weights_inv\[conditions], RGB_c);\n    XYZ.y = dot(DM_weights_inv\[conditions], RGB_c);\n    XYZ.z = dot(DS_weights_inv\[conditions], RGB_c);\n\n    return XYZ;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / hue_limit * table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b (cubic polynomial)\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline float smin_s(float a, float b, float s, float normalise)\n  \{\n    const float s_scaled     = s * normalise;\n    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;\n    const float h            = max(scaled_delta, 0.0f);\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  inline float midpoint(float low, float high)\n  \{\n    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document\n    return (high + low) * 0.5f;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  int lookupLimitingCuspHue(float wrapped_hue)\n  \{\n    // samples are almost uniform should be able to find the correct entry +/- 6 entries from middle\n    // on average it is actually in a narrow range than this, left as an exersize for the reader to\n    // improve this, typically lies in upper half\n    // either way log2(search_range*2) is way smaller than log2(gamutCuspTableSize)\n    // BUG: needs checking if this range is too small should all the hues cluster together due to a\n    // pathelogical triangle formed by two primaries from one gamut closely bracketing one from the other\n#define search_range 2\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n    int low_i  = max(0, i - search_range);\n    int high_i = min(baseIndex + gamutCuspTableSize, i + search_range); // Allowed as we have extra entries in the table\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > hueTable\[i])\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float limiting_lerp_fraction(float wrapped_hue, int pos)\n  \{\n    return (wrapped_hue - hueTable\[pos - 1])\n          / (hueTable\[pos] - hueTable\[pos - 1]);\n  \}\n\n  inline float4 limitingCuspFromTable(int pos, float t)\n  \{\n    return lerp(limitingGamutCuspTable\[pos - 1], limitingGamutCuspTable\[pos], t);\n  \}\n\n  inline float reachMFromTable(int pos, float t)\n  \{\n    return lerp(reachMTable\[pos - 1], reachMTable\[pos], t);\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)\n  \{\n    // Assume J (0.0, limitJmax)\n    \n    if (J <= analytical_threshold)\n      return 1.0f; // makes the analytic inverse possible below cusp\n\n    // Approximate inverse required above threshold TODO: explain why\n    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n  \}\n\n  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,\n                                  const float focusAdjustGain, const float analytical_threshold)\n  \{\n    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)\n  \{\n    float direction_scaler;\n    if (intersectJ <= focusJ)\n    \{\n      direction_scaler = intersectJ;\n    \}\n    else\n    \{\n       direction_scaler = (limitJmax - intersectJ);\n    \}\n\n    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);\n  \}\n\n  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,\n                                                         const float inv_gamma, const float J_max, const float M_max,\n                                                         const float J_intersection_reference)\n  \{\n    // Line defined by     J = slope * x + J_axis_intersect\n    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)\n    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential\n    \n    // We calculate a shifted intersection from the original intersection using the inverse of the exponential\n    // and the provided reference\n    const float normalised_J        = J_axis_intersect / J_intersection_reference;\n    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);\n\n    // Now we find the M intersection of two lines\n    // line from origin to J,M Max       l1(x) = J/M * x\n    // line from J Intersect' with slope l2(x) = slope * x + Intersect'\n\n    return shifted_intersecion / ((J_max / M_max) - slope);\n    //return shifted_intersecion * M_max / (J_max - slope * M_max);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,\n                                       float2 estimated_hull_gammas, const float slope)\n  \{\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);\n\n    // The upper hull is flipped and thus 'zerod' at J_max\n    // Also note we negate the slope\n    const float f_J_intersect_cusp = J_max - J_intersect_cusp;\n    const float f_J_intersect_source = J_max - J_intersect_source;\n    const float f_JM_cusp_J = J_max - JM_cusp.x;\n    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);\n\n    // Smooth minimum between the two calculated values for the M component\n    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n    return M_boundary;\n    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);\n  \}\n\n  inline float reinhard_compress(const float scale, const float factor, const bool direction)\n  \{\n    if (INVERSE == direction)\n    \{\n      if (factor >= 1.0f)\n        return scale;\n      else\n        return scale * (-(factor / (factor - 1.0f)));\n    \}\n    return scale * (factor) / (1.0f + factor);\n  \}\n\n  inline float gamut_mapped_location(const float location, const float gamutBoundary, const float reachBoundary, const bool direction)\n  \{\n    // Assumes _compressionFuncParams in (0.0, 1.0)\n    const float threshold = clamp(gamutBoundary / reachBoundary, _compressionFuncParams, 0.99999f) * gamutBoundary;\n\n    // Values upto the threshold or when both boundaries are the same remain as is\n    if (location <= threshold || gamutBoundary == reachBoundary)\n      return location;\n\n    // Translate to place threshold at zero\n    const float location_offset = location - threshold;\n    const float boundary_offset = gamutBoundary - threshold;\n    const float reach_offset    = reachBoundary - threshold;\n\n    // Assumes boundary != reach\n    // Generaly speaking boundary should be < reach\n    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);\n    const float factor = location_offset / scale;\n\n    const float relative_location = reinhard_compress(scale, factor, direction);\n\n    return (threshold + relative_location); // shift back to absolute\n  \}\n\n  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,\n                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,\n                    float reachMaxM, float model_gamma)\n  \{\n    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float ganutBoundaryM   = findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,\n                                                                  smoothness, estimated_hull_gammas, slope);\n\n    if (ganutBoundaryM <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)\n    \{\n      return float2(JM.x, 0.0f);\n    \}\n\n    // Compress the out of gamut color along the projection line\n    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);\n    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);\n    const float mappedJ  = slope * mappedM + intersectJ;\n\n    return float2\{mappedJ, mappedM\};\n  \}\n\n  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));\n  \}\n\n  inline float compute_analytical_threshold(const float cuspJ, const float limitJmax, const float focusGainBlend)\n  \{\n    return lerp(cuspJ, limitJmax, focusGainBlend);\n  \}\n\n  float3 gamutMapper(float3 JMh, const float4 cusp, const float reachM, bool direction)\n  \{\n    // Limit to +ve values // TODO test this is neededS\n    if (JMh.x <= 0.0f)\n    \{\n      JMh.x = 0.0f;\n      JMh.y = 0.0f;\n    \}\n    // Above the expected maximum we explicitly map to 0 M\n    if (JMh.x >= _limitJmax)\n    \{\n      JMh.y = 0.0f;\n    \}\n\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f)\n      return JMh;\n\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n    const float2 JMcusp                = float2(cusp.x, cusp.y);\n    const float2 estimated_hull_gammas = float2\{cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA]\};\n    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x, _limitJmax, _focusGainBlend); \n    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);\n\n    float  Jx         = JMh.x;\n    float2 JM         = float2\{JMh.x, JMh.y\};\n    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);\n \n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > analytical_threshold)\n      \{\n        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                        clamped_smoothness, reachM, _model_gamma).x;\n        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);\n      \}\n    \}\n    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                    clamped_smoothness, reachM, _model_gamma);\n\n    return \{JM.x, JM.y, JMh.z\};\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, conditions);\n    return JMh;\n  \}\n\n  float3 JMh_to_linear_RGB(const float3 JMh, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, conditions);\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  float init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions\n\n    const float aces_ts_n      = peakLuminance;\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_m_0) / log(10000.0f / 100.0f));\n    input_upper_clamp = aces_ts_r_hit * 8.0f * _XYZ_w_scaler;  // limit to nice power of 2 (3 stops) above that needed to max out // TODO magic 8 ball factor needs assessing\n\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    const float aces_ts_u      = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    const float aces_ts_m      = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1);\n    const float aces_ts_u_2    = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?\n    return log10(aces_ts_m_0);\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(const float Y)\n  \{\n    // Assumes Y is >= +0.0\n    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);\n    return max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility\n  \}\n\n  inline float aces_ts_rev(const float Y)\n  \{\n    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?\n    const float f = (Y + sqrt(Y * (4.0f * aces_ts_t_1 + Y))) / 2.0f;\n    return aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float _Y_to_Hellwig_J(float Y, int conditions)\n  \{\n    // Assumes Y is >= +0.0\n    const float A = _post_adaptation_non_linear_response_compression_forward(F_L\[conditions] * Y) / y_to_j_A_w\[conditions];\n    return _J_from_Achromatic(A, conditions);\n  \}\n\n  inline float _Hellwig_J_to_Y(float J, int conditions)\n  \{\n    // Assumes J is >= +0.0\n    const float A = y_to_j_A_w\[conditions] * _Achromatic_from_J(J, conditions);\n    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L\[conditions];\n  \}\n\n//  inline float Y_to_Hellwig_J(float Y, int conditions)\n//  \{\n//    const float absY = fabs(Y);\n//    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?\n//  \}\n//\n//  inline float Hellwig_J_to_Y(float J, int conditions)\n//  \{\n//    const float absJ = fabs(J);\n//    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?\n//  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions)\n  \{\n    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below\n    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);\n    const float  luminanceTS   = aces_ts_fwd(inputY);\n    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);\n    return float3(tonemappedJ, inputJMh.y, inputJMh.z);\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);\n    const float  linear          = aces_ts_rev(luminance);\n    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);\n    return float3(untonemappedJ, JMh.y, JMh.z);\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, bool inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2             = max(k2, 0.001f); // TODO; magic constant\n    k1             = sqrt(k1 * k1 + k2 * k2);\n    const float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n    \{\n      const float minus_b = k3 * x - k1;\n      const float minus_c = k2 * k3 * x;\n      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2\n    \}\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompressionNorm(float h)\n  \{\n#ifdef USE_DEGREES\n    const float hr = to_radians(h);\n#else\n    const float hr = h;\n#endif\n    float a = cos(hr);\n    float b = sin(hr);\n    float cos_hr2 = a * a - b * b;\n    float sin_hr2 = 2.0f * a * b;\n    float cos_hr3 = 4.0f * a * a * a - 3.0f * a;\n    float sin_hr3 = 3.0f * b - 4.0f * b * b * b;\n\n    float M = 11.34072f * a +\n              16.46899f * cos_hr2 +\n               7.88380f * cos_hr3 +\n              14.66441f * b +\n              -6.37224f * sin_hr2 +\n               9.19364f * sin_hr3 +\n              77.12896f;\n\n    return M * chromaCompressScale;\n  \}\n\n  inline float chromaCompression(float3 JMh, const float origJ, const float reachMMax, const bool inverse,\n                                 const float limitJmax, const float model_gamma,\n                                 const float sat, const float sat_thr, const float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    const float nJ                   = JMh.x / limitJmax;\n    const float snJ                  = max(0.0f, 1.0f - nJ);\n\n    const float normalisation_factor = chromaCompressionNorm(JMh.z); // reachCuspM; // pow(nJ, model_gamma) * reachMMax; //\n    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor; // 1.0f; //\n\n    const float toe_limit           = limit - 0.001f;  // TODO; magic constantl\n    const float toe_snJ_sat         = snJ * sat;\n    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);\n    const float toe_nJ_compr        = nJ * compr;\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= normalisation_factor;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);\n\n      // Denormalize\n      M *= normalisation_factor;\n    \}\n    else\n    \{\n      M /= normalisation_factor;\n      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);\n      M *= normalisation_factor;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 compressChroma(float3 JMh, const float originalJ, const float reachM, const bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, reachM, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse)\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);\n        const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);\n        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);\n        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped      = clamp_to_AP1(src);\n        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(JMh.z);\n        const float  t      = limiting_lerp_fraction(JMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);\n        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);\n        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);\n        output              = compressChroma(src, JMh.x, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        const int    pos  = lookupLimitingCuspHue(src.z);\n        const float  t    = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);\n        output            = compressChroma(src, JMh.x, reachM, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA], t);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const int   pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float reachM      = reachMFromTable(pos, t);\n        output = float3(chromaCompressionNorm(src.z), reachM, wrapped_hue);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.z);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.w);\n    \}\n    else if (DEBUG_reachMTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float reachM = reachMTable\[index];\n        output = float3(reachM, src.z, index);\n    \}\n    \n    else if (DEBUG_Jconstants == diagnosticMode)\n    \{\n        output = float3(_midJ, _limitJmax, _focusDist);\n    \}\n    else if (DEBUG_FocusConstants == diagnosticMode)\n    \{\n        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);\n    \}\n    else if (DEBUG_reachMConditions == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);\n        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);\n\n        output = float3(sM, dM, wrapped_hue); \n    \}\n    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (100 == diagnosticMode)\n    \{\n        const float sm  = src.z * smin(src.x / src.z, src.y / src.z, clamped_smoothness);\n        const float sms = smin_s(src.x, src.y, clamped_smoothness, src.z);\n        output = float3(sm, sms, src.z); \n    \}\n    else if (102 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const float2 found       = find_reach_cusp_for_hue(wrapped_hue, SOURCE_CONDITIONS, hueFindingTollerance);\n        const float  norm        = chromaCompressionNorm(wrapped_hue);\n        output = float3(found.x, found.y, norm);\n    \}\n    else if (103 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_JMh_corners\[index];\n    \}\n    else if (104 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_cusp_corners\[index];\n    \}\n    else if (105 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = display_JMh_corners\[index];\n    \}\n    else if (106 == diagnosticMode)\n    \{\n        output = float3(input_upper_clamp / _XYZ_w_scaler);\n    \}\n    else if (107 == diagnosticMode)\n    \{\n        const int index = int(src.z) % (2 * cuspCornerCount);\n        output = float3(cube_hues\[index], index, unique_hues);\n    \}\n    else if (108 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const int    i           = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n        output = float3(float(pos), pos + t, float(i));\n    \}\n    else if (109 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float hue = hueTable\[index];\n        output = float3(float(index), hue, hue);\n    \}\n    else if (110 == diagnosticMode)\n    \{\n        const float wrapped_hue  = wrap_hue(src.z);\n        const int   pos          = lookupLimitingCuspHue(wrapped_hue);\n        const float t            = limiting_lerp_fraction(wrapped_hue, pos);\n        const float computed_hue = lerp(hueTable\[pos - 1], hueTable\[pos], t);\n        output = float3(computed_hue, wrapped_hue, src.z);\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_Peak Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Kernel_Limiting primaries" {{params.limiting_primaries}}
  "ACES_DRT_Kernel_Limiting Whitepoint" {{params.limiting_whitepoint}}
  "ACES_DRT_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name DRT
  selected true
  xpos 228
  ypos 85
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_limiter.blink
  recompileCount 222
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise 7487a34904160a1d2d4333cb1ceb64e5312c7856e9e5e054a0b0edbe91fa1f78 2 \"src\" Read Point \"dst\" Write Point 12 \"Direction\" Bool 1 AA== \"Limiting Primaries\" Int 1 AwAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Limiting Whitepoint\" Int 1 AgAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Limiting Peak Luminance\" Float 1 AADIQg== \"Clamp to limiting space\" Bool 1 AQ== \"White point scale\" Bool 1 AQ== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 12 \"invert\" 1 1 \"limitingPrimaries\" 1 1 \"encodingPrimaries\" 1 1 \"limitingWhite\" 1 1 \"encodingWhite\" 1 1 \"limitingLuminance\" 1 1 \"limitClamp\" 1 1 \"whitepoint_scale\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 5 \"XYZ_to_limiting_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"limiting_RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"white_scaling_factor\" Float 1 1 AAAAAA== \"white_scaled\" Bool 1 1 AA== \"has_effect\" Bool 1 1 AA=="
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int limitingPrimaries;\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int limitingWhite;\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float limitingLuminance;\n\n  bool limitClamp;\n  bool whitepoint_scale;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  float3x3 XYZ_to_limiting_RGB;\n  float3x3 limiting_RGB_to_XYZ;\n\n  float white_scaling_factor;\n  bool white_scaled;\n  bool has_effect;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(limitingLuminance, \"Limiting Peak Luminance\", 100.0f);\n    defineParam(limitingPrimaries, \"Limiting Primaries\", 3);\n    defineParam(limitingWhite, \"Limiting Whitepoint\", 2);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(limitClamp, \"Clamp to limiting space\", true);\n    defineParam(whitepoint_scale, \"White point scale\", true);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n \}\n\n  void init()\n  \{\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(limitingPrimaries, custom_primaries, temp_primaries);\n    const float2 limiting_whitepoint = get_whitepoint(limitingWhite, custom_white);\n    limiting_RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_limiting_RGB = limiting_RGB_to_XYZ.invert();\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2   encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    const float3x3 XYZ_to_encoding_RGB = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, INVERSE);\n\n    // Scale to fit maximum creative white channel value\n    const float3 creativeWhiteXYZ = vector_dot(limiting_RGB_to_XYZ, float3(1.0f));\n    const float3 creativeWhiteRGB = vector_dot(XYZ_to_encoding_RGB, creativeWhiteXYZ);\n    const float  max_channel      = max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    white_scaling_factor          = (whitepoint_scale) ? 1.0f / max_channel : 1.0f; // TODO: add scaling into reencoding matrix?\n    white_scaled                  = (white_scaling_factor != 1.0f);\n\n    has_effect = white_scaled;\n    if (!invert)\n    \{\n      has_effect |= limitClamp;\n    \}\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  inline float3 xyz_to_limiting(const float3 XYZ)\n  \{\n    return vector_dot(XYZ_to_limiting_RGB, XYZ);\n  \}\n\n  inline float3 limiting_to_xyz(const float3 RGB)\n  \{\n    return vector_dot(limiting_RGB_to_XYZ, RGB);\n  \}\n\n  inline float3 apply_limiting_clamp(float3 RGB)\n  \{\n    if (limitClamp)\n    \{\n      RGB = clamp(RGB, float3\{0.0f\}, float3\{limitingLuminance\});\n    \}\n    return RGB;\n  \}\n\n  inline float3 apply_whitepoint_scale(float3 RGB)\n  \{\n    if (white_scaled)\n    \{\n      RGB *= white_scaling_factor;\n    \}\n    return RGB;\n  \}\n\n  inline float3 remove_whitepoint_scale(float3 RGB)\n  \{\n    RGB /= white_scaling_factor;\n    return RGB;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 out(source.x, source.y, source.z);\n\n    if (has_effect)\n    \{\n      if (invert)\n      \{\n        out = xyz_to_limiting(out);\n        out = remove_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n      else\n      \{\n        out = xyz_to_limiting(out);\n        out = apply_limiting_clamp(out);\n        out = apply_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n    \}\n\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Encoding_Kernel_Limiting Primaries" {{params.limiting_primaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.OutPrimaries}}
  "ACES_DRT_Encoding_Kernel_Limiting Whitepoint" {{params.limiting_whitepoint}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.OutWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Limiting Peak Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Encoding_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Encoding_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  rebuild_finalise ""
  name Limiter
  xpos 228
  ypos 121
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 49
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction true
  ACES_DRT_Encoding_Kernel_Encoding {{parent.OutEncoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.OutPrimaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.OutWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Reference Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Encoding_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Encoding_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  rebuild_finalise ""
  name Encode
  xpos 228
  ypos 157
 }
 Output {
  name Output1
  xpos 228
  ypos 224
 }
 StickyNote {
  inputs 0
  name params
  label "params\n"
  xpos 339
  ypos 12
  addUserKnob {20 User}
  addUserKnob {4 limiting_whitepoint l "Limiting Gamut" M {"Illuminant E" ACES D65 DCI Custom "" ""}}
  limiting_whitepoint D65
  addUserKnob {4 limiting_primaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom ""}}
  limiting_primaries "Rec.709  (sRGB)"
  addUserKnob {20 Custom n 1}
  addUserKnob {12 custom_red l "Custom red"}
  custom_red {0.6399999857 0.3300000131}
  addUserKnob {12 custom_green l "Custom Green"}
  custom_green {0.3000000119 0.6000000238}
  addUserKnob {12 custom_blue l "Custom Blue"}
  custom_blue {0.150000006 0.05999999866}
  addUserKnob {12 custom_white l "Custom White"}
  custom_white {0.3127000034 0.3289999962}
  addUserKnob {20 endGroup n -1}
  addUserKnob {7 peakLuminance l Peak R 10 10000}
  peakLuminance 100
 }
end_group
push $N92925c0
Group {
 name ACES_DRT_Encoding
 xpos -91
 ypos -180
 addUserKnob {20 User}
 addUserKnob {4 Direction M {Decode Encode}}
 addUserKnob {26 gamut l Gamut}
 addUserKnob {4 whitepoint l Whitepoint M {"Illuminant E" ACES D65 DCI Custom ""}}
 whitepoint ACES
 addUserKnob {4 primaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" ""}}
 primaries AP0-ACES
 addUserKnob {20 Custom n 1}
 Custom 0
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Red" l "Custom Red" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Red"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Green" l "Custom Green" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Green"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Blue" l "Custom Blue" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Blue"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom White" l "Custom White" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom White"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {7 referenceLuminance l "Reference Luminance" R 0 200}
 referenceLuminance 100
 addUserKnob {4 encoding l Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 7
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction {{parent.Direction}}
  ACES_DRT_Encoding_Kernel_Encoding {{parent.encoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.primaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.whitepoint}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Encoding_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Encoding_Kernel_Custom White" {0.3127000034 0.3289999962}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 228
  ypos 74
 }
 Output {
  name Output1
  xpos 228
  ypos 149
 }
end_group
Group {
 name ACESDRT2
 xpos -91
 ypos -153
 addUserKnob {20 User}
 addUserKnob {41 ACES_DRT_Kernel_Invert l Invert T BlinkScript1.ACES_DRT_Kernel_Invert}
 addUserKnob {41 "ACES_DRT_Kernel_Peak Luminance" l "Peak Luminance" T "BlinkScript1.ACES_DRT_Kernel_Peak Luminance"}
 addUserKnob {4 limiting_whitepoint l "White Point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." M {"Illuminant E" ACES D65 DCI Custom ""}}
 limiting_whitepoint D65
 addUserKnob {4 limiting_primaries l Primaries t "the limiting primaries of the gamut to which to compress to" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom ""}}
 limiting_primaries "Rec.709  (sRGB)"
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
 addUserKnob {41 "ACES_DRT_Kernel_Disagnostics Mode" l "Disagnostics Mode" T "BlinkScript1.ACES_DRT_Kernel_Disagnostics Mode"}
}
 Input {
  inputs 0
  name Input1
  xpos 130
  ypos -203
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 7
  ypos -187
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 130
  ypos -163
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 232
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Kernel\" iterate pixelWise a546cd9cba9682f370361c457308753c0b805750e9fad0cd6e79b12111e27470 2 \"src\" Read Point \"dst\" Write Point 47 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 1 AABAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 47 \"invert\" 1 1 \"AP1Clamp\" 1 1 \"_peakLuminance\" 1 1 \"primariesLimit\" 1 1 \"whiteLimit\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 \"_inputViewingConditions\" 1 1 \"L_A_in\" 1 1 \"Y_b_in\" 1 1 \"_outputViewingConditions\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 \"_userSurround\" 3 1 \"_XYZ_w_scaler\" 1 1 \"diagnosticMode\" 1 1 \"_smoothCusps\" 1 1 \"_smoothOffset\" 2 1 \"_cuspMidBlend\" 1 1 \"_focusGainBlend\" 1 1 \"_focusAdjustGain\" 1 1 \"_focusDistance\" 1 1 \"_focusDistanceScaling\" 1 1 \"_compressionFuncParams\" 1 1 \"LMS_rxy\" 2 1 \"LMS_gxy\" 2 1 \"LMS_bxy\" 2 1 \"LMS_wxy\" 2 1 \"chroma_compress\" 1 1 \"chroma_compress_fact\" 1 1 \"chroma_expand\" 1 1 \"chroma_expand_fact\" 1 1 \"chroma_expand_thr\" 1 1 \"lowerHullGamma\" 1 1 \"upperHullGamma\" 1 1 \"disableUpperHullGamma\" 1 1 \"disableLowerHullGamma\" 1 1 \"aces_ts_n_r\" 1 1 \"aces_ts_g\" 1 1 \"aces_ts_c\" 1 1 \"aces_ts_c_d\" 1 1 \"aces_ts_w_g\" 1 1 \"aces_ts_t_1\" 1 1 \"aces_ts_r_hit_min\" 1 1 \"aces_ts_r_hit_max\" 1 1 47 \"DL_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DL_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"achromatic_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"hueTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"limitingGamutCuspTable\" Float 4 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachMTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"cube_hues\" Float 1 12 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"unique_hues\" Int 1 1 AAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_base_slope\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"chromaCompressScale\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"aces_ts_inv_upper_limit\" Float 1 1 AAAAAA== \"input_upper_clamp\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int whiteLimit;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#define DEBUG_limitingGamutCuspTableRaw 60\n#define DEBUG_limitingGamutCuspTableRaw2 61\n#define DEBUG_reachMTableRaw 62\n\n\n#define DEBUG_Jconstants 70\n#define DEBUG_FocusConstants 71\n#define DEBUG_limitingFocusJ 72\n#define DEBUG_reachMConditions 73\n\n#define DEBUG_gamutCompressAlphaFORWARDS 80\n#define DEBUG_gamutCompressAlphaINVERSE 81\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold\n  float _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3 DL_weights\[NUMBER_CONDITIONS];\n  float3 DM_weights\[NUMBER_CONDITIONS];\n  float3 DS_weights\[NUMBER_CONDITIONS];\n  \n  float3 DL_weights_inv\[NUMBER_CONDITIONS];\n  float3 DM_weights_inv\[NUMBER_CONDITIONS];\n  float3 DS_weights_inv\[NUMBER_CONDITIONS];\n\n  float3 achromatic_w;\n  float3 a_w;\n  float3 b_w;\n\n  float3 achromatic_weights\[NUMBER_CONDITIONS];\n  float3 a_weights\[NUMBER_CONDITIONS];\n  float3 b_weights\[NUMBER_CONDITIONS];\n\n  float3 achromatic_weights_inv\[NUMBER_CONDITIONS];\n  float3 a_weights_inv\[NUMBER_CONDITIONS];\n  float3 b_weights_inv\[NUMBER_CONDITIONS];\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n\n#define j_scale      100.0f\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n\n//#define USE_DEGREES\n#ifdef USE_DEGREES\n#define hue_limit 360.0f\n#else\n#define hue_limit (2 * PI)\n#endif\n#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range \[0.0, hue_limit) needs to be a multiple of 6 to sample hull corners\n#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases\n#define totalTableSize gamutCuspTableSize + additonal_entries\n#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle\n\n#define gammaAccuracy 5e-6\n#define gammaMinimum 0.4f\n#define gammaMaximum 2.0f\n#define gammaSearchStep 0.2f\n#define badGammaTollerance 1e-2f\n#define hueFindingTollerance 1e-7f\n\n  // Non-uniform in h\n  float  hueTable\[totalTableSize];\n  float4 limitingGamutCuspTable\[totalTableSize];    // \{ J, M, Upper gamma, Lower gamma \}\n  float reachMTable\[totalTableSize];                // reachM \n\n// Note reuse of Hue channel 2\n#define UPPER_GAMMA 2\n#define LOWER_GAMMA 3\n\n#define cuspCornerCount 6\n#define totalCornerCount cuspCornerCount + additonal_entries\n\n  float3 reach_cusp_corners\[totalCornerCount];\n  float3 reach_JMh_corners\[totalCornerCount];\n\n  float3 display_cusp_corners\[totalCornerCount];\n  float3 display_JMh_corners\[totalCornerCount];\n\n  float cube_hues\[2*cuspCornerCount];\n  int unique_hues;\n\n  float  clamped_smoothness;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma; // TODO: investigate uses of this\n  float _base_slope;\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n  float chromaCompressScale; // Scaling foactor for 'cusp' normalisation factor\n\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_m_2;\n  float aces_ts_inv_upper_limit;\n  float input_upper_clamp;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9f, 0.59f, 0.9f));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", 0.75f);\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(1.0f / 3.0f, 1.0f / 3.0f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float3x3 newMatrix =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    if (direction == INVERSE)\n    \{\n      return newMatrix.invert();\n    \}\n    return newMatrix;\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  float3x3 generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_w = nl_scale * float3(ra, 1.0f, ba);\n    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;\n\n    float3x3 mat =  constuct_inverse_matrix(achromatic_w, a_w, b_w);\n\n    for (int i = 0; i != 3; ++i)\n    \{\n      float n = (460.0f / mat\[i]\[0]) / 1403.0f;\n      mat\[i]\[0] *= n / nl_scale;\n      mat\[i]\[1] *= n / nl_scale;\n      mat\[i]\[2] *= n / nl_scale;\n    \}\n    return mat;\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8f, 0.525f, 0.8f);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9f, 0.59f, 0.9f);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0f, 0.69f, 1.0f);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  void init_matrices(float3x3& CAT_CAT16)\n  \{\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n    float2 temp_primaries\[3] =\n    \{\n      LMS_rxy, LMS_gxy, LMS_bxy\n    \};\n  \n    float3x3 CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(temp_primaries, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE;  // Future Nuke versions make the inverse an inplace operator\n    CAT_CAT16 = CAT_CAT16.invert(); // So we copy it then invert, this extra assignment could be dropped in the future\n\n    // AP1 matrix\n    get_primaries(2, custom_primaries, temp_primaries);\n    float2 whitepoint = get_whitepoint(1, custom_white);\n    AP1_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_AP1 = AP1_to_XYZ;\n    XYZ_to_AP1 = XYZ_to_AP1.invert();\n\n    get_primaries(primariesLimit, custom_primaries, temp_primaries);\n    whitepoint = get_whitepoint(whiteLimit, custom_white);\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit;\n    XYZ_to_RGB_limit = XYZ_to_RGB_limit.invert();\n  \}\n\n  void init_chroma_compression(const float peakLuminance, const float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / peakLuminance;\n    chromaCompressScale = pow(0.03379f * peakLuminance, 0.30596f) - 0.45135f;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  float2 init_gamut_mapper(const float peakLuminance, const float log_peak, const float3 white)\n  \{\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(white * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = linear_RGB_to_JMh(float3(peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n    _base_slope = _limitJmax * _focusDist;\n\n    clamped_smoothness             = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?\n    const float2 smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n    return smooth_cusp_scale;\n  \}\n\n  inline float3 generate_unit_cube_corners(const int corner)\n  \{\n    // Generation order R, Y, G, C, B, M to ensure hues rotate in correct order\n    return float3(int(((corner+1)%cuspCornerCount) < 3), int(((corner+5)%cuspCornerCount) < 3), int(((corner+3)%cuspCornerCount) < 3));\n  \}\n\n  void build_cusp_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount], const int rgb_conditions, const float3x3& rgb_matrix, const float peakLuminance)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      temp_cusp_corners\[i] = vector_dot(rgb_matrix, peakLuminance * generate_unit_cube_corners(i));\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  void find_reach_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount],\n                                const int rgb_conditions, const float3x3& rgb_matrix, const float limitJ, const float maximum_source)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      const float3 xyz_vector = vector_dot(rgb_matrix, generate_unit_cube_corners(i));\n      float3 JMh = float3(0.0f);\n\n      float lower = 0.0f;\n      float upper = maximum_source;\n      while ((upper - lower) > 1e-3)\n      \{\n        float test = midpoint(lower, upper);\n        const float3 test_corner = test * xyz_vector;\n        JMh = XYZ_to_JMh(test_corner, rgb_conditions);\n        if (JMh.x < limitJ)\n        \{\n          lower = test;\n        \}\n        else\n        \{\n          upper = test;\n        \}\n        if (JMh.x == limitJ)\n          break;\n      \}\n      temp_cusp_corners\[i] = upper * xyz_vector;\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n \n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  int extract_sorted_cube_hues(float sorted_hues\[12], const float3 reach_JMh\[totalCornerCount], const float3 display_JMh\[totalCornerCount])\n  \{\n    // Basic merge of 2 sorted arrays, extracting the unique hues.\n    // Return the count of the unique hues\n    int idx = 0;\n    int reach_idx = 1;\n    int display_idx = 1;\n    while ((reach_idx < (cuspCornerCount + 1)) || (display_idx < (cuspCornerCount + 1)))\n    \{\n      const float reach_hue = reach_JMh\[reach_idx].z;\n      const float display_hue = display_JMh\[display_idx].z;\n      if (reach_hue == display_hue)\n      \{\n        sorted_hues\[idx] = reach_hue;\n        ++reach_idx;\n        ++display_idx; // When equal consume both\n      \}\n      else\n      \{\n        if (reach_hue < display_hue)\n        \{\n          sorted_hues\[idx] = reach_hue;\n          ++reach_idx;\n        \}\n        else\n        \{\n          sorted_hues\[idx] = display_hue;\n          ++display_idx;\n        \}\n      \}\n      ++idx;\n    \}\n    return idx;\n  \}\n\n  void build_hue_sample_interval(const int samples, const float lower, const float upper, float hueTable\[totalTableSize], const int base)\n  \{\n    const float delta = (upper - lower) / float(samples);\n    for (int i = 0; i != samples; ++i)\n    \{\n      hueTable\[base + i] = lower + float(i) * delta;\n    \}\n  \}\n\n  void build_hue_table(float hueTable\[totalTableSize], const float cube_hues\[2*cuspCornerCount], const int unique_hues)\n  \{\n    const float ideal_spacing = gamutCuspTableSize / hue_limit;\n    int samples_count\[2*cuspCornerCount+2];\n    int last_idx = -1;\n    int min_index = cube_hues\[0] == 0.0f ? 0 : 1; // Ensure we can always sample at 0.0 hue\n    for (int hue_idx = 0; hue_idx != unique_hues; ++hue_idx)\n    \{\n      // BUG: \"gamutCuspTableSize - 1\" will fail if we have multple hues mapping near the top of the table\n      int nominal_idx = clamp(int(round(cube_hues\[hue_idx] * ideal_spacing)), min_index, gamutCuspTableSize - 1);\n      if (last_idx == nominal_idx)\n      \{\n        // Last two hues should sample at same index, need to adjust them\n        // Adjust previous sample down if we can\n        if (hue_idx > 1 && samples_count\[hue_idx - 2] != (samples_count\[hue_idx - 1] - 1))\n        \{\n          samples_count\[hue_idx - 1] = samples_count\[hue_idx - 1] - 1;\n        \}\n        else\n        \{\n          nominal_idx = nominal_idx + 1;\n        \}\n      \}\n      samples_count\[hue_idx] = min(nominal_idx, gamutCuspTableSize - 1);\n      last_idx = min_index = nominal_idx;\n    \}\n\n    int total_samples = 0;\n    // Special cases for ends\n    int i = 0;\n    build_hue_sample_interval(samples_count\[i], 0.0f, cube_hues\[i], hueTable, total_samples+1);\n    total_samples += samples_count\[i];\n    for (++i; i != unique_hues; ++i)\n    \{\n      const int samples = samples_count\[i]-samples_count\[i-1];\n      build_hue_sample_interval(samples, cube_hues\[i-1], cube_hues\[i], hueTable, total_samples+1);\n      total_samples += samples;\n    \}\n    // BUG: could break if we are unlucky with samples all being used up by this point\n    build_hue_sample_interval(gamutCuspTableSize - total_samples, cube_hues\[i-1], hue_limit, hueTable, total_samples+1);\n\n    hueTable\[0] = hueTable\[totalTableSize - 2] - hue_limit;\n    hueTable\[totalTableSize - 1] = hueTable\[1] + hue_limit;\n  \}\n\n  float2 find_reach_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (reach_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (reach_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(reach_JMh_corners\[lower_corner].x, reach_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = reach_cusp_corners\[lower_corner];\n    const float3 cusp_upper = reach_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < reach_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > reach_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  float2 find_display_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (display_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (display_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(display_JMh_corners\[lower_corner].x, display_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = display_cusp_corners\[lower_corner];\n    const float3 cusp_upper = display_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < display_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > display_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  void initialise_cusp_table(float4 output_table\[totalTableSize], const float luminance, const int conditions)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    for (int i = 1; i != gamutCuspTableSize + 1; ++i)\n    \{\n      const float hue = hueTable\[i];\n      const float2 JM = find_display_cusp_for_hue(hue, conditions, hueFindingTollerance);\n      output_table\[i] = float4(JM.x, JM.y, hue, 0.0f);\n    \}\n\n    // Copy extra entries to ease the code to handle hues wrapping around\n    output_table\[0]                              = output_table\[baseIndex + gamutCuspTableSize - 1];\n    output_table\[baseIndex + gamutCuspTableSize] = output_table\[baseIndex];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    output_table\[0].z = output_table\[0].z - hue_limit;\n    output_table\[baseIndex + gamutCuspTableSize].z = output_table\[baseIndex + gamutCuspTableSize].z + hue_limit;\n  \}\n\n  void smooth_cusp_table(float4 table\[totalTableSize], const float2 scale)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      //table\[i].x      = table\[i].x * scale.x; // Not needed as the scale is unity\n      table\[i].y      = table\[i].y * scale.y;\n    \}\n  \}\n\n  void precompute_reach_table(float reachMTable\[totalTableSize], const float limitJ, const float3x3& xyz_matrix,\n                              const float3x3& rgb_matrix, const int conditions)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      reachMTable\[i] = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);\n    \}\n  \}\n\n  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)\n  \{\n    const float search_range = 100.0;\n    float low     = 0.0;\n    float high    = low + search_range;\n    bool  outside = false;\n\n    while (!outside && high < 1400.0)\n    \{\n      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));\n      if (!outside)\n      \{\n        low  = high;\n        high = high + search_range;\n      \}\n    \}\n\n    while ((high - low) > threshold)\n    \{\n      const float sampleM = midpoint(low, high);\n      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));\n      if (outside)\n      \{\n        high = sampleM;\n      \}\n      else\n      \{\n        low = sampleM;\n      \}\n    \}\n    return high;\n  \}\n\n  void fill_initial_hull_gammas(float4 table\[totalTableSize], float upperHullGamma, float lowerHullGamma)\n  \{\n    upperHullGamma = 1.0f / upperHullGamma;\n    lowerHullGamma = 1.0f / lowerHullGamma;\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      table\[i]\[UPPER_GAMMA] = upperHullGamma;\n      table\[i]\[LOWER_GAMMA] = lowerHullGamma;\n    \}\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||\n        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal);\n  \}\n\n  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,\n                               const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                               const float2 estimated_hull_gammas, const int conditions)\n  \{\n    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);\n    const float analytical_threshold = compute_analytical_threshold(JMcusp.x, limitJmax, focusGainBlend);\n    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);\n\n    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float approxLimit =\n        findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);\n    const float J_boundary       = slope * approxLimit + intersectJ;\n\n    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);\n    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);\n    return newLimitRGB;\n  \}\n\n  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float2 estimated_hull_gammas,\n                                     const float limitJmax, const float base_slope, const float midJ,\n                                     const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                                     const float luminance, const int conditions)\n  \{\n    for (int testIndex = 0; testIndex != test_count; ++testIndex)\n    \{\n      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh\[testIndex], limitJmax, base_slope,\n                                                       midJ, cuspMidBlend, focusAdjustGain, focusGainBlend, estimated_hull_gammas, conditions);\n\n      if (!outside_hull(newLimitRGB, luminance))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.5f, 0.8f, 0.99f\};\n    if (!disableUpperHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n        const float  hue                 = hueTable\[i];\n        const float4 cusp                = table\[i];\n        const float2 JMcusp              = float2(cusp.x, cusp.y);\n\n        float3 testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          // create test values between the cusp and the Jmax\n          testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(high, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(testGamma, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[UPPER_GAMMA] = testGamma;\n      \}\n    \}\n    // Wrap the end entries\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f);\n  \}\n\n  void initialise_lower_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.4f, 0.6f, 0.75f\};\n    const float fixed_gamma = 1.0f / lowerHullGamma;\n    if (!disableLowerHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        const float4 cusp   = table\[i];\n        const float2 JMcusp = float2(cusp.x, cusp.y);\n        const float  hue    = hueTable\[i];\n\n        float3       testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], high);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], testGamma);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[LOWER_GAMMA] = testGamma;\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  float replace_gamma_entry(float4 table\[totalTableSize], int entry, int channel)\n  \{\n    // Very simple patch up, try to find good values either side and lerp a new value\n    int lower = entry - 1;\n    while (lower >= 0)\n    \{\n      if (!bad_gamma_value(table\[lower]\[channel]))\n        break;\n      lower = lower - 1;\n    \}\n    if (lower < 0)\n      return -1.0f; // Give up if we can't find a good entry below\n\n    int upper = entry + 1;\n    while (upper < baseIndex + gamutCuspTableSize)\n    \{\n      if (!bad_gamma_value(table\[upper]\[channel]))\n        break;\n      upper = upper + 1;\n    \}\n    if (upper == totalTableSize)\n      return -2.0f; // Give up nothing above us\n\n    float lower_hue = hueTable\[lower];\n    float upper_hue = hueTable\[upper];\n    float entry_hue = hueTable\[entry];\n    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);\n    return lerp(table\[lower]\[channel], table\[upper]\[channel], lerp_loc);\n  \}\n\n  bool bad_gamma_value(const float value)\n  \{\n    return ((value <= 0.0f) || (value <= gammaMinimum+badGammaTollerance) || (value >= gammaMaximum-badGammaTollerance));\n  \}\n\n  void repair_broken_gamma_values(float4 table\[totalTableSize])\n  \{\n    for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n    \{\n      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)\n      \{\n        if (bad_gamma_value(table\[i]\[channel]))\n        \{\n          table\[i]\[channel] = replace_gamma_entry(table, i, channel);\n        \}\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  inline float3 extract_row(const float3x3 matrix, int row)\n  \{\n    return \{matrix\[row]\[0], matrix\[row]\[1], matrix\[row]\[2]\};\n  \}\n\n  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)\n  \{\n    return weight * extract_row(matrix, row);\n  \}\n\n  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)\n  \{\n    float3x3 matrix =\n    \{\n      a.x, a.y, a.z,\n      b.x, b.y, b.z,\n      c.x, c.y, c.z\n    \};\n    return matrix.invert();\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK,\n                          bool discountIlluminant, int stage, float3x3 CAT_CAT16, float3x3 panlrcm)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0.0f, 1.0f);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k    = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4   = k * k * k * k;\n    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);\n    F_L\[stage]       = _F_L / nl_normalise; //TODO white scale?\n\n    // # FWd Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    //float3 RGB = vector_dot(CAT_CAT16, XYZ);\n    //float3 RGB_c = D_RGB\[conditions] * RGB; // combine with CAT16\n\n    // Pre weight CAT16 matrix by D\n    DL_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].x, CAT_CAT16, 0);\n    DM_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].y, CAT_CAT16, 1);\n    DS_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].z, CAT_CAT16, 2);\n\n    // # Inv Step 6\n    //const float3 RGB = RGB_c / D_RGB\[conditions];\n    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n    const float3x3 tempmat = constuct_inverse_matrix(DL_weights\[stage], DM_weights\[stage], DS_weights\[stage]);\n    DL_weights_inv\[stage] = extract_row(tempmat, 0);\n    DM_weights_inv\[stage] = extract_row(tempmat, 1);\n    DS_weights_inv\[stage] = extract_row(tempmat, 2);\n\n    // Prescale values\n    surround\[stage].y = surround\[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n    surround\[stage].z = surround\[stage].z * 43.0f;\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L\[stage] * RGB_wc);\n    const float A_w     = dot(achromatic_w, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    y_to_j_A_w\[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);\n\n    F_L\[stage] *= _XYZ_w_scaler; // Allows tonescale multiplier to be removed\n\n    achromatic_weights\[stage] = achromatic_w / A_w;\n    a_weights\[stage]          = surround\[stage].z * a_w;\n    b_weights\[stage]          = surround\[stage].z * b_w;\n\n    const float3 column_weights = float3(A_w, 1.0f / surround\[stage].z, 1.0f / surround\[stage].z);\n    achromatic_weights_inv\[stage]   = extract_row(panlrcm, 0) * column_weights;\n    a_weights_inv\[stage]            = extract_row(panlrcm, 1) * column_weights;\n    b_weights_inv\[stage]            = extract_row(panlrcm, 2) * column_weights;\n  \}\n\n  void init()\n  \{\n    const float log_peak = init_tonescale_constants(_peakLuminance);\n\n    float3x3 CAT_CAT16;\n\n    init_matrices(CAT_CAT16);\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    const float3 inputWhite = vector_dot(AP1_to_XYZ, white);\n    const float3 limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n    const float3x3 panlrcm = generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS, CAT_CAT16, panlrcm);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS, CAT_CAT16, panlrcm);\n\n    init_chroma_compression(_peakLuminance, log_peak);\n    const float2 smooth_cusp_scale = init_gamut_mapper(_peakLuminance, log_peak, limitWhite);\n\n    // Fist find the unique hues for the cusp corners, then fill in the table uniformly between those hues\n    find_reach_corners_tables(reach_cusp_corners, reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _limitJmax, input_upper_clamp);\n    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);\n    unique_hues = extract_sorted_cube_hues(cube_hues, reach_JMh_corners, display_JMh_corners);\n    build_hue_table(hueTable, cube_hues, unique_hues);\n\n    initialise_cusp_table(limitingGamutCuspTable, _peakLuminance, DISPLAY_CONDITIONS);\n    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);\n    fill_initial_hull_gammas(limitingGamutCuspTable, upperHullGamma, lowerHullGamma);\n    // Iterate gamma finding based on previous values\n    for (int i = 0; i != 3; ++i)\n    \{\n      initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n      initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n    \}\n    repair_broken_gamma_values(limitingGamutCuspTable);\n\n    precompute_reach_table(reachMTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS);\n  \}\n\n#ifdef USE_DEGREES\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float to_radians(float hue)\n  \{\n    return hue / 180.0f * PI;\n  \}\n#endif\n\n  inline float wrap_hue(float hue)\n  \{\n    float y = fmod(hue, hue_limit);\n    if (y < 0.0)\n    \{\n      y = y + hue_limit;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB        = clamp(RGB, float3\{0.0f\}, float3(input_upper_clamp));\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_forward(float L)\n  \{\n    const float F_L_L = pow(L, float(nl_gamma));\n    return F_L_L / (nl_offset + F_L_L);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));\n    return F_L_RGB / (nl_offset + F_L_RGB);\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_inverse(float A)\n  \{\n    const float F_L_A = (nl_offset * A) / (1.0f - A);\n    return pow(F_L_A, 1.0f / nl_gamma);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 F_L_RGB = (nl_offset * RGB) / (1.0f - RGB);\n    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);\n    return RGB_c;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);\n    return RGB_p;\n  \}\n\n//  // Return compression gamut cusp M scaled with an eccentricity factor\n//  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n//  \{\n//    if (!apply_eccentricity)\n//    \{\n//        return 1.0f;\n//    \}\n//\n//    // Hellwig2022/Helles2023\n//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n//    const float _2_hr = 2 * hr;\n//    const float _3_hr = 3 * hr;\n//    const float _4_hr = 4 * hr;\n//    // clang-format off\n//    return (\n//        - 0.0582f * cos(_1_hr)\n//        - 0.0258f * cos(_2_hr)\n//        - 0.1347f * cos(_3_hr)\n//        + 0.0289f * cos(_4_hr)\n//        - 0.1475f * sin(_1_hr)\n//        - 0.0308f * sin(_2_hr)\n//        + 0.0385f * sin(_3_hr)\n//        + 0.0096f * sin(_4_hr)\n//        + 1.0f\n//      );\n//    // clang-format on\n//  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float _J_from_Achromatic(float A, int conditions)\n  \{\n    return j_scale * pow(A, surround\[conditions].y);\n  \}\n\n  inline float _Achromatic_from_J(float J, int conditions)\n  \{\n    return pow(J / j_scale, 1.0f / surround\[conditions].y);\n  \}\n\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * _J_from_Achromatic(fabs(A), conditions);\n  \}\n\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * _Achromatic_from_J(fabs(J), conditions);\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    float3 RGB_c;\n    RGB_c.x = dot(DL_weights\[conditions], XYZ);\n    RGB_c.y = dot(DM_weights\[conditions], XYZ);\n    RGB_c.z = dot(DS_weights\[conditions], XYZ);\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);\n\n    const float A = dot(achromatic_weights\[conditions], RGB_a);\n    const float a = dot(a_weights\[conditions], RGB_a);\n    const float b = dot(b_weights\[conditions], RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n#ifdef USE_DEGREES\n    const float h  = wrap_hue(degrees(hr));\n#else\n    const float h  = wrap_hue(hr);\n#endif\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    //const float et = eccentricity_factor(hr, false);\n    //float       M  = surround\[conditions].z * et * sqrt(a * a + b * b);\n    float M = sqrt(a * a + b * b); // Valid as et == 1.0\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n#ifdef USE_DEGREES\n    const float hr = to_radians(JMh.z);\n#else\n    const float hr = JMh.z;\n#endif\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float _A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    //const float et    = eccentricity_factor(hr, false);\n    //const float P_p_1 = surround\[conditions].z; // * et;\n    //const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 Aab = float3(_A, a, b);\n    //const float3 RGB_a = vector_dot(panlrcm, Aab);\n    float3 RGB_a;\n    RGB_a.x = dot(achromatic_weights_inv\[conditions], Aab);\n    RGB_a.y = dot(a_weights_inv\[conditions], Aab);\n    RGB_a.z = dot(b_weights_inv\[conditions], Aab);\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);\n\n    float3 XYZ;\n    XYZ.x = dot(DL_weights_inv\[conditions], RGB_c);\n    XYZ.y = dot(DM_weights_inv\[conditions], RGB_c);\n    XYZ.z = dot(DS_weights_inv\[conditions], RGB_c);\n\n    return XYZ;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / hue_limit * table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b (cubic polynomial)\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline float smin_s(float a, float b, float s, float normalise)\n  \{\n    const float s_scaled     = s * normalise;\n    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;\n    const float h            = max(scaled_delta, 0.0f);\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  inline float midpoint(float low, float high)\n  \{\n    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document\n    return (high + low) * 0.5f;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  int lookupLimitingCuspHue(float wrapped_hue)\n  \{\n    // samples are almost uniform should be able to find the correct entry +/- 6 entries from middle\n    // on average it is actually in a narrow range than this, left as an exersize for the reader to\n    // improve this, typically lies in upper half\n    // either way log2(search_range*2) is way smaller than log2(gamutCuspTableSize)\n    // BUG: needs checking if this range is too small should all the hues cluster together due to a\n    // pathelogical triangle formed by two primaries from one gamut closely bracketing one from the other\n#define search_range 2\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n    int low_i  = max(0, i - search_range);\n    int high_i = min(baseIndex + gamutCuspTableSize, i + search_range); // Allowed as we have extra entries in the table\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > hueTable\[i])\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float limiting_lerp_fraction(float wrapped_hue, int pos)\n  \{\n    return (wrapped_hue - hueTable\[pos - 1])\n          / (hueTable\[pos] - hueTable\[pos - 1]);\n  \}\n\n  inline float4 limitingCuspFromTable(int pos, float t)\n  \{\n    return lerp(limitingGamutCuspTable\[pos - 1], limitingGamutCuspTable\[pos], t);\n  \}\n\n  inline float reachMFromTable(int pos, float t)\n  \{\n    return lerp(reachMTable\[pos - 1], reachMTable\[pos], t);\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)\n  \{\n    // Assume J (0.0, limitJmax)\n    \n    if (J <= analytical_threshold)\n      return 1.0f; // makes the analytic inverse possible below cusp\n\n    // Approximate inverse required above threshold TODO: explain why\n    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n  \}\n\n  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,\n                                  const float focusAdjustGain, const float analytical_threshold)\n  \{\n    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)\n  \{\n    float direction_scaler;\n    if (intersectJ <= focusJ)\n    \{\n      direction_scaler = intersectJ;\n    \}\n    else\n    \{\n       direction_scaler = (limitJmax - intersectJ);\n    \}\n\n    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);\n  \}\n\n  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,\n                                                         const float inv_gamma, const float J_max, const float M_max,\n                                                         const float J_intersection_reference)\n  \{\n    // Line defined by     J = slope * x + J_axis_intersect\n    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)\n    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential\n    \n    // We calculate a shifted intersection from the original intersection using the inverse of the exponential\n    // and the provided reference\n    const float normalised_J        = J_axis_intersect / J_intersection_reference;\n    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);\n\n    // Now we find the M intersection of two lines\n    // line from origin to J,M Max       l1(x) = J/M * x\n    // line from J Intersect' with slope l2(x) = slope * x + Intersect'\n\n    return shifted_intersecion / ((J_max / M_max) - slope);\n    //return shifted_intersecion * M_max / (J_max - slope * M_max);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,\n                                       float2 estimated_hull_gammas, const float slope)\n  \{\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);\n\n    // The upper hull is flipped and thus 'zerod' at J_max\n    // Also note we negate the slope\n    const float f_J_intersect_cusp = J_max - J_intersect_cusp;\n    const float f_J_intersect_source = J_max - J_intersect_source;\n    const float f_JM_cusp_J = J_max - JM_cusp.x;\n    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);\n\n    // Smooth minimum between the two calculated values for the M component\n    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n    return M_boundary;\n    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);\n  \}\n\n  inline float reinhard_compress(const float scale, const float factor, const bool direction)\n  \{\n    if (INVERSE == direction)\n    \{\n      if (factor >= 1.0f)\n        return scale;\n      else\n        return scale * (-(factor / (factor - 1.0f)));\n    \}\n    return scale * (factor) / (1.0f + factor);\n  \}\n\n  inline float gamut_mapped_location(const float location, const float gamutBoundary, const float reachBoundary, const bool direction)\n  \{\n    // Assumes _compressionFuncParams in (0.0, 1.0)\n    const float threshold = clamp(gamutBoundary / reachBoundary, _compressionFuncParams, 0.99999f) * gamutBoundary;\n\n    // Values upto the threshold or when both boundaries are the same remain as is\n    if (location <= threshold || gamutBoundary == reachBoundary)\n      return location;\n\n    // Translate to place threshold at zero\n    const float location_offset = location - threshold;\n    const float boundary_offset = gamutBoundary - threshold;\n    const float reach_offset    = reachBoundary - threshold;\n\n    // Assumes boundary != reach\n    // Generaly speaking boundary should be < reach\n    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);\n    const float factor = location_offset / scale;\n\n    const float relative_location = reinhard_compress(scale, factor, direction);\n\n    return (threshold + relative_location); // shift back to absolute\n  \}\n\n  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,\n                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,\n                    float reachMaxM, float model_gamma)\n  \{\n    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float ganutBoundaryM   = findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,\n                                                                  smoothness, estimated_hull_gammas, slope);\n\n    if (ganutBoundaryM <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)\n    \{\n      return float2(JM.x, 0.0f);\n    \}\n\n    // Compress the out of gamut color along the projection line\n    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);\n    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);\n    const float mappedJ  = slope * mappedM + intersectJ;\n\n    return float2\{mappedJ, mappedM\};\n  \}\n\n  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));\n  \}\n\n  inline float compute_analytical_threshold(const float cuspJ, const float limitJmax, const float focusGainBlend)\n  \{\n    return lerp(cuspJ, limitJmax, focusGainBlend);\n  \}\n\n  float3 gamutMapper(float3 JMh, const float4 cusp, const float reachM, bool direction)\n  \{\n    // Limit to +ve values // TODO test this is neededS\n    if (JMh.x <= 0.0f)\n    \{\n      JMh.x = 0.0f;\n      JMh.y = 0.0f;\n    \}\n    // Above the expected maximum we explicitly map to 0 M\n    if (JMh.x >= _limitJmax)\n    \{\n      JMh.y = 0.0f;\n    \}\n\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f)\n      return JMh;\n\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n    const float2 JMcusp                = float2(cusp.x, cusp.y);\n    const float2 estimated_hull_gammas = float2\{cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA]\};\n    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x, _limitJmax, _focusGainBlend); \n    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);\n\n    float  Jx         = JMh.x;\n    float2 JM         = float2\{JMh.x, JMh.y\};\n    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);\n \n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > analytical_threshold)\n      \{\n        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                        clamped_smoothness, reachM, _model_gamma).x;\n        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);\n      \}\n    \}\n    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                    clamped_smoothness, reachM, _model_gamma);\n\n    return \{JM.x, JM.y, JMh.z\};\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, conditions);\n    return JMh;\n  \}\n\n  float3 JMh_to_linear_RGB(const float3 JMh, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, conditions);\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  float init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions\n\n    const float aces_ts_n      = peakLuminance;\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_m_0) / log(10000.0f / 100.0f));\n    input_upper_clamp = aces_ts_r_hit * 8.0f * _XYZ_w_scaler;  // limit to nice power of 2 (3 stops) above that needed to max out // TODO magic 8 ball factor needs assessing\n\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    const float aces_ts_u      = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    const float aces_ts_m      = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1);\n    const float aces_ts_u_2    = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?\n    return log10(aces_ts_m_0);\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(const float Y)\n  \{\n    // Assumes Y is >= +0.0\n    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);\n    return max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility\n  \}\n\n  inline float aces_ts_rev(const float Y)\n  \{\n    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?\n    const float f = (Y + sqrt(Y * (4.0f * aces_ts_t_1 + Y))) / 2.0f;\n    return aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float _Y_to_Hellwig_J(float Y, int conditions)\n  \{\n    // Assumes Y is >= +0.0\n    const float A = _post_adaptation_non_linear_response_compression_forward(F_L\[conditions] * Y) / y_to_j_A_w\[conditions];\n    return _J_from_Achromatic(A, conditions);\n  \}\n\n  inline float _Hellwig_J_to_Y(float J, int conditions)\n  \{\n    // Assumes J is >= +0.0\n    const float A = y_to_j_A_w\[conditions] * _Achromatic_from_J(J, conditions);\n    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L\[conditions];\n  \}\n\n//  inline float Y_to_Hellwig_J(float Y, int conditions)\n//  \{\n//    const float absY = fabs(Y);\n//    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?\n//  \}\n//\n//  inline float Hellwig_J_to_Y(float J, int conditions)\n//  \{\n//    const float absJ = fabs(J);\n//    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?\n//  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions)\n  \{\n    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below\n    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);\n    const float  luminanceTS   = aces_ts_fwd(inputY);\n    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);\n    return float3(tonemappedJ, inputJMh.y, inputJMh.z);\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);\n    const float  linear          = aces_ts_rev(luminance);\n    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);\n    return float3(untonemappedJ, JMh.y, JMh.z);\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, bool inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2             = max(k2, 0.001f); // TODO; magic constant\n    k1             = sqrt(k1 * k1 + k2 * k2);\n    const float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n    \{\n      const float minus_b = k3 * x - k1;\n      const float minus_c = k2 * k3 * x;\n      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2\n    \}\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompressionNorm(float h)\n  \{\n#ifdef USE_DEGREES\n    const float hr = to_radians(h);\n#else\n    const float hr = h;\n#endif\n    float a = cos(hr);\n    float b = sin(hr);\n    float cos_hr2 = a * a - b * b;\n    float sin_hr2 = 2.0f * a * b;\n    float cos_hr3 = 4.0f * a * a * a - 3.0f * a;\n    float sin_hr3 = 3.0f * b - 4.0f * b * b * b;\n\n    float M = 11.34072f * a +\n              16.46899f * cos_hr2 +\n               7.88380f * cos_hr3 +\n              14.66441f * b +\n              -6.37224f * sin_hr2 +\n               9.19364f * sin_hr3 +\n              77.12896f;\n\n    return M * chromaCompressScale;\n  \}\n\n  inline float chromaCompression(float3 JMh, const float origJ, const float reachMMax, const bool inverse,\n                                 const float limitJmax, const float model_gamma,\n                                 const float sat, const float sat_thr, const float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    const float nJ                   = JMh.x / limitJmax;\n    const float snJ                  = max(0.0f, 1.0f - nJ);\n\n    const float normalisation_factor = chromaCompressionNorm(JMh.z); // reachCuspM; // pow(nJ, model_gamma) * reachMMax; //\n    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor; // 1.0f; //\n\n    const float toe_limit           = limit - 0.001f;  // TODO; magic constantl\n    const float toe_snJ_sat         = snJ * sat;\n    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);\n    const float toe_nJ_compr        = nJ * compr;\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= normalisation_factor;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);\n\n      // Denormalize\n      M *= normalisation_factor;\n    \}\n    else\n    \{\n      M /= normalisation_factor;\n      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);\n      M *= normalisation_factor;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 compressChroma(float3 JMh, const float originalJ, const float reachM, const bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, reachM, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse)\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);\n        const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);\n        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);\n        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped      = clamp_to_AP1(src);\n        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(JMh.z);\n        const float  t      = limiting_lerp_fraction(JMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);\n        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);\n        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);\n        output              = compressChroma(src, JMh.x, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        const int    pos  = lookupLimitingCuspHue(src.z);\n        const float  t    = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);\n        output            = compressChroma(src, JMh.x, reachM, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA], t);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const int   pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float reachM      = reachMFromTable(pos, t);\n        output = float3(chromaCompressionNorm(src.z), reachM, wrapped_hue);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.z);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.w);\n    \}\n    else if (DEBUG_reachMTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float reachM = reachMTable\[index];\n        output = float3(reachM, src.z, index);\n    \}\n    \n    else if (DEBUG_Jconstants == diagnosticMode)\n    \{\n        output = float3(_midJ, _limitJmax, _focusDist);\n    \}\n    else if (DEBUG_FocusConstants == diagnosticMode)\n    \{\n        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);\n    \}\n    else if (DEBUG_reachMConditions == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);\n        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);\n\n        output = float3(sM, dM, wrapped_hue); \n    \}\n    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (100 == diagnosticMode)\n    \{\n        const float sm  = src.z * smin(src.x / src.z, src.y / src.z, clamped_smoothness);\n        const float sms = smin_s(src.x, src.y, clamped_smoothness, src.z);\n        output = float3(sm, sms, src.z); \n    \}\n    else if (102 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const float2 found       = find_reach_cusp_for_hue(wrapped_hue, SOURCE_CONDITIONS, hueFindingTollerance);\n        const float  norm        = chromaCompressionNorm(wrapped_hue);\n        output = float3(found.x, found.y, norm);\n    \}\n    else if (103 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_JMh_corners\[index];\n    \}\n    else if (104 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_cusp_corners\[index];\n    \}\n    else if (105 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = display_JMh_corners\[index];\n    \}\n    else if (106 == diagnosticMode)\n    \{\n        output = float3(input_upper_clamp / _XYZ_w_scaler);\n    \}\n    else if (107 == diagnosticMode)\n    \{\n        const int index = int(src.z) % (2 * cuspCornerCount);\n        output = float3(cube_hues\[index], index, unique_hues);\n    \}\n    else if (108 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const int    i           = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n        output = float3(float(pos), pos + t, float(i));\n    \}\n    else if (109 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float hue = hueTable\[index];\n        output = float3(float(index), hue, hue);\n    \}\n    else if (110 == diagnosticMode)\n    \{\n        const float wrapped_hue  = wrap_hue(src.z);\n        const int   pos          = lookupLimitingCuspHue(wrapped_hue);\n        const float t            = limiting_lerp_fraction(wrapped_hue, pos);\n        const float computed_hue = lerp(hueTable\[pos - 1], hueTable\[pos], t);\n        output = float3(computed_hue, wrapped_hue, src.z);\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_AP1 Clamp" false
  "ACES_DRT_Kernel_Limiting primaries" {{parent.limiting_primaries}}
  "ACES_DRT_Kernel_Limiting Whitepoint" {{parent.limiting_whitepoint}}
  "ACES_DRT_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Kernel_Custom White" {0.3127000034 0.3289999962}
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 130
  ypos -110
 }
 Output {
  name Output1
  xpos 130
  ypos -10
 }
end_group
Group {
 name ACESDRT_EncodingLimiter2
 xpos -91
 ypos -129
 addUserKnob {20 User}
 addUserKnob {26 _1 l "Limiting Gamut"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Limiting Peak Luminance" l "Limiting Peak Luminance" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Limiting Peak Luminance"}
 addUserKnob {4 limiting_whitepoint l Whitepoint M {"Illuminant E" ACES D65 DCI Custom ""}}
 limiting_whitepoint D65
 addUserKnob {4 limiting_primaries l "" t "the limiting primaries of the gamut to which to compress to" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom ""}}
 limiting_primaries "Rec.709  (sRGB)"
 addUserKnob {20 Custom l "Custom Gamut" n 1}
 Custom 0
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Red" l "Custom Red" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Red"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Green" l "Custom Green" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Green"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Blue" l "Custom Blue" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Blue"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom White" l "Custom White" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom White"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 _2 l Encoding}
 addUserKnob {4 encoding_whitepoint l Whitepoint -STARTLINE M {"Illuminant E" ACES D65 DCI Custom ""}}
 encoding_whitepoint D65
 addUserKnob {4 encoding_primaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" "" "" ""}}
 encoding_primaries "Rec.709  (sRGB)"
 addUserKnob {26 ""}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Clamp to limiting space" l "Clamp to limiting space" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Clamp to limiting space"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_White point scale" l "White point scale" T "BlinkScript1.ACES_DRT_Encoding_Kernel_White point scale"}
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos 130
  ypos -203
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 7
  ypos -187
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 130
  ypos -163
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_limiter.blink
  recompileCount 224
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise 7487a34904160a1d2d4333cb1ceb64e5312c7856e9e5e054a0b0edbe91fa1f78 2 \"src\" Read Point \"dst\" Write Point 12 \"Direction\" Bool 1 AA== \"Limiting Primaries\" Int 1 AwAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Limiting Whitepoint\" Int 1 AgAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Limiting Peak Luminance\" Float 1 AADIQg== \"Clamp to limiting space\" Bool 1 AQ== \"White point scale\" Bool 1 AQ== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 12 \"invert\" 1 1 \"limitingPrimaries\" 1 1 \"encodingPrimaries\" 1 1 \"limitingWhite\" 1 1 \"encodingWhite\" 1 1 \"limitingLuminance\" 1 1 \"limitClamp\" 1 1 \"whitepoint_scale\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 5 \"XYZ_to_limiting_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"limiting_RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"white_scaling_factor\" Float 1 1 AAAAAA== \"white_scaled\" Bool 1 1 AA== \"has_effect\" Bool 1 1 AA=="
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int limitingPrimaries;\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int limitingWhite;\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float limitingLuminance;\n\n  bool limitClamp;\n  bool whitepoint_scale;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  float3x3 XYZ_to_limiting_RGB;\n  float3x3 limiting_RGB_to_XYZ;\n\n  float white_scaling_factor;\n  bool white_scaled;\n  bool has_effect;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(limitingLuminance, \"Limiting Peak Luminance\", 100.0f);\n    defineParam(limitingPrimaries, \"Limiting Primaries\", 3);\n    defineParam(limitingWhite, \"Limiting Whitepoint\", 2);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(limitClamp, \"Clamp to limiting space\", true);\n    defineParam(whitepoint_scale, \"White point scale\", true);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n \}\n\n  void init()\n  \{\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(limitingPrimaries, custom_primaries, temp_primaries);\n    const float2 limiting_whitepoint = get_whitepoint(limitingWhite, custom_white);\n    limiting_RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_limiting_RGB = limiting_RGB_to_XYZ.invert();\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2   encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    const float3x3 XYZ_to_encoding_RGB = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, INVERSE);\n\n    // Scale to fit maximum creative white channel value\n    const float3 creativeWhiteXYZ = vector_dot(limiting_RGB_to_XYZ, float3(1.0f));\n    const float3 creativeWhiteRGB = vector_dot(XYZ_to_encoding_RGB, creativeWhiteXYZ);\n    const float  max_channel      = max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    white_scaling_factor          = (whitepoint_scale) ? 1.0f / max_channel : 1.0f; // TODO: add scaling into reencoding matrix?\n    white_scaled                  = (white_scaling_factor != 1.0f);\n\n    has_effect = white_scaled;\n    if (!invert)\n    \{\n      has_effect |= limitClamp;\n    \}\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  inline float3 xyz_to_limiting(const float3 XYZ)\n  \{\n    return vector_dot(XYZ_to_limiting_RGB, XYZ);\n  \}\n\n  inline float3 limiting_to_xyz(const float3 RGB)\n  \{\n    return vector_dot(limiting_RGB_to_XYZ, RGB);\n  \}\n\n  inline float3 apply_limiting_clamp(float3 RGB)\n  \{\n    if (limitClamp)\n    \{\n      RGB = clamp(RGB, float3\{0.0f\}, float3\{limitingLuminance\});\n    \}\n    return RGB;\n  \}\n\n  inline float3 apply_whitepoint_scale(float3 RGB)\n  \{\n    if (white_scaled)\n    \{\n      RGB *= white_scaling_factor;\n    \}\n    return RGB;\n  \}\n\n  inline float3 remove_whitepoint_scale(float3 RGB)\n  \{\n    RGB /= white_scaling_factor;\n    return RGB;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 out(source.x, source.y, source.z);\n\n    if (has_effect)\n    \{\n      if (invert)\n      \{\n        out = xyz_to_limiting(out);\n        out = remove_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n      else\n      \{\n        out = xyz_to_limiting(out);\n        out = apply_limiting_clamp(out);\n        out = apply_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n    \}\n\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Encoding_Kernel_Limiting Primaries" {{parent.limiting_primaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.encoding_primaries}}
  "ACES_DRT_Encoding_Kernel_Limiting Whitepoint" {{parent.limiting_whitepoint}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.encoding_whitepoint}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Encoding_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Encoding_Kernel_Custom White" {0.3127000034 0.3289999962}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 130
  ypos -110
 }
 Output {
  name Output1
  xpos 130
  ypos -10
 }
end_group
Group {
 name ACES_DRT_Encoding1
 xpos -91
 ypos -105
 addUserKnob {20 User}
 addUserKnob {4 Direction M {Decode Encode}}
 Direction Encode
 addUserKnob {26 gamut l Gamut}
 addUserKnob {4 whitepoint l Whitepoint M {"Illuminant E" ACES D65 DCI Custom ""}}
 whitepoint D65
 addUserKnob {4 primaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" ""}}
 primaries "Rec.709  (sRGB)"
 addUserKnob {20 Custom n 1}
 Custom 0
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Red" l "Custom Red" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Red"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Green" l "Custom Green" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Green"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Blue" l "Custom Blue" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Blue"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom White" l "Custom White" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom White"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {7 referenceLuminance l "Reference Luminance" R 0 200}
 referenceLuminance 100
 addUserKnob {4 encoding l Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
 encoding "BT.1886 (Gamma 2.4)"
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 7
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction {{parent.Direction}}
  ACES_DRT_Encoding_Kernel_Encoding {{parent.encoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.primaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.whitepoint}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Encoding_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Encoding_Kernel_Custom White" {0.3127000034 0.3289999962}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 228
  ypos 74
 }
 Output {
  name Output1
  xpos 228
  ypos 149
 }
end_group
Viewer {
 inputs 3
 frame 1
 frame_range 1-100
 input_number 2
 viewerProcess None
 monitorOutOutputTransform rec709
 name Viewer1
 xpos 133
 ypos -64
}
