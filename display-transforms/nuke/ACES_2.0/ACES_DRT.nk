set cut_paste_input [stack 0]
version 14.1 v3
push $cut_paste_input
Group {
 name ACESDRT
 selected true
 xpos 120
 ypos -111
 addUserKnob {20 User}
 addUserKnob {41 ACES_DRT_Kernel_Invert l Invert T BlinkScript1.ACES_DRT_Kernel_Invert}
 addUserKnob {41 "ACES_DRT_Kernel_Peak Luminance" l "Peak Luminance" T "BlinkScript1.ACES_DRT_Kernel_Peak Luminance"}
 addUserKnob {4 limiting_whitepoint l "White Point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." M {"ACES White" D65 ""}}
 limiting_whitepoint D65
 addUserKnob {4 limiting_primaries l Primaries t "the limiting primaries of the gamut to which to compress to" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 ""}}
 limiting_primaries sRGB/Rec.709
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
 addUserKnob {41 "ACES_DRT_Kernel_Disagnostics Mode" l "Disagnostics Mode" T "BlinkScript1.ACES_DRT_Kernel_Disagnostics Mode"}
}
 Input {
  inputs 0
  name Input1
  xpos 130
  ypos -203
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 7
  ypos -187
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 130
  ypos -163
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 205
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Kernel\" iterate pixelWise c035a1ca1ba26f4b2e386c0708b90647980fc7438695c3dd51523083c20aafbe 2 \"src\" Read Point \"dst\" Write Point 43 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting  Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting  Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 4 AABAP83MjD9mZqY/AACAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 43 \"invert\" 1 1 Default \"AP1Clamp\" 1 1 Default \"_peakLuminance\" 1 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"_inputViewingConditions\" 1 1 Default \"L_A_in\" 1 1 Default \"Y_b_in\" 1 1 Default \"_outputViewingConditions\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default \"_userSurround\" 3 1 Default \"_XYZ_w_scaler\" 1 1 Default \"diagnosticMode\" 1 1 Default \"_smoothCusps\" 1 1 Default \"_smoothOffset\" 2 1 Default \"_cuspMidBlend\" 1 1 Default \"_focusGainBlend\" 1 1 Default \"_focusAdjustGain\" 1 1 Default \"_focusDistance\" 1 1 Default \"_focusDistanceScaling\" 1 1 Default \"_compressionFuncParams\" 4 1 Default \"LMS_rxy\" 2 1 Default \"LMS_gxy\" 2 1 Default \"LMS_bxy\" 2 1 Default \"LMS_wxy\" 2 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"aces_ts_n_r\" 1 1 Default \"aces_ts_g\" 1 1 Default \"aces_ts_c\" 1 1 Default \"aces_ts_c_d\" 1 1 Default \"aces_ts_w_g\" 1 1 Default \"aces_ts_t_1\" 1 1 Default \"aces_ts_r_hit_min\" 1 1 Default \"aces_ts_r_hit_max\" 1 1 Default 41 \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"achromatic_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"z\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"A_w\" Float 1 2 AAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"chromatic_adapt_scale\" Float 1 2 AAAAAAAAAAA= \"limitingGamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"limitingGamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachGamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"inputWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"smooth_cusp_scale\" Float 2 1 AAAAAAAAAAA= \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"aces_ts_n\" Float 1 1 AAAAAA== \"aces_ts_u\" Float 1 1 AAAAAA== \"aces_ts_m\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_u_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"referenceLuminance\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_cgamutCuspTable 51\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3x3 identity_matrix;\n\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n\n  float3 achromatic_weights;\n  float3 a_weights;\n  float3 b_weights;\n\n  float3x3 panlrcm;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n#define nl_d_scale   nl_gamma * nl_scale * nl_offset\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float  z\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  A_w\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n  float  chromatic_adapt_scale\[NUMBER_CONDITIONS];\n\n#define gamutCuspTableSize 360\n\n  // Adds an extra entry to wrap the hues without branching\n  // Non-uniform in h\n  float3 limitingGamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n\n  // Uniform\n  float2 limitingGamutGammas\[gamutCuspTableSize + 1];\n  float3 reachGamutCuspTable\[gamutCuspTableSize + 1];\n\n  float3 inputWhite;\n  float3 limitWhite;\n\n  float  clamped_smoothness;\n  float2 smooth_cusp_scale;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma; // TODO: investigate uses of this\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n\n  float aces_ts_n;         // peak white\n  float aces_ts_u;\n  float aces_ts_m;\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_u_2;\n  float aces_ts_m_2;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance; // TODO: reference only for tonescale curve\n                            // can it be factored in or removed (is it duplicated)\n \n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting  Luminance\", 100.0f);\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f);\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting  Luminance\", 100.0f);\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f);\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9, 0.59, 0.9));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", float4(0.75f, 1.1f, 1.3f, 1.0f)); // TODO: do we use all of them?\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(0.3333333333333f,  0.3333333333333f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (PRIMARIES_AP0 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_AP1 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_Rec709 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, FORWARDS);\n    \}\n    else if (PRIMARIES_Rec2020 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3D65 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3DCI == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, FORWARDS);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_weights = float3(ra, 1.0f, ba);\n    a_weights          = float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_weights          = float3(1.0f, 1.0f, -2.0f) / 9.0f;\n    // clang-format off\n    float panlrcm_data\[]=\n    \{\n      achromatic_weights.x, achromatic_weights.y, achromatic_weights.z,\n      a_weights.x, a_weights.y, a_weights.z, \n      b_weights.x, b_weights.y, b_weights.z,\n    \};\n    // clang-format on\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = (460.0f / panlrcm\[i]\[0]) / 1403.0f;\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  float2 get_whitepoint(int which)\n  \{\n    if (which == 0)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which == 1)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n\n    return  float2(0.333333f, 0.333333f);\n  \}\n\n  void init_matrices()\n  \{\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(PRIMARIES_AP1);\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix = get_whitepoint(whiteLimit);\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001f, -0.077f);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    inputWhite = vector_dot(AP1_to_XYZ, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n  \}\n\n  void init_chroma_compression(float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / aces_ts_n;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  void init_gamut_mapper(float log_peak)\n  \{\n    clamped_smoothness  = max(0.000001f, _smoothCusps);\n    smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(limitWhite * aces_ts_c_t * aces_ts_n, DISPLAY_CONDITIONS).x;\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = display_linear_RGB_to_JMh(float3(_peakLuminance), RGB_to_XYZ_limit).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  void initialise_cusp_table(float3 * output_table, const int table_size, const float3x3& matrix, const float luminance)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f)) * float3(luminance);\n      tempTableUnsorted\[i] = display_linear_RGB_to_JMh(RGB, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 * tableUnsorted, const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 * output_table, const int table_size, const float limitJ, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_display_linear_RGB(float3(limitJ, high, hue), matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_display_linear_RGB(float3(limitJ, sampleM, hue), matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma,\n                                     const float midJ, const float cuspMidBlend, const float limitJmax,\n                                     const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    const float2 estimated_hull_gammas = float2(1.0f / topGamma, 1.0f / lowerHullGamma);\n    const float  focusJ                = compute_focusJ(JMcusp, midJ, cuspMidBlend, limitJmax);\n\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain = compute_slope_gain(testJmh\[testIndex].x, JMcusp.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_display_linear_RGB(approximate_JMh, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    const float fixed_gamma = 1.0f / upperHullGamma;\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        limitingGamutGammas\[i].x = fixed_gamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      limitingGamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = limitingCuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high,\n                                                    midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma,\n                                                   midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      limitingGamutGammas\[i].x = 1.0f / testGamma;\n    \}\n    // Wrap the last entry\n    limitingGamutGammas\[gamutCuspTableSize] = limitingGamutGammas\[0];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma,\n                                     const float midJ, const float cuspMidBlend, const float limitJmax,\n                                     const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, 1.0f / bottomGamma);\n    const float  focusJ                = lerp(JMcusp.x, midJ, cuspMidBlend); // TODO: different\n\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain = compute_slope_gain(testJmh\[testIndex].x, JMcusp.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_display_linear_RGB(approximate_JMh, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma(const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n    const float fixed_gamma = 1.0f / lowerHullGamma;\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        limitingGamutGammas\[i].y = fixed_gamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      limitingGamutGammas\[i].y    = -5.0f;\n      const float2 JMcusp = limitingCuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high,\n                                                   midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma,\n                                                   midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      limitingGamutGammas\[i].y = 1.0f / testGamma;\n    \}\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK, bool discountIlluminant, int stage)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0, 1);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k  = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4 = k * k * k * k;\n    F_L\[stage]     = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);\n\n    z\[stage] = compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, stage);\n    A_w\[stage]          = dot(achromatic_weights, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    const float F_L_W = pow(F_L\[stage], nl_gamma);\n    y_to_j_A_w\[stage] = (nl_scale * F_L_W) / (nl_offset + F_L_W);\n\n    // TODO check if this dot product reduction is good enough, check different white points\n    chromatic_adapt_scale\[stage] = CAT_CAT16\[1]\[0] / D_RGB\[stage].x + CAT_CAT16\[1]\[1] / D_RGB\[stage].y + CAT_CAT16\[1]\[2] / D_RGB\[stage].z;\n  \}\n\n  void init()\n  \{\n    referenceLuminance = 100.0f;\n\n    init_tonescale_constants(_peakLuminance);\n\n    const float log_peak = log10(aces_ts_n / aces_ts_n_r);\n\n    init_matrices();\n\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS);\n\n    init_chroma_compression(log_peak);\n    init_gamut_mapper(log_peak);\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, AP1_to_XYZ, _peakLuminance); // TODO: Does peakLuminance make sense?\n    initialise_reach_cusp_table(reachGamutCuspTable, gamutCuspTableSize, _limitJmax, XYZ_to_AP1);\n    initialise_cusp_table(limitingGamutCuspTable, gamutCuspTableSize, RGB_to_XYZ_limit, _peakLuminance);\n    initialise_upper_hull_gamma(_midJ, _cuspMidBlend, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain);\n    initialise_lower_hull_gamma(_midJ, _cuspMidBlend, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain);\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB.x      = max(0.0f, RGB.x);\n      RGB.y      = max(0.0f, RGB.y);\n      RGB.z      = max(0.0f, RGB.z);\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, int stage)\n  \{\n    const float3 F_L_RGB = pow(F_L\[stage] / nl_normalise * fabs(RGB), float3(nl_gamma, nl_gamma, nl_gamma));\n    const float3 RGB_c   = (nl_scale * sign(RGB) * F_L_RGB) / (nl_offset + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, int stage)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * nl_normalise / F_L\[stage] * pow((nl_offset * absRGB) / (nl_scale - absRGB), \n                                                                      float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n  \{\n    if (!apply_eccentricity)\n    \{\n        return 1.0f;\n    \}\n\n    // Hellwig2022/Helles2023\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n    const float _2_hr = 2 * hr;\n    const float _3_hr = 3 * hr;\n    const float _4_hr = 4 * hr;\n    // clang-format off\n    return (\n        - 0.0582f * cos(_1_hr)\n        - 0.0258f * cos(_2_hr)\n        - 0.1347f * cos(_3_hr)\n        + 0.0289f * cos(_4_hr)\n        - 0.1475f * sin(_1_hr)\n        - 0.0308f * sin(_2_hr)\n        + 0.0385f * sin(_3_hr)\n        + 0.0096f * sin(_4_hr)\n        + 1.0f\n      );\n    // clang-format on\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * nl_normalise * pow(fabs(A) / A_w\[conditions], surround\[conditions].y * z\[conditions]);\n  \}\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * A_w\[conditions] * pow(fabs(J) / nl_normalise, 1.0f / (surround\[conditions].y * z\[conditions]));\n  \}\n\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, int conditions)\n  \{\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB\[conditions] * RGB; // TODO: combine with CAT16\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, conditions);\n\n    // # Step 6 and Step 4\n    // # Computing achromatic responses for the stimulus.\n    // # Converting to preliminary cartesian coordinates.\n    // basically a 3x3 matrix\n\n    const float A = dot(achromatic_weights, RGB_a);\n    const float a = dot(a_weights, RGB_a);\n    const float b = dot(b_weights, RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n    const float h  = wrap_to_360(degrees(hr));\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    const float et = eccentricity_factor(hr, false);\n    float       M  = 43.0f * surround\[conditions].z * et * sqrt(a * a + b * b);\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n    const float hr = radians(JMh.z);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    const float et    = eccentricity_factor(hr, false);\n    const float P_p_1 = 43.0f * et * surround\[conditions].z;\n    const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M / P_p_1;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b));\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, conditions);\n\n    // # Step 6\n    const float3 RGB = RGB_c / D_RGB\[conditions];\n\n    // # Step 7\n    const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, conditions);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, conditions);\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  float2 limitingCuspFromTable(float wrapped_hue)\n  \{\n    float3 lo;\n    float3 hi;\n    if (wrapped_hue <= limitingGamutCuspTable\[0].z)\n    \{\n      lo   = limitingGamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = limitingGamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize; // Allowed as we have extra entry in the table\n      int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (wrapped_hue > limitingGamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = limitingGamutCuspTable\[high_i - 1];\n      hi = limitingGamutCuspTable\[high_i];\n    \}\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  // TODO: retest passing in table to search in.\n  float2 ccuspFromTable(float wrapped_hue)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (wrapped_hue <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize; // Allowed as we have extra entry in the table\n      int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (wrapped_hue > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 hueDependantHullGammas(float wrapped_hue)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = wrapped_hue - base_hue;\n\n    return lerp(limitingGamutGammas\[i_lo], limitingGamutGammas\[i_lo + 1], t);\n  \}\n\n  float cReachFromTable(float wrapped_hue)\n  \{\n    const int i_lo = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n    const float3 lo = reachGamutCuspTable\[i_lo];\n    const float3 hi = reachGamutCuspTable\[i_lo + 1]; // Valid as we have added 1 to table length\n\n    const float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float cuspJ, float limitJmax, float focusGainBlend, float focusAdjustGain)\n  \{\n    const float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J <= thr)\n      return 1.0f; // Analytic inverse possible below cusp // TODO is this comment correct\n\n    // Approximate inverse required above threshold // TODO\n    float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n   \}\n\n  inline float compute_slope_gain(float J, float cuspJ, float limitJmax, float focusDist, float focusGainBlend, float focusAdjustGain)\n  \{\n    return limitJmax * focusDist * getFocusGain(J, cuspJ, limitJmax, focusGainBlend, focusAdjustGain);\n  \}\n\n// reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  float3 getReachBoundary(float3 Jmh, float2 JMcusp_raw, float reachMaxM, float midJ, float cuspMidBlend, float limitJmax,\n                          float focusDist, float focusGainBlend, float focusAdjustGain, float model_gamma)\n  \{\n    float  focusJ     = compute_focusJ(JMcusp_raw, midJ, cuspMidBlend, limitJmax);\n    float  slope_gain = compute_slope_gain(Jmh.x, JMcusp_raw.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n    float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n    float  slope;\n    if (intersectJ < focusJ)\n    \{\n      slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n    \}\n    else\n    \{\n      slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n    \}\n    Jmh.y = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n    return Jmh;\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float2 estimated_hull_gammas)\n  \{\n    float2      JM_source    = float2(JMh_s.x, JMh_s.y);\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    float slope;\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp) * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), gamma_top)\n      / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  float3 gamutMapper2(float3 JMh, bool direction, float Jx, float limitJmax, float focusDist, float focusGainBlend, float focusAdjustGain,\n                      float2 JMcusp, float focusJ, float cuspMidBlend, float2 estimated_hull_gammas, float smoothness, float reachMaxM, float midJ, float model_gamma)\n  \{\n    const float2 project_from = float2(JMh.x, JMh.y);\n\n    // Calculate where the out of gamut color is projected to\n    const float  slope_gain    = compute_slope_gain(Jx, JMcusp.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n    const float3 ganutBoundary = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothness, estimated_hull_gammas);\n    const float2 JMboundary    = float2(ganutBoundary.x, ganutBoundary.y);\n    const float2 project_to    = float2(ganutBoundary.z, 0.0f);\n    const float  projectJ      = ganutBoundary.z;\n\n    // Get hue dependent compression parameters depend on J\n    const float3 JMh_boundary = float3(JMboundary.x, JMboundary.y, JMh.z);\n    const float  locusMax     = getReachBoundary(JMh_boundary, JMcusp, reachMaxM, midJ, cuspMidBlend,\n                                                 limitJmax, focusDist, focusGainBlend, focusAdjustGain, model_gamma).y;\n    const float  difference   = max(1.0001f, locusMax / JMboundary.y); // TODO: magic threshold?\n    const float  threshold    = max(_compressionFuncParams.x, 1.0f / difference);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed;\n\n    const float lowerMlimit = 0.0001f; // Testing a small value here // TODO\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)        // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, threshold, difference, _compressionFuncParams.w, direction);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f); // TODO: should this be lowerMlimit\n    \}\n    return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n  \}\n\n  inline float compute_focusJ(float2 JMCusp, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(JMCusp.x, midJ, min(1.0f, cuspMidBlend - (JMCusp.x / limitJmax)));\n  \}\n\n  float3 gamutMapper(float3 JMh, bool direction)\n  \{\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f) // TODO: should this be lowerMlimit\n      return JMh;\n\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n    const float2 JMcusp                = limitingCuspFromTable(JMh.z);\n    const float2 JMcusp_smoothed       = JMcusp * smooth_cusp_scale;  // TODO; could this be baked in?\n    const float2 estimated_hull_gammas = hueDependantHullGammas(JMh.z);\n    const float  reachMaxM             = cReachFromTable(JMh.z);\n\n    // focus is Cusp dependent and thus hue\n    const float focusJ = compute_focusJ(JMcusp_smoothed, _midJ, _cuspMidBlend, _limitJmax);\n\n    float Jx = JMh.x;\n\n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > lerp(JMcusp_smoothed.x, _limitJmax, _focusGainBlend)) // TODO check consistency with disableFocusGain\n        Jx = gamutMapper2(JMh, direction, Jx, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain,\n                          JMcusp_smoothed, focusJ, _cuspMidBlend, estimated_hull_gammas,\n                          clamped_smoothness, reachMaxM, _midJ, _model_gamma).x;\n    \}\n    return gamutMapper2(JMh, direction, Jx, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain,\n                        JMcusp_smoothed, focusJ, _cuspMidBlend, estimated_hull_gammas,\n                        clamped_smoothness, reachMaxM, _midJ, _model_gamma);\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 display_linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, DISPLAY_CONDITIONS); // TODO\n    return JMh;\n  \}\n\n  float3 JMh_to_display_linear_RGB(float3 JMh, const float3x3& matrix)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, DISPLAY_CONDITIONS); // TODO\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  void init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    aces_ts_n = peakLuminance;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_n / aces_ts_n_r) / log(10000.0f / 100.0f));\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    aces_ts_u                  = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    aces_ts_m                  = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = aces_ts_w_2 * aces_ts_m_1;\n    aces_ts_u_2                = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(float Y)\n  \{\n    Y       = max(0.0f, Y / referenceLuminance); // TODO: we rescale and scale on input and output could this be better\n    float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);\n    float h = max(0.0f, f * f / (f + aces_ts_t_1));\n    return h * aces_ts_n;\n  \}\n\n  inline float aces_ts_rev(float Y)\n  \{\n    Y       = Y / aces_ts_n;\n    Y       = max(0.0f, min(aces_ts_n / (aces_ts_u_2 * aces_ts_n_r), Y)); // TODO: precompute?\n    float h = (Y + sqrt(Y * (4.0f * aces_ts_t_1 + Y))) / 2.0f;\n    float f = aces_ts_s_2 / (pow((aces_ts_m_2 / h), (1.0f / aces_ts_g)) - 1.0f);\n    return f * referenceLuminance;\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float Y_to_Hellwig_J(float Y, int stage)\n  \{\n    const float F_L_Y = pow(F_L\[stage] * fabs(Y) / nl_normalise, nl_gamma);\n    return sign(Y) * nl_normalise * pow(((nl_scale * F_L_Y) / (nl_offset + F_L_Y)) / y_to_j_A_w\[stage], surround\[stage].y * z\[stage]);\n  \}\n\n  inline float Hellwig_J_to_Y(float J, int stage)\n  \{\n    const float A = y_to_j_A_w\[stage] * pow(fabs(J) / nl_normalise, 1.0f / (surround\[stage].y * z\[stage]));\n    return sign(J) * nl_normalise / F_L\[stage] * pow((nl_offset * A) / (nl_scale - A), 1.0f / nl_gamma); // TODO: fix me\n  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions) // TODO: switch float3 to single channel?\n  \{\n    float  linear        = Hellwig_J_to_Y(inputJMh.x, conditions);\n    float  luminanceTS   = aces_ts_fwd(linear);\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, conditions);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    return tonemappedJMh;\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    float3 untonemappedColourJMh = JMh;\n    float  luminance             = Hellwig_J_to_Y(untonemappedColourJMh.x, conditions);\n    float  linear                = aces_ts_rev(luminance);\n    untonemappedColourJMh.x      = Y_to_Hellwig_J(linear, conditions);\n\n    return untonemappedColourJMh;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f); // TODO; magic constant\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, bool inverse, float limitJmax, float model_gamma,\n                          float sat, float sat_thr, float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = ccuspFromTable(JMh.z).y;\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= Mnorm;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0); // TODO; magic constant\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, nJ * compr, snJ, 0);\n\n      // Denormalize\n      M *= Mnorm;\n    \}\n    else\n    \{\n      M /= Mnorm;\n      M = toe(M, limit, nJ * compr, snJ, 1);\n      M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1); // TODO; magic constant\n      M *= Mnorm;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  inline float3 compressChroma(float3 JMh, float originalJ, bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse) // TODO: should this be in the chromaCompression function\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        compressedJMh  = gamutMapper(gamutMappedJMh, INVERSE);\n        tonemappedJMh  = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh            = compressChroma(compressedJMh, tonemappedJMh.x, INVERSE);\n        output         = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped = clamp_to_AP1(src);\n        JMh            = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        tonemappedJMh  = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh  = compressChroma(tonemappedJMh, JMh.x, FORWARDS);\n        gamutMappedJMh = gamutMapper(compressedJMh, FORWARDS);\n        output         = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        float3 JMh = inverseTonescale(src, SOURCE_CONDITIONS);\n        output     = compressChroma(src, JMh.x, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        output = gamutMapper(src, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        output = gamutMapper(src, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        float3 tonemappedJMh = forwardTonescale(src, SOURCE_CONDITIONS);\n        output               = compressChroma(src, tonemappedJMh.x, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        float2 cusp = limitingCuspFromTable(src.z);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_cgamutCuspTable == diagnosticMode)\n    \{\n        float2 cusp = ccuspFromTable(src.z);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        float2 gammas = hueDependantHullGammas(src.z);\n        output = float3(gammas.x, gammas.y, src.z);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        float reachM = cReachFromTable(src.z);\n        output = float3(reachM, src.y, src.z);\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_Limiting primaries" {{parent.limiting_primaries}}
  "ACES_DRT_Kernel_Limiting Whitepoint" {{parent.limiting_whitepoint}}
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_Compression Function Parameters" {0.75 1.100000024 1.299999952 1}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 130
  ypos -110
 }
 Output {
  name Output1
  xpos 130
  ypos -10
 }
end_group
