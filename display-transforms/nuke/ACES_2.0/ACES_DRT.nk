set cut_paste_input [stack 0]
version 13.2 v8
push $cut_paste_input
Group {
 name ACES_DRT_FULL
 selected true
 xpos 146
 ypos -174
 addUserKnob {20 User}
 addUserKnob {4 InEncoding l Input M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
 addUserKnob {4 InWhitepoint l "" -STARTLINE M {"Illuminant E" ACES D65 DCI Custom ""}}
 InWhitepoint ACES
 addUserKnob {4 InPrimaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" "" "" "" "" ""}}
 InPrimaries AP0-ACES
 addUserKnob {26 Limit l Limiting}
 addUserKnob {41 limiting_whitepoint l "Limiting Gamut" T params.limiting_whitepoint}
 addUserKnob {41 limiting_primaries l "" -STARTLINE T params.limiting_primaries}
 addUserKnob {20 Custom n 1}
 Custom 0
 addUserKnob {41 custom_red l "Custom red" T params.custom_red}
 addUserKnob {41 custom_green l "Custom Green" T params.custom_green}
 addUserKnob {41 custom_blue l "Custom Blue" T params.custom_blue}
 addUserKnob {41 custom_white l "Custom White" T params.custom_white}
 addUserKnob {20 endGroup n -1}
 addUserKnob {41 peakLuminance l Peak T params.peakLuminance}
 addUserKnob {26 Limiter l Scale/Clipping}
 addUserKnob {6 WhiteScale l "White Scaling" +STARTLINE}
 WhiteScale true
 addUserKnob {6 HardClip l "Hard Clip" +STARTLINE}
 HardClip true
 addUserKnob {26 Encoding}
 addUserKnob {4 OutEncoding l Output -STARTLINE M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 "Gamma 2.2" ""}}
 OutEncoding "BT.1886 (Gamma 2.4)"
 addUserKnob {4 OutWhitepoint l "" -STARTLINE M {"Illuminant E" ACES D65 DCI Custom "" ""}}
 OutWhitepoint D65
 addUserKnob {4 OutPrimaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" ""}}
 OutPrimaries "Rec.709  (sRGB)"
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  color {0.801596 0.176808 -0.198404 0}
  color_panelDropped true
  format "256 256 0 0 256 256 1 square_256"
  name NoInput
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 51
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Encoding {{parent.InEncoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.InPrimaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.InWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Encoding_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Encoding_Kernel_Custom White" {0.3127000034 0.3289999962}
  rebuild_finalise ""
  name Decode
  xpos 228
  ypos 49
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 227
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Kernel\" iterate pixelWise a546cd9cba9682f370361c457308753c0b805750e9fad0cd6e79b12111e27470 2 \"src\" Read Point \"dst\" Write Point 47 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 1 AABAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 47 \"invert\" 1 1 \"AP1Clamp\" 1 1 \"_peakLuminance\" 1 1 \"primariesLimit\" 1 1 \"whiteLimit\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 \"_inputViewingConditions\" 1 1 \"L_A_in\" 1 1 \"Y_b_in\" 1 1 \"_outputViewingConditions\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 \"_userSurround\" 3 1 \"_XYZ_w_scaler\" 1 1 \"diagnosticMode\" 1 1 \"_smoothCusps\" 1 1 \"_smoothOffset\" 2 1 \"_cuspMidBlend\" 1 1 \"_focusGainBlend\" 1 1 \"_focusAdjustGain\" 1 1 \"_focusDistance\" 1 1 \"_focusDistanceScaling\" 1 1 \"_compressionFuncParams\" 1 1 \"LMS_rxy\" 2 1 \"LMS_gxy\" 2 1 \"LMS_bxy\" 2 1 \"LMS_wxy\" 2 1 \"chroma_compress\" 1 1 \"chroma_compress_fact\" 1 1 \"chroma_expand\" 1 1 \"chroma_expand_fact\" 1 1 \"chroma_expand_thr\" 1 1 \"lowerHullGamma\" 1 1 \"upperHullGamma\" 1 1 \"disableUpperHullGamma\" 1 1 \"disableLowerHullGamma\" 1 1 \"aces_ts_n_r\" 1 1 \"aces_ts_g\" 1 1 \"aces_ts_c\" 1 1 \"aces_ts_c_d\" 1 1 \"aces_ts_w_g\" 1 1 \"aces_ts_t_1\" 1 1 \"aces_ts_r_hit_min\" 1 1 \"aces_ts_r_hit_max\" 1 1 47 \"DL_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DL_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DM_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"DS_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_w\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"achromatic_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"achromatic_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"a_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"b_weights_inv\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"hueTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"limitingGamutCuspTable\" Float 4 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachMTable\" Float 1 362 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reach_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_cusp_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"display_JMh_corners\" Float 3 8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"cube_hues\" Float 1 12 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"unique_hues\" Int 1 1 AAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_base_slope\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"chromaCompressScale\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"aces_ts_inv_upper_limit\" Float 1 1 AAAAAA== \"input_upper_clamp\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int whiteLimit;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#define DEBUG_limitingGamutCuspTableRaw 60\n#define DEBUG_limitingGamutCuspTableRaw2 61\n#define DEBUG_reachMTableRaw 62\n\n\n#define DEBUG_Jconstants 70\n#define DEBUG_FocusConstants 71\n#define DEBUG_limitingFocusJ 72\n#define DEBUG_reachMConditions 73\n\n#define DEBUG_gamutCompressAlphaFORWARDS 80\n#define DEBUG_gamutCompressAlphaINVERSE 81\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold\n  float _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3 DL_weights\[NUMBER_CONDITIONS];\n  float3 DM_weights\[NUMBER_CONDITIONS];\n  float3 DS_weights\[NUMBER_CONDITIONS];\n  \n  float3 DL_weights_inv\[NUMBER_CONDITIONS];\n  float3 DM_weights_inv\[NUMBER_CONDITIONS];\n  float3 DS_weights_inv\[NUMBER_CONDITIONS];\n\n  float3 achromatic_w;\n  float3 a_w;\n  float3 b_w;\n\n  float3 achromatic_weights\[NUMBER_CONDITIONS];\n  float3 a_weights\[NUMBER_CONDITIONS];\n  float3 b_weights\[NUMBER_CONDITIONS];\n\n  float3 achromatic_weights_inv\[NUMBER_CONDITIONS];\n  float3 a_weights_inv\[NUMBER_CONDITIONS];\n  float3 b_weights_inv\[NUMBER_CONDITIONS];\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n\n#define j_scale      100.0f\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n\n//#define USE_DEGREES\n#ifdef USE_DEGREES\n#define hue_limit 360.0f\n#else\n#define hue_limit (2 * PI)\n#endif\n#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range \[0.0, hue_limit) needs to be a multiple of 6 to sample hull corners\n#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases\n#define totalTableSize gamutCuspTableSize + additonal_entries\n#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle\n\n#define gammaAccuracy 5e-6\n#define gammaMinimum 0.4f\n#define gammaMaximum 2.0f\n#define gammaSearchStep 0.2f\n#define badGammaTollerance 1e-2f\n#define hueFindingTollerance 1e-7f\n\n  // Non-uniform in h\n  float  hueTable\[totalTableSize];\n  float4 limitingGamutCuspTable\[totalTableSize];    // \{ J, M, Upper gamma, Lower gamma \}\n  float reachMTable\[totalTableSize];                // reachM \n\n// Note reuse of Hue channel 2\n#define UPPER_GAMMA 2\n#define LOWER_GAMMA 3\n\n#define cuspCornerCount 6\n#define totalCornerCount cuspCornerCount + additonal_entries\n\n  float3 reach_cusp_corners\[totalCornerCount];\n  float3 reach_JMh_corners\[totalCornerCount];\n\n  float3 display_cusp_corners\[totalCornerCount];\n  float3 display_JMh_corners\[totalCornerCount];\n\n  float cube_hues\[2*cuspCornerCount];\n  int unique_hues;\n\n  float  clamped_smoothness;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma; // TODO: investigate uses of this\n  float _base_slope;\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n  float chromaCompressScale; // Scaling foactor for 'cusp' normalisation factor\n\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_m_2;\n  float aces_ts_inv_upper_limit;\n  float input_upper_clamp;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting Luminance\", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f); // Note these are rediculously wrong depends on viewing conditions\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9f, 0.59f, 0.9f));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", 0.75f);\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(1.0f / 3.0f, 1.0f / 3.0f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float3x3 newMatrix =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    if (direction == INVERSE)\n    \{\n      return newMatrix.invert();\n    \}\n    return newMatrix;\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  float3x3 generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_w = nl_scale * float3(ra, 1.0f, ba);\n    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;\n\n    float3x3 mat =  constuct_inverse_matrix(achromatic_w, a_w, b_w);\n\n    for (int i = 0; i != 3; ++i)\n    \{\n      float n = (460.0f / mat\[i]\[0]) / 1403.0f;\n      mat\[i]\[0] *= n / nl_scale;\n      mat\[i]\[1] *= n / nl_scale;\n      mat\[i]\[2] *= n / nl_scale;\n    \}\n    return mat;\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8f, 0.525f, 0.8f);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9f, 0.59f, 0.9f);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0f, 0.69f, 1.0f);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  void init_matrices(float3x3& CAT_CAT16)\n  \{\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n    float2 temp_primaries\[3] =\n    \{\n      LMS_rxy, LMS_gxy, LMS_bxy\n    \};\n  \n    float3x3 CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(temp_primaries, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE;  // Future Nuke versions make the inverse an inplace operator\n    CAT_CAT16 = CAT_CAT16.invert(); // So we copy it then invert, this extra assignment could be dropped in the future\n\n    // AP1 matrix\n    get_primaries(2, custom_primaries, temp_primaries);\n    float2 whitepoint = get_whitepoint(1, custom_white);\n    AP1_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_AP1 = AP1_to_XYZ;\n    XYZ_to_AP1 = XYZ_to_AP1.invert();\n\n    get_primaries(primariesLimit, custom_primaries, temp_primaries);\n    whitepoint = get_whitepoint(whiteLimit, custom_white);\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit;\n    XYZ_to_RGB_limit = XYZ_to_RGB_limit.invert();\n  \}\n\n  void init_chroma_compression(const float peakLuminance, const float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / peakLuminance;\n    chromaCompressScale = pow(0.03379f * peakLuminance, 0.30596f) - 0.45135f;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  float2 init_gamut_mapper(const float peakLuminance, const float log_peak, const float3 white)\n  \{\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(white * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = linear_RGB_to_JMh(float3(peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n    _base_slope = _limitJmax * _focusDist;\n\n    clamped_smoothness             = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?\n    const float2 smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n    return smooth_cusp_scale;\n  \}\n\n  inline float3 generate_unit_cube_corners(const int corner)\n  \{\n    // Generation order R, Y, G, C, B, M to ensure hues rotate in correct order\n    return float3(int(((corner+1)%cuspCornerCount) < 3), int(((corner+5)%cuspCornerCount) < 3), int(((corner+3)%cuspCornerCount) < 3));\n  \}\n\n  void build_cusp_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount], const int rgb_conditions, const float3x3& rgb_matrix, const float peakLuminance)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      temp_cusp_corners\[i] = vector_dot(rgb_matrix, peakLuminance * generate_unit_cube_corners(i));\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  void find_reach_corners_tables(float3 XYZ_corners\[totalCornerCount], float3 JMh_corners\[totalCornerCount],\n                                const int rgb_conditions, const float3x3& rgb_matrix, const float limitJ, const float maximum_source)\n  \{\n    float3 temp_cusp_corners\[cuspCornerCount];\n    float3 temp_JMh_corners\[cuspCornerCount];\n\n    int min_index = 0;\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      const float3 xyz_vector = vector_dot(rgb_matrix, generate_unit_cube_corners(i));\n      float3 JMh = float3(0.0f);\n\n      float lower = 0.0f;\n      float upper = maximum_source;\n      while ((upper - lower) > 1e-3)\n      \{\n        float test = midpoint(lower, upper);\n        const float3 test_corner = test * xyz_vector;\n        JMh = XYZ_to_JMh(test_corner, rgb_conditions);\n        if (JMh.x < limitJ)\n        \{\n          lower = test;\n        \}\n        else\n        \{\n          upper = test;\n        \}\n        if (JMh.x == limitJ)\n          break;\n      \}\n      temp_cusp_corners\[i] = upper * xyz_vector;\n      temp_JMh_corners\[i] = XYZ_to_JMh(temp_cusp_corners\[i], rgb_conditions);\n \n      if (temp_JMh_corners\[i].z < temp_JMh_corners\[min_index].z)\n        min_index = i;\n    \}\n\n    // Rotate entries placing lowest at \[1] (not \[0])\n    for (int i = 0; i != cuspCornerCount; ++i)\n    \{\n      XYZ_corners\[i + 1] = temp_cusp_corners\[(i + min_index) % cuspCornerCount];\n      JMh_corners\[i + 1] = temp_JMh_corners\[(i + min_index) % cuspCornerCount];\n    \}\n\n    // Copy end elements to create a cycle\n    XYZ_corners\[0]                   = XYZ_corners\[cuspCornerCount];\n    XYZ_corners\[cuspCornerCount+1]   = XYZ_corners\[1];\n    JMh_corners\[0]                   = JMh_corners\[cuspCornerCount];\n    JMh_corners\[cuspCornerCount+1]   = JMh_corners\[1];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    JMh_corners\[0].z                 = JMh_corners\[0].z - hue_limit;\n    JMh_corners\[cuspCornerCount+1].z = JMh_corners\[cuspCornerCount+1].z + hue_limit;\n  \}\n\n  int extract_sorted_cube_hues(float sorted_hues\[12], const float3 reach_JMh\[totalCornerCount], const float3 display_JMh\[totalCornerCount])\n  \{\n    // Basic merge of 2 sorted arrays, extracting the unique hues.\n    // Return the count of the unique hues\n    int idx = 0;\n    int reach_idx = 1;\n    int display_idx = 1;\n    while ((reach_idx < (cuspCornerCount + 1)) || (display_idx < (cuspCornerCount + 1)))\n    \{\n      const float reach_hue = reach_JMh\[reach_idx].z;\n      const float display_hue = display_JMh\[display_idx].z;\n      if (reach_hue == display_hue)\n      \{\n        sorted_hues\[idx] = reach_hue;\n        ++reach_idx;\n        ++display_idx; // When equal consume both\n      \}\n      else\n      \{\n        if (reach_hue < display_hue)\n        \{\n          sorted_hues\[idx] = reach_hue;\n          ++reach_idx;\n        \}\n        else\n        \{\n          sorted_hues\[idx] = display_hue;\n          ++display_idx;\n        \}\n      \}\n      ++idx;\n    \}\n    return idx;\n  \}\n\n  void build_hue_sample_interval(const int samples, const float lower, const float upper, float hueTable\[totalTableSize], const int base)\n  \{\n    const float delta = (upper - lower) / float(samples);\n    for (int i = 0; i != samples; ++i)\n    \{\n      hueTable\[base + i] = lower + float(i) * delta;\n    \}\n  \}\n\n  void build_hue_table(float hueTable\[totalTableSize], const float cube_hues\[2*cuspCornerCount], const int unique_hues)\n  \{\n    const float ideal_spacing = gamutCuspTableSize / hue_limit;\n    int samples_count\[2*cuspCornerCount+2];\n    int last_idx = -1;\n    int min_index = cube_hues\[0] == 0.0f ? 0 : 1; // Ensure we can always sample at 0.0 hue\n    for (int hue_idx = 0; hue_idx != unique_hues; ++hue_idx)\n    \{\n      // BUG: \"gamutCuspTableSize - 1\" will fail if we have multple hues mapping near the top of the table\n      int nominal_idx = clamp(int(round(cube_hues\[hue_idx] * ideal_spacing)), min_index, gamutCuspTableSize - 1);\n      if (last_idx == nominal_idx)\n      \{\n        // Last two hues should sample at same index, need to adjust them\n        // Adjust previous sample down if we can\n        if (hue_idx > 1 && samples_count\[hue_idx - 2] != (samples_count\[hue_idx - 1] - 1))\n        \{\n          samples_count\[hue_idx - 1] = samples_count\[hue_idx - 1] - 1;\n        \}\n        else\n        \{\n          nominal_idx = nominal_idx + 1;\n        \}\n      \}\n      samples_count\[hue_idx] = min(nominal_idx, gamutCuspTableSize - 1);\n      last_idx = min_index = nominal_idx;\n    \}\n\n    int total_samples = 0;\n    // Special cases for ends\n    int i = 0;\n    build_hue_sample_interval(samples_count\[i], 0.0f, cube_hues\[i], hueTable, total_samples+1);\n    total_samples += samples_count\[i];\n    for (++i; i != unique_hues; ++i)\n    \{\n      const int samples = samples_count\[i]-samples_count\[i-1];\n      build_hue_sample_interval(samples, cube_hues\[i-1], cube_hues\[i], hueTable, total_samples+1);\n      total_samples += samples;\n    \}\n    // BUG: could break if we are unlucky with samples all being used up by this point\n    build_hue_sample_interval(gamutCuspTableSize - total_samples, cube_hues\[i-1], hue_limit, hueTable, total_samples+1);\n\n    hueTable\[0] = hueTable\[totalTableSize - 2] - hue_limit;\n    hueTable\[totalTableSize - 1] = hueTable\[1] + hue_limit;\n  \}\n\n  float2 find_reach_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (reach_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (reach_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(reach_JMh_corners\[lower_corner].x, reach_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = reach_cusp_corners\[lower_corner];\n    const float3 cusp_upper = reach_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < reach_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > reach_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  float2 find_display_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)\n  \{\n    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching\n    // along the line calculating the JMh of points along the line till we find the required value.\n    // All values on the line segments are valid cusp locations.\n\n    int upper_corner = 1;\n    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?\n    \{\n       if (display_JMh_corners\[i].z > hue)\n       \{\n        upper_corner = i;\n        break;\n       \}\n    \}\n    const int lower_corner = upper_corner - 1;\n\n    // hue should now be within \[lower_corner, upper_corner), handle exact match\n    if (display_JMh_corners\[lower_corner].z == hue)\n    \{\n      return float2(display_JMh_corners\[lower_corner].x, display_JMh_corners\[lower_corner].y);\n    \}\n \n    // search by lerping between RGB corners for the hue\n    const float3 cusp_lower = display_cusp_corners\[lower_corner];\n    const float3 cusp_upper = display_cusp_corners\[upper_corner];\n    float3 sample;\n\n    float sample_t;\n    float lower_t = 0.0f;\n    float upper_t = 1.0f;\n\n    float3 JMh;\n\n    // There is an edge case where we need to search towards the range when across the \[0.0f, hue_limit) boundary\n    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make\n    // sure we are still in the expected range between the lower and upper corner hue limits\n    if (upper_corner > cuspCornerCount)\n    \{\n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z < display_JMh_corners\[lower_corner].z) || (JMh.z > hue))\n        \{\n          upper_t = sample_t;\n        \}\n        else\n        \{\n          lower_t = sample_t;\n        \}\n      \}\n    \}\n    else\n    \{\n      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication\n      // we can use it for all the remaining segments as it still produces the correct result \n      while((upper_t - lower_t) > tollerance)\n      \{\n        sample_t = midpoint(lower_t, upper_t);\n        sample = lerp(cusp_lower, cusp_upper, sample_t);\n        JMh = XYZ_to_JMh(sample, rgb_conditions);\n        if ((JMh.z > display_JMh_corners\[upper_corner].z) || (JMh.z <= hue))\n        \{\n          lower_t = sample_t;\n        \}\n        else\n        \{\n          upper_t = sample_t;\n        \}\n      \}\n    \}\n\n    // Use the midpoint of the final interval for the actual sampls\n    sample_t = midpoint(lower_t, upper_t);\n    sample = lerp(cusp_lower, cusp_upper, sample_t);\n    JMh = XYZ_to_JMh(sample, rgb_conditions);\n\n    return float2(JMh.x, JMh.y);\n  \}\n\n  void initialise_cusp_table(float4 output_table\[totalTableSize], const float luminance, const int conditions)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    for (int i = 1; i != gamutCuspTableSize + 1; ++i)\n    \{\n      const float hue = hueTable\[i];\n      const float2 JM = find_display_cusp_for_hue(hue, conditions, hueFindingTollerance);\n      output_table\[i] = float4(JM.x, JM.y, hue, 0.0f);\n    \}\n\n    // Copy extra entries to ease the code to handle hues wrapping around\n    output_table\[0]                              = output_table\[baseIndex + gamutCuspTableSize - 1];\n    output_table\[baseIndex + gamutCuspTableSize] = output_table\[baseIndex];\n\n    // Wrap the hues, to maintain monotonicity these entries will fall outside \[0.0, hue_limit)\n    output_table\[0].z = output_table\[0].z - hue_limit;\n    output_table\[baseIndex + gamutCuspTableSize].z = output_table\[baseIndex + gamutCuspTableSize].z + hue_limit;\n  \}\n\n  void smooth_cusp_table(float4 table\[totalTableSize], const float2 scale)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      //table\[i].x      = table\[i].x * scale.x; // Not needed as the scale is unity\n      table\[i].y      = table\[i].y * scale.y;\n    \}\n  \}\n\n  void precompute_reach_table(float reachMTable\[totalTableSize], const float limitJ, const float3x3& xyz_matrix,\n                              const float3x3& rgb_matrix, const int conditions)\n  \{\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      const float hue = hueTable\[i];\n      reachMTable\[i] = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);\n    \}\n  \}\n\n  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)\n  \{\n    const float search_range = 100.0;\n    float low     = 0.0;\n    float high    = low + search_range;\n    bool  outside = false;\n\n    while (!outside && high < 1400.0)\n    \{\n      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));\n      if (!outside)\n      \{\n        low  = high;\n        high = high + search_range;\n      \}\n    \}\n\n    while ((high - low) > threshold)\n    \{\n      const float sampleM = midpoint(low, high);\n      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));\n      if (outside)\n      \{\n        high = sampleM;\n      \}\n      else\n      \{\n        low = sampleM;\n      \}\n    \}\n    return high;\n  \}\n\n  void fill_initial_hull_gammas(float4 table\[totalTableSize], float upperHullGamma, float lowerHullGamma)\n  \{\n    upperHullGamma = 1.0f / upperHullGamma;\n    lowerHullGamma = 1.0f / lowerHullGamma;\n    for (int i = 0; i != totalTableSize; ++i)\n    \{\n      table\[i]\[UPPER_GAMMA] = upperHullGamma;\n      table\[i]\[LOWER_GAMMA] = lowerHullGamma;\n    \}\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||\n        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal);\n  \}\n\n  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,\n                               const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                               const float2 estimated_hull_gammas, const int conditions)\n  \{\n    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);\n    const float analytical_threshold = compute_analytical_threshold(JMcusp.x, limitJmax, focusGainBlend);\n    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);\n\n    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float approxLimit =\n        findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);\n    const float J_boundary       = slope * approxLimit + intersectJ;\n\n    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);\n    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);\n    return newLimitRGB;\n  \}\n\n  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float2 estimated_hull_gammas,\n                                     const float limitJmax, const float base_slope, const float midJ,\n                                     const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,\n                                     const float luminance, const int conditions)\n  \{\n    for (int testIndex = 0; testIndex != test_count; ++testIndex)\n    \{\n      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh\[testIndex], limitJmax, base_slope,\n                                                       midJ, cuspMidBlend, focusAdjustGain, focusGainBlend, estimated_hull_gammas, conditions);\n\n      if (!outside_hull(newLimitRGB, luminance))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.5f, 0.8f, 0.99f\};\n    if (!disableUpperHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n        const float  hue                 = hueTable\[i];\n        const float4 cusp                = table\[i];\n        const float2 JMcusp              = float2(cusp.x, cusp.y);\n\n        float3 testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          // create test values between the cusp and the Jmax\n          testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(high, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(testGamma, table\[i]\[LOWER_GAMMA]);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[UPPER_GAMMA] = testGamma;\n      \}\n    \}\n    // Wrap the end entries\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f);\n  \}\n\n  void initialise_lower_hull_gamma(float4 table\[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,\n                                   const float luminance, const int conditions)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 5;\n    const float testPositions\[test_count] = \{0.01f, 0.1f, 0.4f, 0.6f, 0.75f\};\n    const float fixed_gamma = 1.0f / lowerHullGamma;\n    if (!disableLowerHullGamma)\n    \{\n      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n      \{\n        const float4 cusp   = table\[i];\n        const float2 JMcusp = float2(cusp.x, cusp.y);\n        const float  hue    = hueTable\[i];\n\n        float3       testJmh\[test_count];\n        for (int testIndex = 0; testIndex != test_count; ++testIndex)\n        \{\n          testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n        \}\n\n        const float search_range = gammaSearchStep;\n        float       low          = gammaMinimum;\n        float       high         = low + search_range;\n        bool        all_inside   = true;\n\n        while (all_inside && high < gammaMaximum)\n        \{\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], high);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (all_inside)\n          \{\n            low  = high;\n            high = high + search_range;\n          \}\n        \}\n\n        float testGamma = -1.0;\n        while ((high - low) > gammaAccuracy)\n        \{\n          testGamma  = midpoint(low, high);\n          const float2 estimated_hull_gammas = float2(table\[i]\[UPPER_GAMMA], testGamma);\n          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,\n                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,\n                                              luminance, conditions);\n          if (!all_inside)\n          \{\n            high = testGamma;\n          \}\n          else\n          \{\n            low = testGamma;\n          \}\n        \}\n        table\[i]\[LOWER_GAMMA] = testGamma;\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  float replace_gamma_entry(float4 table\[totalTableSize], int entry, int channel)\n  \{\n    // Very simple patch up, try to find good values either side and lerp a new value\n    int lower = entry - 1;\n    while (lower >= 0)\n    \{\n      if (!bad_gamma_value(table\[lower]\[channel]))\n        break;\n      lower = lower - 1;\n    \}\n    if (lower < 0)\n      return -1.0f; // Give up if we can't find a good entry below\n\n    int upper = entry + 1;\n    while (upper < baseIndex + gamutCuspTableSize)\n    \{\n      if (!bad_gamma_value(table\[upper]\[channel]))\n        break;\n      upper = upper + 1;\n    \}\n    if (upper == totalTableSize)\n      return -2.0f; // Give up nothing above us\n\n    float lower_hue = hueTable\[lower];\n    float upper_hue = hueTable\[upper];\n    float entry_hue = hueTable\[entry];\n    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);\n    return lerp(table\[lower]\[channel], table\[upper]\[channel], lerp_loc);\n  \}\n\n  bool bad_gamma_value(const float value)\n  \{\n    return ((value <= 0.0f) || (value <= gammaMinimum+badGammaTollerance) || (value >= gammaMaximum-badGammaTollerance));\n  \}\n\n  void repair_broken_gamma_values(float4 table\[totalTableSize])\n  \{\n    for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)\n    \{\n      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)\n      \{\n        if (bad_gamma_value(table\[i]\[channel]))\n        \{\n          table\[i]\[channel] = replace_gamma_entry(table, i, channel);\n        \}\n      \}\n    \}\n    table\[0] = table\[baseIndex + gamutCuspTableSize - 1];\n    table\[baseIndex + gamutCuspTableSize] = table\[baseIndex];\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  inline float3 extract_row(const float3x3 matrix, int row)\n  \{\n    return \{matrix\[row]\[0], matrix\[row]\[1], matrix\[row]\[2]\};\n  \}\n\n  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)\n  \{\n    return weight * extract_row(matrix, row);\n  \}\n\n  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)\n  \{\n    float3x3 matrix =\n    \{\n      a.x, a.y, a.z,\n      b.x, b.y, b.z,\n      c.x, c.y, c.z\n    \};\n    return matrix.invert();\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK,\n                          bool discountIlluminant, int stage, float3x3 CAT_CAT16, float3x3 panlrcm)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0.0f, 1.0f);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k    = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4   = k * k * k * k;\n    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);\n    F_L\[stage]       = _F_L / nl_normalise; //TODO white scale?\n\n    // # FWd Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    //float3 RGB = vector_dot(CAT_CAT16, XYZ);\n    //float3 RGB_c = D_RGB\[conditions] * RGB; // combine with CAT16\n\n    // Pre weight CAT16 matrix by D\n    DL_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].x, CAT_CAT16, 0);\n    DM_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].y, CAT_CAT16, 1);\n    DS_weights\[stage] = weight_matrix_row(F_L\[stage] * D_RGB\[stage].z, CAT_CAT16, 2);\n\n    // # Inv Step 6\n    //const float3 RGB = RGB_c / D_RGB\[conditions];\n    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n    const float3x3 tempmat = constuct_inverse_matrix(DL_weights\[stage], DM_weights\[stage], DS_weights\[stage]);\n    DL_weights_inv\[stage] = extract_row(tempmat, 0);\n    DM_weights_inv\[stage] = extract_row(tempmat, 1);\n    DS_weights_inv\[stage] = extract_row(tempmat, 2);\n\n    // Prescale values\n    surround\[stage].y = surround\[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n    surround\[stage].z = surround\[stage].z * 43.0f;\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L\[stage] * RGB_wc);\n    const float A_w     = dot(achromatic_w, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    y_to_j_A_w\[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);\n\n    F_L\[stage] *= _XYZ_w_scaler; // Allows tonescale multiplier to be removed\n\n    achromatic_weights\[stage] = achromatic_w / A_w;\n    a_weights\[stage]          = surround\[stage].z * a_w;\n    b_weights\[stage]          = surround\[stage].z * b_w;\n\n    const float3 column_weights = float3(A_w, 1.0f / surround\[stage].z, 1.0f / surround\[stage].z);\n    achromatic_weights_inv\[stage]   = extract_row(panlrcm, 0) * column_weights;\n    a_weights_inv\[stage]            = extract_row(panlrcm, 1) * column_weights;\n    b_weights_inv\[stage]            = extract_row(panlrcm, 2) * column_weights;\n  \}\n\n  void init()\n  \{\n    const float log_peak = init_tonescale_constants(_peakLuminance);\n\n    float3x3 CAT_CAT16;\n\n    init_matrices(CAT_CAT16);\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    const float3 inputWhite = vector_dot(AP1_to_XYZ, white);\n    const float3 limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n    const float3x3 panlrcm = generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS, CAT_CAT16, panlrcm);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS, CAT_CAT16, panlrcm);\n\n    init_chroma_compression(_peakLuminance, log_peak);\n    const float2 smooth_cusp_scale = init_gamut_mapper(_peakLuminance, log_peak, limitWhite);\n\n    // Fist find the unique hues for the cusp corners, then fill in the table uniformly between those hues\n    find_reach_corners_tables(reach_cusp_corners, reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _limitJmax, input_upper_clamp);\n    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);\n    unique_hues = extract_sorted_cube_hues(cube_hues, reach_JMh_corners, display_JMh_corners);\n    build_hue_table(hueTable, cube_hues, unique_hues);\n\n    initialise_cusp_table(limitingGamutCuspTable, _peakLuminance, DISPLAY_CONDITIONS);\n    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);\n    fill_initial_hull_gammas(limitingGamutCuspTable, upperHullGamma, lowerHullGamma);\n    // Iterate gamma finding based on previous values\n    for (int i = 0; i != 3; ++i)\n    \{\n      initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n      initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);\n    \}\n    repair_broken_gamma_values(limitingGamutCuspTable);\n\n    precompute_reach_table(reachMTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS);\n  \}\n\n#ifdef USE_DEGREES\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float to_radians(float hue)\n  \{\n    return hue / 180.0f * PI;\n  \}\n#endif\n\n  inline float wrap_hue(float hue)\n  \{\n    float y = fmod(hue, hue_limit);\n    if (y < 0.0)\n    \{\n      y = y + hue_limit;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB        = clamp(RGB, float3\{0.0f\}, float3(input_upper_clamp));\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_forward(float L)\n  \{\n    const float F_L_L = pow(L, float(nl_gamma));\n    return F_L_L / (nl_offset + F_L_L);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));\n    return F_L_RGB / (nl_offset + F_L_RGB);\n  \}\n\n  inline float _post_adaptation_non_linear_response_compression_inverse(float A)\n  \{\n    const float F_L_A = (nl_offset * A) / (1.0f - A);\n    return pow(F_L_A, 1.0f / nl_gamma);\n  \}\n\n  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 F_L_RGB = (nl_offset * RGB) / (1.0f - RGB);\n    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);\n    return RGB_c;\n  \}\n\n  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)\n  \{\n    const float3 absRGB  = fabs(RGB);\n    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);\n    return RGB_p;\n  \}\n\n//  // Return compression gamut cusp M scaled with an eccentricity factor\n//  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n//  \{\n//    if (!apply_eccentricity)\n//    \{\n//        return 1.0f;\n//    \}\n//\n//    // Hellwig2022/Helles2023\n//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n//    const float _2_hr = 2 * hr;\n//    const float _3_hr = 3 * hr;\n//    const float _4_hr = 4 * hr;\n//    // clang-format off\n//    return (\n//        - 0.0582f * cos(_1_hr)\n//        - 0.0258f * cos(_2_hr)\n//        - 0.1347f * cos(_3_hr)\n//        + 0.0289f * cos(_4_hr)\n//        - 0.1475f * sin(_1_hr)\n//        - 0.0308f * sin(_2_hr)\n//        + 0.0385f * sin(_3_hr)\n//        + 0.0096f * sin(_4_hr)\n//        + 1.0f\n//      );\n//    // clang-format on\n//  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float _J_from_Achromatic(float A, int conditions)\n  \{\n    return j_scale * pow(A, surround\[conditions].y);\n  \}\n\n  inline float _Achromatic_from_J(float J, int conditions)\n  \{\n    return pow(J / j_scale, 1.0f / surround\[conditions].y);\n  \}\n\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * _J_from_Achromatic(fabs(A), conditions);\n  \}\n\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * _Achromatic_from_J(fabs(J), conditions);\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    float3 RGB_c;\n    RGB_c.x = dot(DL_weights\[conditions], XYZ);\n    RGB_c.y = dot(DM_weights\[conditions], XYZ);\n    RGB_c.z = dot(DS_weights\[conditions], XYZ);\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);\n\n    const float A = dot(achromatic_weights\[conditions], RGB_a);\n    const float a = dot(a_weights\[conditions], RGB_a);\n    const float b = dot(b_weights\[conditions], RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n#ifdef USE_DEGREES\n    const float h  = wrap_hue(degrees(hr));\n#else\n    const float h  = wrap_hue(hr);\n#endif\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    //const float et = eccentricity_factor(hr, false);\n    //float       M  = surround\[conditions].z * et * sqrt(a * a + b * b);\n    float M = sqrt(a * a + b * b); // Valid as et == 1.0\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n#ifdef USE_DEGREES\n    const float hr = to_radians(JMh.z);\n#else\n    const float hr = JMh.z;\n#endif\n\n    // # *HelmholtzKohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float _A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    //const float et    = eccentricity_factor(hr, false);\n    //const float P_p_1 = surround\[conditions].z; // * et;\n    //const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 Aab = float3(_A, a, b);\n    //const float3 RGB_a = vector_dot(panlrcm, Aab);\n    float3 RGB_a;\n    RGB_a.x = dot(achromatic_weights_inv\[conditions], Aab);\n    RGB_a.y = dot(a_weights_inv\[conditions], Aab);\n    RGB_a.z = dot(b_weights_inv\[conditions], Aab);\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);\n\n    float3 XYZ;\n    XYZ.x = dot(DL_weights_inv\[conditions], RGB_c);\n    XYZ.y = dot(DM_weights_inv\[conditions], RGB_c);\n    XYZ.z = dot(DS_weights_inv\[conditions], RGB_c);\n\n    return XYZ;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / hue_limit * table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b (cubic polynomial)\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline float smin_s(float a, float b, float s, float normalise)\n  \{\n    const float s_scaled     = s * normalise;\n    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;\n    const float h            = max(scaled_delta, 0.0f);\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  inline float midpoint(float low, float high)\n  \{\n    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document\n    return (high + low) * 0.5f;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  int lookupLimitingCuspHue(float wrapped_hue)\n  \{\n    // samples are almost uniform should be able to find the correct entry +/- 6 entries from middle\n    // on average it is actually in a narrow range than this, left as an exersize for the reader to\n    // improve this, typically lies in upper half\n    // either way log2(search_range*2) is way smaller than log2(gamutCuspTableSize)\n    // BUG: needs checking if this range is too small should all the hues cluster together due to a\n    // pathelogical triangle formed by two primaries from one gamut closely bracketing one from the other\n#define search_range 2\n    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n    int low_i  = max(0, i - search_range);\n    int high_i = min(baseIndex + gamutCuspTableSize, i + search_range); // Allowed as we have extra entries in the table\n\n    while (low_i + 1 < high_i)\n    \{\n      if (wrapped_hue > hueTable\[i])\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float limiting_lerp_fraction(float wrapped_hue, int pos)\n  \{\n    return (wrapped_hue - hueTable\[pos - 1])\n          / (hueTable\[pos] - hueTable\[pos - 1]);\n  \}\n\n  inline float4 limitingCuspFromTable(int pos, float t)\n  \{\n    return lerp(limitingGamutCuspTable\[pos - 1], limitingGamutCuspTable\[pos], t);\n  \}\n\n  inline float reachMFromTable(int pos, float t)\n  \{\n    return lerp(reachMTable\[pos - 1], reachMTable\[pos], t);\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)\n  \{\n    // Assume J (0.0, limitJmax)\n    \n    if (J <= analytical_threshold)\n      return 1.0f; // makes the analytic inverse possible below cusp\n\n    // Approximate inverse required above threshold TODO: explain why\n    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n  \}\n\n  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,\n                                  const float focusAdjustGain, const float analytical_threshold)\n  \{\n    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)\n  \{\n    float direction_scaler;\n    if (intersectJ <= focusJ)\n    \{\n      direction_scaler = intersectJ;\n    \}\n    else\n    \{\n       direction_scaler = (limitJmax - intersectJ);\n    \}\n\n    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);\n  \}\n\n  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,\n                                                         const float inv_gamma, const float J_max, const float M_max,\n                                                         const float J_intersection_reference)\n  \{\n    // Line defined by     J = slope * x + J_axis_intersect\n    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)\n    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential\n    \n    // We calculate a shifted intersection from the original intersection using the inverse of the exponential\n    // and the provided reference\n    const float normalised_J        = J_axis_intersect / J_intersection_reference;\n    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);\n\n    // Now we find the M intersection of two lines\n    // line from origin to J,M Max       l1(x) = J/M * x\n    // line from J Intersect' with slope l2(x) = slope * x + Intersect'\n\n    return shifted_intersecion / ((J_max / M_max) - slope);\n    //return shifted_intersecion * M_max / (J_max - slope * M_max);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,\n                                       float2 estimated_hull_gammas, const float slope)\n  \{\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);\n\n    // The upper hull is flipped and thus 'zerod' at J_max\n    // Also note we negate the slope\n    const float f_J_intersect_cusp = J_max - J_intersect_cusp;\n    const float f_J_intersect_source = J_max - J_intersect_source;\n    const float f_JM_cusp_J = J_max - JM_cusp.x;\n    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);\n\n    // Smooth minimum between the two calculated values for the M component\n    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n    return M_boundary;\n    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);\n  \}\n\n  inline float reinhard_compress(const float scale, const float factor, const bool direction)\n  \{\n    if (INVERSE == direction)\n    \{\n      if (factor >= 1.0f)\n        return scale;\n      else\n        return scale * (-(factor / (factor - 1.0f)));\n    \}\n    return scale * (factor) / (1.0f + factor);\n  \}\n\n  inline float gamut_mapped_location(const float location, const float gamutBoundary, const float reachBoundary, const bool direction)\n  \{\n    // Assumes _compressionFuncParams in (0.0, 1.0)\n    const float threshold = clamp(gamutBoundary / reachBoundary, _compressionFuncParams, 0.99999f) * gamutBoundary;\n\n    // Values upto the threshold or when both boundaries are the same remain as is\n    if (location <= threshold || gamutBoundary == reachBoundary)\n      return location;\n\n    // Translate to place threshold at zero\n    const float location_offset = location - threshold;\n    const float boundary_offset = gamutBoundary - threshold;\n    const float reach_offset    = reachBoundary - threshold;\n\n    // Assumes boundary != reach\n    // Generaly speaking boundary should be < reach\n    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);\n    const float factor = location_offset / scale;\n\n    const float relative_location = reinhard_compress(scale, factor, direction);\n\n    return (threshold + relative_location); // shift back to absolute\n  \}\n\n  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,\n                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,\n                    float reachMaxM, float model_gamma)\n  \{\n    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);\n    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);\n    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);\n    const float ganutBoundaryM   = findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,\n                                                                  smoothness, estimated_hull_gammas, slope);\n\n    if (ganutBoundaryM <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)\n    \{\n      return float2(JM.x, 0.0f);\n    \}\n\n    // Compress the out of gamut color along the projection line\n    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);\n    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);\n    const float mappedJ  = slope * mappedM + intersectJ;\n\n    return float2\{mappedJ, mappedM\};\n  \}\n\n  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));\n  \}\n\n  inline float compute_analytical_threshold(const float cuspJ, const float limitJmax, const float focusGainBlend)\n  \{\n    return lerp(cuspJ, limitJmax, focusGainBlend);\n  \}\n\n  float3 gamutMapper(float3 JMh, const float4 cusp, const float reachM, bool direction)\n  \{\n    // Limit to +ve values // TODO test this is neededS\n    if (JMh.x <= 0.0f)\n    \{\n      JMh.x = 0.0f;\n      JMh.y = 0.0f;\n    \}\n    // Above the expected maximum we explicitly map to 0 M\n    if (JMh.x >= _limitJmax)\n    \{\n      JMh.y = 0.0f;\n    \}\n\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f)\n      return JMh;\n\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n    const float2 JMcusp                = float2(cusp.x, cusp.y);\n    const float2 estimated_hull_gammas = float2\{cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA]\};\n    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x, _limitJmax, _focusGainBlend); \n    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);\n\n    float  Jx         = JMh.x;\n    float2 JM         = float2\{JMh.x, JMh.y\};\n    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);\n \n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > analytical_threshold)\n      \{\n        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                        clamped_smoothness, reachM, _model_gamma).x;\n        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);\n      \}\n    \}\n    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,\n                    clamped_smoothness, reachM, _model_gamma);\n\n    return \{JM.x, JM.y, JMh.z\};\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, conditions);\n    return JMh;\n  \}\n\n  float3 JMh_to_linear_RGB(const float3 JMh, const float3x3& matrix, const int conditions)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, conditions);\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  float init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions\n\n    const float aces_ts_n      = peakLuminance;\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_m_0) / log(10000.0f / 100.0f));\n    input_upper_clamp = aces_ts_r_hit * 8.0f * _XYZ_w_scaler;  // limit to nice power of 2 (3 stops) above that needed to max out // TODO magic 8 ball factor needs assessing\n\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    const float aces_ts_u      = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    const float aces_ts_m      = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1);\n    const float aces_ts_u_2    = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?\n    return log10(aces_ts_m_0);\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(const float Y)\n  \{\n    // Assumes Y is >= +0.0\n    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);\n    return max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility\n  \}\n\n  inline float aces_ts_rev(const float Y)\n  \{\n    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?\n    const float f = (Y + sqrt(Y * (4.0f * aces_ts_t_1 + Y))) / 2.0f;\n    return aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float _Y_to_Hellwig_J(float Y, int conditions)\n  \{\n    // Assumes Y is >= +0.0\n    const float A = _post_adaptation_non_linear_response_compression_forward(F_L\[conditions] * Y) / y_to_j_A_w\[conditions];\n    return _J_from_Achromatic(A, conditions);\n  \}\n\n  inline float _Hellwig_J_to_Y(float J, int conditions)\n  \{\n    // Assumes J is >= +0.0\n    const float A = y_to_j_A_w\[conditions] * _Achromatic_from_J(J, conditions);\n    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L\[conditions];\n  \}\n\n//  inline float Y_to_Hellwig_J(float Y, int conditions)\n//  \{\n//    const float absY = fabs(Y);\n//    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?\n//  \}\n//\n//  inline float Hellwig_J_to_Y(float J, int conditions)\n//  \{\n//    const float absJ = fabs(J);\n//    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?\n//  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions)\n  \{\n    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below\n    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);\n    const float  luminanceTS   = aces_ts_fwd(inputY);\n    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);\n    return float3(tonemappedJ, inputJMh.y, inputJMh.z);\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);\n    const float  linear          = aces_ts_rev(luminance);\n    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);\n    return float3(untonemappedJ, JMh.y, JMh.z);\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, bool inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2             = max(k2, 0.001f); // TODO; magic constant\n    k1             = sqrt(k1 * k1 + k2 * k2);\n    const float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n    \{\n      const float minus_b = k3 * x - k1;\n      const float minus_c = k2 * k3 * x;\n      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2\n    \}\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompressionNorm(float h)\n  \{\n#ifdef USE_DEGREES\n    const float hr = to_radians(h);\n#else\n    const float hr = h;\n#endif\n    float a = cos(hr);\n    float b = sin(hr);\n    float cos_hr2 = a * a - b * b;\n    float sin_hr2 = 2.0f * a * b;\n    float cos_hr3 = 4.0f * a * a * a - 3.0f * a;\n    float sin_hr3 = 3.0f * b - 4.0f * b * b * b;\n\n    float M = 11.34072f * a +\n              16.46899f * cos_hr2 +\n               7.88380f * cos_hr3 +\n              14.66441f * b +\n              -6.37224f * sin_hr2 +\n               9.19364f * sin_hr3 +\n              77.12896f;\n\n    return M * chromaCompressScale;\n  \}\n\n  inline float chromaCompression(float3 JMh, const float origJ, const float reachMMax, const bool inverse,\n                                 const float limitJmax, const float model_gamma,\n                                 const float sat, const float sat_thr, const float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, hue_limit)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    const float nJ                   = JMh.x / limitJmax;\n    const float snJ                  = max(0.0f, 1.0f - nJ);\n\n    const float normalisation_factor = chromaCompressionNorm(JMh.z); // reachCuspM; // pow(nJ, model_gamma) * reachMMax; //\n    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor; // 1.0f; //\n\n    const float toe_limit           = limit - 0.001f;  // TODO; magic constantl\n    const float toe_snJ_sat         = snJ * sat;\n    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);\n    const float toe_nJ_compr        = nJ * compr;\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= normalisation_factor;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);\n\n      // Denormalize\n      M *= normalisation_factor;\n    \}\n    else\n    \{\n      M /= normalisation_factor;\n      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);\n      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);\n      M *= normalisation_factor;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 compressChroma(float3 JMh, const float originalJ, const float reachM, const bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, reachM, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse)\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);\n        const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);\n        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);\n        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped      = clamp_to_AP1(src);\n        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        const int    pos    = lookupLimitingCuspHue(JMh.z);\n        const float  t      = limiting_lerp_fraction(JMh.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);\n        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);\n        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);\n        output              = compressChroma(src, JMh.x, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        const int    pos    = lookupLimitingCuspHue(src.z);\n        const float  t      = limiting_lerp_fraction(src.z, pos);\n        const float4 cusp   = limitingCuspFromTable(pos, t);\n        const float  reachM = reachMFromTable(pos, t);\n        output = gamutMapper(src, cusp, reachM, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        const int    pos  = lookupLimitingCuspHue(src.z);\n        const float  t    = limiting_lerp_fraction(src.z, pos);\n        const float  reachM = reachMFromTable(pos, t);\n        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);\n        output            = compressChroma(src, JMh.x, reachM, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float4 cusp        = limitingCuspFromTable(pos, t);\n        output = float3(cusp\[UPPER_GAMMA], cusp\[LOWER_GAMMA], t);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const int   pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const float reachM      = reachMFromTable(pos, t);\n        output = float3(chromaCompressionNorm(src.z), reachM, wrapped_hue);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.z);\n    \}\n    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float4 cusp = limitingGamutCuspTable\[index];\n        output = float3(cusp.x, cusp.y, cusp.w);\n    \}\n    else if (DEBUG_reachMTableRaw == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float reachM = reachMTable\[index];\n        output = float3(reachM, src.z, index);\n    \}\n    \n    else if (DEBUG_Jconstants == diagnosticMode)\n    \{\n        output = float3(_midJ, _limitJmax, _focusDist);\n    \}\n    else if (DEBUG_FocusConstants == diagnosticMode)\n    \{\n        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);\n    \}\n    else if (DEBUG_reachMConditions == diagnosticMode)\n    \{\n        const float wrapped_hue = wrap_hue(src.z);\n        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);\n        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);\n\n        output = float3(sM, dM, wrapped_hue); \n    \}\n    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)\n    \{\n        const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);\n        output = float3(gml, src.y, src.z); \n    \}\n    else if (100 == diagnosticMode)\n    \{\n        const float sm  = src.z * smin(src.x / src.z, src.y / src.z, clamped_smoothness);\n        const float sms = smin_s(src.x, src.y, clamped_smoothness, src.z);\n        output = float3(sm, sms, src.z); \n    \}\n    else if (102 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const float2 found       = find_reach_cusp_for_hue(wrapped_hue, SOURCE_CONDITIONS, hueFindingTollerance);\n        const float  norm        = chromaCompressionNorm(wrapped_hue);\n        output = float3(found.x, found.y, norm);\n    \}\n    else if (103 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_JMh_corners\[index];\n    \}\n    else if (104 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = reach_cusp_corners\[index];\n    \}\n    else if (105 == diagnosticMode)\n    \{\n        const int index = int(src.z) % totalCornerCount;\n        output = display_JMh_corners\[index];\n    \}\n    else if (106 == diagnosticMode)\n    \{\n        output = float3(input_upper_clamp / _XYZ_w_scaler);\n    \}\n    else if (107 == diagnosticMode)\n    \{\n        const int index = int(src.z) % (2 * cuspCornerCount);\n        output = float3(cube_hues\[index], index, unique_hues);\n    \}\n    else if (108 == diagnosticMode)\n    \{\n        const float  wrapped_hue = wrap_hue(src.z);\n        const int    pos         = lookupLimitingCuspHue(wrapped_hue);\n        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);\n        const int    i           = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;\n\n        output = float3(float(pos), pos + t, float(i));\n    \}\n    else if (109 == diagnosticMode)\n    \{\n        int index = clamp(int(src.z), 0, totalTableSize);\n        float hue = hueTable\[index];\n        output = float3(float(index), hue, hue);\n    \}\n    else if (110 == diagnosticMode)\n    \{\n        const float wrapped_hue  = wrap_hue(src.z);\n        const int   pos          = lookupLimitingCuspHue(wrapped_hue);\n        const float t            = limiting_lerp_fraction(wrapped_hue, pos);\n        const float computed_hue = lerp(hueTable\[pos - 1], hueTable\[pos], t);\n        output = float3(computed_hue, wrapped_hue, src.z);\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_Peak Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Kernel_Limiting primaries" {{params.limiting_primaries}}
  "ACES_DRT_Kernel_Limiting Whitepoint" {{params.limiting_whitepoint}}
  "ACES_DRT_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name DRT
  selected true
  xpos 228
  ypos 85
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_limiter.blink
  recompileCount 222
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise 7487a34904160a1d2d4333cb1ceb64e5312c7856e9e5e054a0b0edbe91fa1f78 2 \"src\" Read Point \"dst\" Write Point 12 \"Direction\" Bool 1 AA== \"Limiting Primaries\" Int 1 AwAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Limiting Whitepoint\" Int 1 AgAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Limiting Peak Luminance\" Float 1 AADIQg== \"Clamp to limiting space\" Bool 1 AQ== \"White point scale\" Bool 1 AQ== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 12 \"invert\" 1 1 \"limitingPrimaries\" 1 1 \"encodingPrimaries\" 1 1 \"limitingWhite\" 1 1 \"encodingWhite\" 1 1 \"limitingLuminance\" 1 1 \"limitClamp\" 1 1 \"whitepoint_scale\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 5 \"XYZ_to_limiting_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"limiting_RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"white_scaling_factor\" Float 1 1 AAAAAA== \"white_scaled\" Bool 1 1 AA== \"has_effect\" Bool 1 1 AA=="
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int limitingPrimaries;\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int limitingWhite;\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float limitingLuminance;\n\n  bool limitClamp;\n  bool whitepoint_scale;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  float3x3 XYZ_to_limiting_RGB;\n  float3x3 limiting_RGB_to_XYZ;\n\n  float white_scaling_factor;\n  bool white_scaled;\n  bool has_effect;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(limitingLuminance, \"Limiting Peak Luminance\", 100.0f);\n    defineParam(limitingPrimaries, \"Limiting Primaries\", 3);\n    defineParam(limitingWhite, \"Limiting Whitepoint\", 2);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(limitClamp, \"Clamp to limiting space\", true);\n    defineParam(whitepoint_scale, \"White point scale\", true);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n \}\n\n  void init()\n  \{\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(limitingPrimaries, custom_primaries, temp_primaries);\n    const float2 limiting_whitepoint = get_whitepoint(limitingWhite, custom_white);\n    limiting_RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_limiting_RGB = limiting_RGB_to_XYZ.invert();\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2   encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    const float3x3 XYZ_to_encoding_RGB = RGBPrimsToXYZMatrix(temp_primaries, limiting_whitepoint, 1.0f, INVERSE);\n\n    // Scale to fit maximum creative white channel value\n    const float3 creativeWhiteXYZ = vector_dot(limiting_RGB_to_XYZ, float3(1.0f));\n    const float3 creativeWhiteRGB = vector_dot(XYZ_to_encoding_RGB, creativeWhiteXYZ);\n    const float  max_channel      = max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    white_scaling_factor          = (whitepoint_scale) ? 1.0f / max_channel : 1.0f; // TODO: add scaling into reencoding matrix?\n    white_scaled                  = (white_scaling_factor != 1.0f);\n\n    has_effect = white_scaled;\n    if (!invert)\n    \{\n      has_effect |= limitClamp;\n    \}\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  inline float3 xyz_to_limiting(const float3 XYZ)\n  \{\n    return vector_dot(XYZ_to_limiting_RGB, XYZ);\n  \}\n\n  inline float3 limiting_to_xyz(const float3 RGB)\n  \{\n    return vector_dot(limiting_RGB_to_XYZ, RGB);\n  \}\n\n  inline float3 apply_limiting_clamp(float3 RGB)\n  \{\n    if (limitClamp)\n    \{\n      RGB = clamp(RGB, float3\{0.0f\}, float3\{limitingLuminance\});\n    \}\n    return RGB;\n  \}\n\n  inline float3 apply_whitepoint_scale(float3 RGB)\n  \{\n    if (white_scaled)\n    \{\n      RGB *= white_scaling_factor;\n    \}\n    return RGB;\n  \}\n\n  inline float3 remove_whitepoint_scale(float3 RGB)\n  \{\n    RGB /= white_scaling_factor;\n    return RGB;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 out(source.x, source.y, source.z);\n\n    if (has_effect)\n    \{\n      if (invert)\n      \{\n        out = xyz_to_limiting(out);\n        out = remove_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n      else\n      \{\n        out = xyz_to_limiting(out);\n        out = apply_limiting_clamp(out);\n        out = apply_whitepoint_scale(out);\n        out = limiting_to_xyz(out);\n      \}\n    \}\n\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Encoding_Kernel_Limiting Primaries" {{params.limiting_primaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.OutPrimaries}}
  "ACES_DRT_Encoding_Kernel_Limiting Whitepoint" {{params.limiting_whitepoint}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.OutWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Limiting Peak Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Encoding_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Encoding_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  rebuild_finalise ""
  name Limiter
  xpos 228
  ypos 121
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 49
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise d407b657fc53735f2f291700a119d5c16ced367b1196a70bff1962726d996fba 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"normalisingFactor\" Float 1 1 AAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  // 6: Gamma 2.2\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n\n  float normalisingFactor;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n\n    normalisingFactor = referenceLuminance;\n    if (encoding == 5)\n      normalisingFactor = 10000.0f;\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(const float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(const float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(const float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(const float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(const float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(const float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(const float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(const float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(const float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d);\n  \}\n\n  float3 linear_to_ST2084(const float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v), st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(const int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n    else if (encoding == 6)\n    \{\n      v = pow(v, float3\{2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * normalisingFactor;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v /= normalisingFactor;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n    else if (encoding == 6)\n    \{\n      return pow(v, float3\{1.0f / 2.2f\});\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction true
  ACES_DRT_Encoding_Kernel_Encoding {{parent.OutEncoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.OutPrimaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.OutWhitepoint}}
  "ACES_DRT_Encoding_Kernel_Reference Luminance" {{parent.params.peakLuminance}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {{parent.params.custom_red} {parent.params.custom_red}}
  "ACES_DRT_Encoding_Kernel_Custom Green" {{parent.params.custom_green} {parent.params.custom_green}}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {{parent.params.custom_blue} {parent.params.custom_blue}}
  "ACES_DRT_Encoding_Kernel_Custom White" {{parent.params.custom_white} {parent.params.custom_white}}
  rebuild_finalise ""
  name Encode
  xpos 228
  ypos 157
 }
 Output {
  name Output1
  xpos 228
  ypos 224
 }
 StickyNote {
  inputs 0
  name params
  label "params\n"
  xpos 339
  ypos 12
  addUserKnob {20 User}
  addUserKnob {4 limiting_whitepoint l "Limiting Gamut" M {"Illuminant E" ACES D65 DCI Custom "" ""}}
  limiting_whitepoint D65
  addUserKnob {4 limiting_primaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom ""}}
  limiting_primaries "Rec.709  (sRGB)"
  addUserKnob {20 Custom n 1}
  addUserKnob {12 custom_red l "Custom red"}
  custom_red {0.6399999857 0.3300000131}
  addUserKnob {12 custom_green l "Custom Green"}
  custom_green {0.3000000119 0.6000000238}
  addUserKnob {12 custom_blue l "Custom Blue"}
  custom_blue {0.150000006 0.05999999866}
  addUserKnob {12 custom_white l "Custom White"}
  custom_white {0.3127000034 0.3289999962}
  addUserKnob {20 endGroup n -1}
  addUserKnob {7 peakLuminance l Peak R 10 10000}
  peakLuminance 100
 }
end_group
