set cut_paste_input [stack 0]
version 14.1 v3
push $cut_paste_input
Group {
 name ACESDRT
 selected true
 xpos 120
 ypos -111
 addUserKnob {20 User}
 addUserKnob {41 ACES_DRT_Kernel_Invert l Invert T BlinkScript1.ACES_DRT_Kernel_Invert}
 addUserKnob {41 "ACES_DRT_Kernel_Peak Luminance" l "Peak Luminance" T "BlinkScript1.ACES_DRT_Kernel_Peak Luminance"}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile T BlinkScript1.recompile}
 addUserKnob {41 "ACES_DRT_Kernel_Disagnostics Mode" l "Disagnostics Mode" T "BlinkScript1.ACES_DRT_Kernel_Disagnostics Mode"}
}
 Input {
  inputs 0
  name Input1
  xpos 130
  ypos -203
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 7
  ypos -187
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 130
  ypos -163
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT.blink
  recompileCount 204
  ProgramGroup 1
  KernelDescription "3 \"ACES_DRT_Kernel\" iterate pixelWise 10833ac4288cb48e6ecd282a7155c62d3d628cfb8b79411fc31f1fd023bae94f 2 \"src\" Read Point \"dst\" Write Point 43 \"Invert\" Bool 1 AA== \"AP1 Clamp\" Bool 1 AQ== \"Peak Luminance\" Float 1 AADIQg== \"Limiting primaries\" Int 1 AgAAAA== \"Limiting Whitepoint\" Int 1 AQAAAA== \"Input Viewing Conditions\" Int 1 AQAAAA== \"Input Adapting  Luminance\" Float 1 AADIQg== \"Input Background Luminance\" Float 1 AACgQQ== \"Output Viewing Conditions\" Int 1 AQAAAA== \"Output Adapting  Luminance\" Float 1 AADIQg== \"Output Background Luminance\" Float 1 AACgQQ== \"User Surround Parameters\" Float 3 ZmZmPz0KFz9mZmY/AAAAAA== \"XYZ White Scaler\" Float 1 AADIQg== \"Disagnostics Mode\" Int 1 AAAAAA== \"Cusp Smoothing Factor\" Float 1 j8L1PQ== \"Cusp Smoothing Offset\" Float 2 AAAAAHE9ij4= \"Cusp Mid Blend\" Float 1 ZmamPw== \"Focus gain Blend\" Float 1 mpmZPg== \"Focus Adjust Gain\" Float 1 zcwMPw== \"Focus Distance\" Float 1 zcysPw== \"Focus Distance Scaling\" Float 1 AADgPw== \"Compression Function Parameters\" Float 4 AABAP83MjD9mZqY/AACAPw== \"LMS Red Primary\" Float 2 z2ZVP/ypMT4= \"LMS Green Primary\" Float 2 ZaoYQJyiu78= \"LMS Blue Primary\" Float 2 Di2yPQAAAL4= \"LMS White Primary\" Float 2 q6qqPquqqj4= \"chroma_compress\" Float 1 mpkZQA== \"chroma_compress_fact\" Float 1 MzNTQA== \"chroma_expand\" Float 1 ZmamPw== \"chroma_expand_fact\" Float 1 16MwPw== \"chroma_expand_thr\" Float 1 AAAAPw== \"Lower Hull Gamma\" Float 1 heuRPw== \"Upper Hull Gamma\" Float 1 AACAPw== \"Disable per hue Upper Hull Computation\" Bool 1 AA== \"Disable per hue Lower Hull Computation\" Bool 1 AQ== \"aces_ts_n_r\" Float 1 AADIQg== \"aces_ts_g\" Float 1 MzOTPw== \"aces_ts_c\" Float 1 7FE4Pg== \"aces_ts_c_d\" Float 1 PzUgQQ== \"aces_ts_w_g\" Float 1 KVwPPg== \"aces_ts_t_1\" Float 1 CtcjPQ== \"aces_ts_r_hit_min\" Float 1 AAAAQw== \"aces_ts_r_hit_max\" Float 1 AABgRA== 43 \"invert\" 1 1 Default \"AP1Clamp\" 1 1 Default \"_peakLuminance\" 1 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"_inputViewingConditions\" 1 1 Default \"L_A_in\" 1 1 Default \"Y_b_in\" 1 1 Default \"_outputViewingConditions\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default \"_userSurround\" 3 1 Default \"_XYZ_w_scaler\" 1 1 Default \"diagnosticMode\" 1 1 Default \"_smoothCusps\" 1 1 Default \"_smoothOffset\" 2 1 Default \"_cuspMidBlend\" 1 1 Default \"_focusGainBlend\" 1 1 Default \"_focusAdjustGain\" 1 1 Default \"_focusDistance\" 1 1 Default \"_focusDistanceScaling\" 1 1 Default \"_compressionFuncParams\" 4 1 Default \"LMS_rxy\" 2 1 Default \"LMS_gxy\" 2 1 Default \"LMS_bxy\" 2 1 Default \"LMS_wxy\" 2 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"aces_ts_n_r\" 1 1 Default \"aces_ts_g\" 1 1 Default \"aces_ts_c\" 1 1 Default \"aces_ts_c_d\" 1 1 Default \"aces_ts_w_g\" 1 1 Default \"aces_ts_t_1\" 1 1 Default \"aces_ts_r_hit_min\" 1 1 Default \"aces_ts_r_hit_max\" 1 1 Default 41 \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"achromatic_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"a_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"b_weights\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"surround\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"F_L\" Float 1 2 AAAAAAAAAAA= \"z\" Float 1 2 AAAAAAAAAAA= \"D_RGB\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"A_w\" Float 1 2 AAAAAAAAAAA= \"y_to_j_A_w\" Float 1 2 AAAAAAAAAAA= \"chromatic_adapt_scale\" Float 1 2 AAAAAAAAAAA= \"limitingGamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"limitingGamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"reachGamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"inputWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"clamped_smoothness\" Float 1 1 AAAAAA== \"smooth_cusp_scale\" Float 2 1 AAAAAAAAAAA= \"_focusDist\" Float 1 1 AAAAAA== \"_midJ\" Float 1 1 AAAAAA== \"_limitJmax\" Float 1 1 AAAAAA== \"_model_gamma\" Float 1 1 AAAAAA== \"_compr\" Float 1 1 AAAAAA== \"_sat\" Float 1 1 AAAAAA== \"_sat_thr\" Float 1 1 AAAAAA== \"aces_ts_n\" Float 1 1 AAAAAA== \"aces_ts_u\" Float 1 1 AAAAAA== \"aces_ts_m\" Float 1 1 AAAAAA== \"aces_ts_c_t\" Float 1 1 AAAAAA== \"aces_ts_s_2\" Float 1 1 AAAAAA== \"aces_ts_u_2\" Float 1 1 AAAAAA== \"aces_ts_m_2\" Float 1 1 AAAAAA== \"referenceLuminance\" Float 1 1 AAAAAA=="
  kernelSource "kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  // Toggle Inverse Transform\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  bool AP1Clamp;\n\n  // Target Peak Luminance\n  float _peakLuminance;\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int _inputViewingConditions;\n  float L_A_in;\n  float Y_b_in;\n\n  int _outputViewingConditions;\n  float L_A_out;\n  float Y_b_out;\n\n  float3 _userSurround;\n\n  float  _XYZ_w_scaler;\n\n\n  // Diagnostic path modes\n#define COMPILE_DIAGNOSTICS\n\n#define APPLY_DRT 0\n\n#ifdef COMPILE_DIAGNOSTICS\n\n#define FORWARDS_clamp_to_AP1 1\n#define FORWARDS_XYZ_to_JMh 2\n#define FORWARDS_forwardTonescale 3\n#define FORWARDS_compressChroma 4\n#define FORWARDS_gamutMapper 5\n#define FORWARDS_JMh_to_XYZ 6\n\n#define INVERSE_XYZ_to_JMh 11\n#define INVERSE_gamutMapper 12\n#define INVERSE_inverseTonescale 13\n#define INVERSE_compressChroma 14\n#define INVERSE_JMh_to_XYZ 15\n\n#define DEBUG_limitingGamutCuspTable 50\n#define DEBUG_cgamutCuspTable 51\n#define DEBUG_limitingGamutGammas 52\n#define DEBUG_reachGamutCuspTable 53\n\n#endif\n\n  int diagnosticMode;\n\n  float  _smoothCusps;\n  float2 _smoothOffset;\n  float  _cuspMidBlend;\n\n  float _focusGainBlend;\n  float _focusAdjustGain;\n  float _focusDistance;\n  float _focusDistanceScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 _compressionFuncParams;\n\n  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;\n\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n\n  float lowerHullGamma;\n  float upperHullGamma;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n\n  // aces_ts Curve (ACES2 candidate) parameters\n  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)\n  float aces_ts_g;         // surround / contrast\n  float aces_ts_c;         // scene-referred grey\n  float aces_ts_c_d;       // display-referred grey (in nits)\n  float aces_ts_w_g;       // grey change between different peak luminance\n  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float aces_ts_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float aces_ts_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\nlocal:\n#define SOURCE_CONDITIONS  0\n#define DISPLAY_CONDITIONS 1\n#define NUMBER_CONDITIONS  2\n\n#define PRIMARIES_AP0 0\n#define PRIMARIES_AP1 1\n#define PRIMARIES_Rec709 2\n#define PRIMARIES_Rec2020 3\n#define PRIMARIES_P3D65 4\n#define PRIMARIES_P3DCI 5\n\n  float3x3 identity_matrix;\n\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n\n  float3 achromatic_weights;\n  float3 a_weights;\n  float3 b_weights;\n\n  float3x3 panlrcm;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 RGB_to_XYZ_limit;\n\n  // Model Nonlinearity 'constants'\n#define nl_gamma     0.42f\n#define nl_normalise 100.0f\n#define nl_scale     400.0f\n#define nl_offset    27.13f\n#define nl_d_scale   nl_gamma * nl_scale * nl_offset\n\n  float3 surround\[NUMBER_CONDITIONS];\n  //bool   HK_mode\[NUMBER_CONDITIONS];\n  float  F_L\[NUMBER_CONDITIONS];\n  float  z\[NUMBER_CONDITIONS];\n  float3 D_RGB\[NUMBER_CONDITIONS];\n  float  A_w\[NUMBER_CONDITIONS];\n  float  y_to_j_A_w\[NUMBER_CONDITIONS];\n  float  chromatic_adapt_scale\[NUMBER_CONDITIONS];\n\n#define gamutCuspTableSize 360\n\n  // Adds an extra entry to wrap the hues without branching\n  // Non-uniform in h\n  float3 limitingGamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n\n  // Uniform\n  float2 limitingGamutGammas\[gamutCuspTableSize + 1];\n  float3 reachGamutCuspTable\[gamutCuspTableSize + 1];\n\n  float3 inputWhite;\n  float3 limitWhite;\n\n  float  clamped_smoothness;\n  float2 smooth_cusp_scale;\n  float _focusDist;\n  float _midJ;\n  float _limitJmax;\n  float _model_gamma;\n\n  // Chroma compression pre-calculated constants\n  float _compr;   // Compression TODO rename\n  float _sat;     // Saturation TODO rename\n  float _sat_thr; // Threshold to start expanding saturation\n\n  float aces_ts_n;         // peak white\n  float aces_ts_u;\n  float aces_ts_m;\n  float aces_ts_c_t;\n  float aces_ts_s_2;\n  float aces_ts_u_2;\n  float aces_ts_m_2;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance; // TODO: reference only for tonescale curve\n                            // can it be factored in or removed (is it duplicated)\n \n  void define()\n  \{\n    defineParam(invert, \"Invert\", FORWARDS);\n\n    defineParam(AP1Clamp, \"AP1 Clamp\", true);\n\n    defineParam(_peakLuminance, \"Peak Luminance\", 100.0f);\n    defineParam(primariesLimit, \"Limiting primaries\", 2);\n    defineParam(whiteLimit, \"Limiting Whitepoint\", 1);\n\n    defineParam(_inputViewingConditions, \"Input Viewing Conditions\", 1);\n    defineParam(L_A_in, \"Input Adapting  Luminance\", 100.0f);\n    defineParam(Y_b_in, \"Input Background Luminance\", 20.0f);\n    defineParam(_outputViewingConditions, \"Output Viewing Conditions\", 1);\n    defineParam(L_A_out, \"Output Adapting  Luminance\", 100.0f);\n    defineParam(Y_b_out, \"Output Background Luminance\", 20.0f);\n    defineParam(_userSurround, \"User Surround Parameters\", float3(0.9, 0.59, 0.9));\n\n    defineParam(_XYZ_w_scaler, \"XYZ White Scaler\", 100.0f);\n\n    defineParam(diagnosticMode, \"Disagnostics Mode\", APPLY_DRT);\n    \n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothCusps, \"Cusp Smoothing Factor\", 0.12f);\n    defineParam(_smoothOffset, \"Cusp Smoothing Offset\", float2(0.0f, 0.27f));\n    defineParam(_cuspMidBlend, \"Cusp Mid Blend\", 1.3f);\n\n    defineParam(_focusGainBlend, \"Focus gain Blend\", 0.3f);\n    defineParam(_focusAdjustGain, \"Focus Adjust Gain\", 0.55f);\n    defineParam(_focusDistance, \"Focus Distance\", 1.35f);\n    defineParam(_focusDistanceScaling, \"Focus Distance Scaling\", 1.75f);\n\n    defineParam(_compressionFuncParams, \"Compression Function Parameters\", float4(0.75f, 1.1f, 1.3f, 1.0f)); // TODO: do we use all of them?\n    defineParam(LMS_rxy, \"LMS Red Primary\", float2(0.8336f,  0.1735f));\n    defineParam(LMS_gxy, \"LMS Green Primary\", float2(2.3854f, -1.4659f));\n    defineParam(LMS_bxy, \"LMS Blue Primary\", float2(0.087f , -0.125f));\n    defineParam(LMS_wxy, \"LMS White Primary\", float2(0.3333333333333f,  0.3333333333333f));\n\n    // TODO: improve user facing labels\n    defineParam(chroma_compress, \"chroma_compress\", 2.4f);\n    defineParam(chroma_compress_fact, \"chroma_compress_fact\", 3.3f);\n    defineParam(chroma_expand, \"chroma_expand\", 1.3f);\n    defineParam(chroma_expand_fact, \"chroma_expand_fact\", 0.69f);\n    defineParam(chroma_expand_thr, \"chroma_expand_thr\", 0.5f);\n\n    defineParam(lowerHullGamma, \"Lower Hull Gamma\", 1.14f);\n    defineParam(upperHullGamma, \"Upper Hull Gamma\", 1.0f);\n    defineParam(disableLowerHullGamma, \"Disable per hue Lower Hull Computation\", true);\n    defineParam(disableUpperHullGamma, \"Disable per hue Upper Hull Computation\", false);\n\n    // aces_ts Curve (ACES2 candidate) parameters\n    defineParam(aces_ts_n_r, \"aces_ts_n_r\", 100.0f);             // Normalized white in nits (what 1.0 should be)\n    defineParam(aces_ts_g, \"aces_ts_g\", 1.15f);                  // surround / contrast\n    defineParam(aces_ts_c, \"aces_ts_c\", 0.18f);                  // scene-referred 18% grey\n    defineParam(aces_ts_c_d, \"aces_ts_c_d\", 10.013f);            // display-referred 18^grey (in nits)\n    defineParam(aces_ts_w_g, \"aces_ts_w_g\", 0.14f);              // grey change between different peak luminance\n    defineParam(aces_ts_t_1, \"aces_ts_t_1\", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it\n    defineParam(aces_ts_r_hit_min, \"aces_ts_r_hit_min\", 128.0f); // Scene-referred value \"hitting the roof\" at 100 nits\n    defineParam(aces_ts_r_hit_max, \"aces_ts_r_hit_max\", 896.0f); // Scene-referred value \"hitting the roof\" at 10,000 nits\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (PRIMARIES_AP0 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_AP1 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_Rec709 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, FORWARDS);\n    \}\n    else if (PRIMARIES_Rec2020 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3D65 == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f,\n                                 FORWARDS);\n    \}\n    else if (PRIMARIES_P3DCI == which)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, FORWARDS);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm(float ra, float ba)\n  \{\n    achromatic_weights = float3(ra, 1.0f, ba);\n    a_weights          = float3(11.0f, -12.0f, 1.0f) / 11.0f;\n    b_weights          = float3(1.0f, 1.0f, -2.0f) / 9.0f;\n    // clang-format off\n    float panlrcm_data\[]=\n    \{\n      achromatic_weights.x, achromatic_weights.y, achromatic_weights.z,\n      a_weights.x, a_weights.y, a_weights.z, \n      b_weights.x, b_weights.y, b_weights.z,\n    \};\n    // clang-format on\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = (460.0f / panlrcm\[i]\[0]) / 1403.0f;\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int condition)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (condition == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (condition == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (condition == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (condition == 3)\n    \{\n      // Pull from external input\n      newSurround = _userSurround;\n    \}\n    return newSurround;\n  \}\n\n  float2 get_whitepoint(int which)\n  \{\n    if (which == 0)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which == 1)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n\n    return  float2(0.333333f, 0.333333f);\n  \}\n\n  void init_matrices()\n  \{\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy, 1.0f, FORWARDS);\n    CAT_CAT16 = CAT_CAT16_INVERSE.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(PRIMARIES_AP1);\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix = get_whitepoint(whiteLimit);\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001f, -0.077f);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, FORWARDS);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    const float3 white(1.0f, 1.0f, 1.0f);\n    inputWhite = vector_dot(AP1_to_XYZ, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.\n  \}\n\n  void init_chroma_compression(float log_peak)\n  \{\n    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number\n    _sat_thr = chroma_expand_thr / aces_ts_n;\n  \}\n\n  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)\n  \{\n    return 1.48f + sqrt(Y_background / Y_white);\n  \}\n\n  void init_gamut_mapper(float log_peak)\n  \{\n    clamped_smoothness  = max(0.000001f, _smoothCusps);\n    smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;\n\n    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    \n    _midJ = XYZ_to_JMh(limitWhite * aces_ts_c_t * aces_ts_n, DISPLAY_CONDITIONS).x;\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white\n    _limitJmax = display_linear_RGB_to_JMh(float3(_peakLuminance), RGB_to_XYZ_limit).x;\n    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  void initialise_cusp_table(float3 * output_table, const int table_size, const float3x3& matrix, const float luminance)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f)) * float3(luminance);\n      tempTableUnsorted\[i] = display_linear_RGB_to_JMh(RGB, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 * tableUnsorted, const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 * output_table, const int table_size, const float limitJ, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_display_linear_RGB(float3(limitJ, high, hue), matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_display_linear_RGB(float3(limitJ, sampleM, hue), matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma,\n                                     const float midJ, const float cuspMidBlend, const float limitJmax,\n                                     const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    const float2 estimated_hull_gammas = float2(1.0f / topGamma, 1.0f / lowerHullGamma);\n    const float  focusJ                = compute_focusJ(JMcusp, midJ, cuspMidBlend, limitJmax);\n\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain = compute_slope_gain(testJmh\[testIndex].x, JMcusp.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_display_linear_RGB(approximate_JMh, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma(const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        limitingGamutGammas\[i].x = 1.0f / upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      limitingGamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = limitingCuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high,\n                                                    midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma,\n                                                   midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      limitingGamutGammas\[i].x = 1.0f / testGamma;\n    \}\n    // Wrap the last entry\n    limitingGamutGammas\[gamutCuspTableSize] = limitingGamutGammas\[0];\n  \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma,\n                                     const float midJ, const float cuspMidBlend, const float limitJmax,\n                                     const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, 1.0f / bottomGamma);\n    const float  focusJ                = lerp(JMcusp.x, midJ, cuspMidBlend); // TODO: different\n\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain = compute_slope_gain(testJmh\[testIndex].x, JMcusp.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, clamped_smoothness, estimated_hull_gammas);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_display_linear_RGB(approximate_JMh, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma(const float midJ, const float cuspMidBlend, const float limitJmax,\n                                   const float focusDist, const float focusGainBlend, const float focusAdjustGain)\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        limitingGamutGammas\[i].y = 1.0f / lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      limitingGamutGammas\[i].y    = -5.0f;\n      const float2 JMcusp = limitingCuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high,\n                                                   midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma,\n                                                   midJ, cuspMidBlend, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      limitingGamutGammas\[i].y = 1.0f / testGamma;\n    \}\n  \}\n\n  inline float degree_of_adaptation(float F, float _L_A)\n  \{\n    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));\n    return D;\n  \}\n\n  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK, bool discountIlluminant, int stage)\n  \{\n    surround\[stage] = viewingConditionsToSurround(conditions);\n    //HK_mode\[stage]  = HK;\n\n    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);\n\n    // # Computing degree of adaptation :math:`D`.\n    if (!discountIlluminant)\n    \{\n      float D      = clamp(degree_of_adaptation(surround\[stage].x, _L_A), 0, 1);\n      D_RGB\[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;\n    \}\n    else\n    \{\n      D_RGB\[stage] = XYZ_w_scaled.y / RGB_w;\n    \}\n\n    const float k  = 1.0f / (5.0f * _L_A + 1.0f);\n    const float k4 = k * k * k * k;\n    F_L\[stage]     = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);\n\n    z\[stage] = compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);\n\n    // # Computing achromatic responses for the whitepoint.\n    const float3 RGB_wc = D_RGB\[stage] * RGB_w;\n     // Needs to use original as we have not setup alternates at this point\n     // Assumes White falls on the original curve\n    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, stage);\n    A_w\[stage]          = dot(achromatic_weights, RGB_aw);\n\n    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?\n    const float F_L_W = pow(F_L\[stage], nl_gamma);\n    y_to_j_A_w\[stage] = (nl_scale * F_L_W) / (nl_offset + F_L_W);\n\n    // TODO check if this dot product reduction is good enough, check different white points\n    chromatic_adapt_scale\[stage] = CAT_CAT16\[1]\[0] / D_RGB\[stage].x + CAT_CAT16\[1]\[1] / D_RGB\[stage].y + CAT_CAT16\[1]\[2] / D_RGB\[stage].z;\n  \}\n\n  void init()\n  \{\n    referenceLuminance = 100.0f;\n\n    init_tonescale_constants(_peakLuminance);\n\n    const float log_peak = log10(aces_ts_n / aces_ts_n_r);\n\n    init_matrices();\n\n    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS);\n    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS);\n\n    init_chroma_compression(log_peak);\n    init_gamut_mapper(log_peak);\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, AP1_to_XYZ, _peakLuminance); // TODO: Does peakLuminance make sense?\n    initialise_reach_cusp_table(reachGamutCuspTable, gamutCuspTableSize, _limitJmax, XYZ_to_AP1);\n    initialise_cusp_table(limitingGamutCuspTable, gamutCuspTableSize, RGB_to_XYZ_limit, _peakLuminance);\n    initialise_upper_hull_gamma(_midJ, _cuspMidBlend, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain);\n    initialise_lower_hull_gamma(_midJ, _cuspMidBlend, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain);\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  float3 clamp_to_AP1(float3 XYZ)\n  \{\n    if (AP1Clamp)\n    \{\n      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);\n      RGB.x      = max(0.0f, RGB.x);\n      RGB.y      = max(0.0f, RGB.y);\n      RGB.z      = max(0.0f, RGB.z);\n      XYZ        = vector_dot(AP1_to_XYZ, RGB);\n    \}\n    return XYZ;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, int stage)\n  \{\n    const float3 F_L_RGB = pow(F_L\[stage] / nl_normalise * fabs(RGB), float3(nl_gamma, nl_gamma, nl_gamma));\n    const float3 RGB_c   = (nl_scale * sign(RGB) * F_L_RGB) / (nl_offset + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, int stage)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * nl_normalise / F_L\[stage] * pow((nl_offset * absRGB) / (nl_scale - absRGB), \n                                                                      float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));\n    return RGB_p;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  inline float eccentricity_factor(float hr, bool apply_eccentricity)\n  \{\n    if (!apply_eccentricity)\n    \{\n        return 1.0f;\n    \}\n\n    // Hellwig2022/Helles2023\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)\n    const float _2_hr = 2 * hr;\n    const float _3_hr = 3 * hr;\n    const float _4_hr = 4 * hr;\n    // clang-format off\n    return (\n        - 0.0582f * cos(_1_hr)\n        - 0.0258f * cos(_2_hr)\n        - 0.1347f * cos(_3_hr)\n        + 0.0289f * cos(_4_hr)\n        - 0.1475f * sin(_1_hr)\n        - 0.0308f * sin(_2_hr)\n        + 0.0385f * sin(_3_hr)\n        + 0.0096f * sin(_4_hr)\n        + 1.0f\n      );\n    // clang-format on\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround // TODO\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  //\n  inline float J_from_Achromatic(float A, int conditions)\n  \{\n    return sign(A) * nl_normalise * pow(fabs(A) / A_w\[conditions], surround\[conditions].y * z\[conditions]);\n  \}\n  inline float Achromatic_from_J(float J, int conditions)\n  \{\n    return sign(J) * A_w\[conditions] * pow(fabs(J) / nl_normalise, 1.0f / (surround\[conditions].y * z\[conditions]));\n  \}\n\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, int conditions)\n  \{\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB\[conditions] * RGB; // TODO: combine with CAT16\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, conditions);\n\n    // # Step 6 and Step 4\n    // # Computing achromatic responses for the stimulus.\n    // # Converting to preliminary cartesian coordinates.\n    // basically a 3x3 matrix\n\n    const float A = dot(achromatic_weights, RGB_a);\n    const float a = dot(a_weights, RGB_a);\n    const float b = dot(b_weights, RGB_a);\n\n    // # Computing the *hue* angle\n    const float hr = atan2(b, a);\n    const float h  = wrap_to_360(degrees(hr));\n\n    // # Step 7\n    // # Computing the correlate of *Lightness*\n    float J = J_from_Achromatic(A, conditions);\n\n    //if (HK_mode\[conditions])\n    //\{\n    //  // # Computing the correlate of *chroma*\n    //  const float C = 35.0f * M / A_w\[conditions];\n    //  J = sqrt(J * J + 66.0f * C);\n    //\}\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness*\n    const float et = eccentricity_factor(hr, false);\n    float       M  = 43.0f * surround\[conditions].z * et * sqrt(a * a + b * b);\n\n    if (J == 0.0f) // TODO: is this needed?\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    float       J  = JMh.x;\n    const float M  = JMh.y;\n    const float hr = radians(JMh.z);\n\n    // # *HelmholtzKohlrausch* Effect Extension.\n    //if (HK_mode\[conditions])\n    //\{\n    //  const float C = (M * 35.0f) / A_w\[conditions];\n    //  J             = sqrt(J * J - 66.0f * C);\n    //\}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    const float A = Achromatic_from_J(J, conditions);\n\n    // # Computing *P_p_1* to *P_p_2*.\n    const float et    = eccentricity_factor(hr, false);\n    const float P_p_1 = 43.0f * et * surround\[conditions].z;\n    const float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions\n    const float gamma = M / P_p_1;\n    const float a     = gamma * cos(hr);\n    const float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    const float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b));\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, conditions);\n\n    // # Step 6\n    const float3 RGB = RGB_c / D_RGB\[conditions];\n\n    // # Step 7\n    const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, int conditions)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, conditions);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, int conditions)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, conditions);\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0f) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n\n  float2 limitingCuspFromTable(float wrapped_hue)\n  \{\n    float3 lo;\n    float3 hi;\n    if (wrapped_hue <= limitingGamutCuspTable\[0].z)\n    \{\n      lo   = limitingGamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = limitingGamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize; // Allowed as we have extra entry in the table\n      int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (wrapped_hue > limitingGamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = limitingGamutCuspTable\[high_i - 1];\n      hi = limitingGamutCuspTable\[high_i];\n    \}\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  // TODO: retest passing in table to search in.\n  float2 ccuspFromTable(float wrapped_hue)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (wrapped_hue <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize; // Allowed as we have extra entry in the table\n      int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (wrapped_hue > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 hueDependantHullGammas(float wrapped_hue)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = wrapped_hue - base_hue;\n\n    return lerp(limitingGamutGammas\[i_lo], limitingGamutGammas\[i_lo + 1], t);\n  \}\n\n  float cReachFromTable(float wrapped_hue)\n  \{\n    const int i_lo = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize);\n\n    const float3 lo = reachGamutCuspTable\[i_lo];\n    const float3 hi = reachGamutCuspTable\[i_lo + 1]; // Valid as we have added 1 to table length\n\n    const float t = (wrapped_hue - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  inline float getFocusGain(float J, float cuspJ, float limitJmax, float focusGainBlend, float focusAdjustGain)\n  \{\n    const float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J <= thr)\n      return 1.0f; // Analytic inverse possible below cusp // TODO is this comment correct\n\n    // Approximate inverse required above threshold // TODO\n    float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n   \}\n\n  inline float compute_slope_gain(float J, float cuspJ, float limitJmax, float focusDist, float focusGainBlend, float focusAdjustGain)\n  \{\n    return limitJmax * focusDist * getFocusGain(J, cuspJ, limitJmax, focusGainBlend, focusAdjustGain);\n  \}\n\n// reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a = JM.y / (focusJ * slope_gain);\n    float b;\n    float c;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    const float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      return 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      return 2.0f * c / (-b + root);\n    \}\n  \}\n\n  float3 getReachBoundary(float3 Jmh, float2 JMcusp_raw, float reachMaxM, float midJ, float cuspMidBlend, float limitJmax,\n                          float focusDist, float focusGainBlend, float focusAdjustGain, float model_gamma)\n  \{\n    float  focusJ     = compute_focusJ(JMcusp_raw, midJ, cuspMidBlend, limitJmax);\n    float  slope_gain = compute_slope_gain(Jmh.x, JMcusp_raw.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n    float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n    float  slope;\n    if (intersectJ < focusJ)\n    \{\n      slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n    \}\n    else\n    \{\n      slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n    \}\n    Jmh.y = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n    return Jmh;\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float2 estimated_hull_gammas)\n  \{\n    float2      JM_source    = float2(JMh_s.x, JMh_s.y);\n    const float gamma_top    = estimated_hull_gammas.x;\n    const float gamma_bottom = estimated_hull_gammas.y;\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    float slope;\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp) * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), gamma_top)\n      / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  float3 gamutMapper2(float3 JMh, bool direction, float Jx, float limitJmax, float focusDist, float focusGainBlend, float focusAdjustGain,\n                      float2 JMcusp, float focusJ, float cuspMidBlend, float2 estimated_hull_gammas, float smoothness, float reachMaxM, float midJ, float model_gamma)\n  \{\n    const float2 project_from = float2(JMh.x, JMh.y);\n\n    // Calculate where the out of gamut color is projected to\n    const float  slope_gain    = compute_slope_gain(Jx, JMcusp.x, limitJmax, focusDist, focusGainBlend, focusAdjustGain);\n    const float3 ganutBoundary = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothness, estimated_hull_gammas);\n    const float2 JMboundary    = float2(ganutBoundary.x, ganutBoundary.y);\n    const float2 project_to    = float2(ganutBoundary.z, 0.0f);\n    const float  projectJ      = ganutBoundary.z;\n\n    // Get hue dependent compression parameters depend on J\n    const float3 JMh_boundary = float3(JMboundary.x, JMboundary.y, JMh.z);\n    const float  locusMax     = getReachBoundary(JMh_boundary, JMcusp, reachMaxM, midJ, cuspMidBlend,\n                                                 limitJmax, focusDist, focusGainBlend, focusAdjustGain, model_gamma).y;\n    const float  difference   = max(1.0001f, locusMax / JMboundary.y); // TODO: magic threshold?\n    const float  threshold    = max(_compressionFuncParams.x, 1.0f / difference);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed;\n\n    const float lowerMlimit = 0.0001f; // Testing a small value here // TODO\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)        // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, threshold, difference, _compressionFuncParams.w, direction);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f); // TODO: should this be lowerMlimit\n    \}\n    return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n  \}\n\n  inline float compute_focusJ(float2 JMCusp, float midJ, float cuspMidBlend, float limitJmax)\n  \{\n    return lerp(JMCusp.x, midJ, min(1.0f, cuspMidBlend - (JMCusp.x / limitJmax)));\n  \}\n\n  float3 gamutMapper(float3 JMh, bool direction)\n  \{\n    // We compress M only so avoid mapping near zero\n    if (JMh.y == 0.0f) // TODO: should this be lowerMlimit\n      return JMh;\n\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    // Hue dependent, but as hue does not change we can compute them equally for both directions.\n    const float2 JMcusp                = limitingCuspFromTable(JMh.z);\n    const float2 JMcusp_smoothed       = JMcusp * smooth_cusp_scale;  // TODO; could this be baked in?\n    const float2 estimated_hull_gammas = hueDependantHullGammas(JMh.z);\n    const float  reachMaxM             = cReachFromTable(JMh.z);\n\n    // focus is Cusp dependent and thus hue\n    const float focusJ = compute_focusJ(JMcusp_smoothed, _midJ, _cuspMidBlend, _limitJmax);\n\n    float Jx = JMh.x;\n\n    if (INVERSE == direction)\n    \{\n      // Inverse path is a multi-step iterative to solve for the original 'J'\n      // Analytic inverse below threshold extra pass approximation above\n      if (Jx > lerp(JMcusp_smoothed.x, _limitJmax, _focusGainBlend)) // TODO check consistency with disableFocusGain\n        Jx = gamutMapper2(JMh, direction, Jx, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain,\n                          JMcusp_smoothed, focusJ, _cuspMidBlend, estimated_hull_gammas,\n                          clamped_smoothness, reachMaxM, _midJ, _model_gamma).x;\n    \}\n    return gamutMapper2(JMh, direction, Jx, _limitJmax, _focusDist, _focusGainBlend, _focusAdjustGain,\n                        JMcusp_smoothed, focusJ, _cuspMidBlend, estimated_hull_gammas,\n                        clamped_smoothness, reachMaxM, _midJ, _model_gamma);\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 display_linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix)\n  \{\n    const float3 XYZ = vector_dot(matrix, RGB);\n    const float3 JMh = XYZ_to_JMh(XYZ, DISPLAY_CONDITIONS); // TODO\n    return JMh;\n  \}\n\n  float3 JMh_to_display_linear_RGB(float3 JMh, const float3x3& matrix)\n  \{\n    const float3 XYZ = JMh_to_XYZ(JMh, DISPLAY_CONDITIONS); // TODO\n    const float3 RGB = vector_dot(matrix, XYZ);\n    return RGB;\n  \}\n\n  void init_tonescale_constants(float peakLuminance)\n  \{\n    // pre-calculate aces_ts  constants\n    aces_ts_n = peakLuminance;\n    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_n / aces_ts_n_r) / log(10000.0f / 100.0f));\n    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;\n    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));\n    aces_ts_u                  = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);\n    aces_ts_m                  = aces_ts_m_1 / aces_ts_u;\n    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);\n    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;\n    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));\n    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);\n    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;\n    aces_ts_s_2                = aces_ts_w_2 * aces_ts_m_1;\n    aces_ts_u_2                = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);\n    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;\n  \}\n\n  // ACES Tonescale function, proposed by Daniele Siragusano\n  inline float aces_ts_fwd(float Y)\n  \{\n    Y       = Y / referenceLuminance;\n    float f = aces_ts_m_2 * pow(max(0.0f, Y) / (Y + aces_ts_s_2), aces_ts_g);\n    float h = max(0.0f, f * f / (f + aces_ts_t_1));\n    return h * aces_ts_n;\n  \}\n\n  inline float aces_ts_rev(float Y)\n  \{\n    Y       = Y / aces_ts_n;\n    Y       = max(0.0f, min(aces_ts_n / (aces_ts_u_2 * aces_ts_n_r), Y)); // TODO: precompute?\n    float h = (Y + sqrt(Y * (4.0f * aces_ts_t_1 + Y))) / 2.0f;\n    float f = aces_ts_s_2 / (pow((aces_ts_m_2 / h), (1.0f / aces_ts_g)) - 1.0f);\n    return f * referenceLuminance;\n  \}\n\n  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model\n  inline float Y_to_Hellwig_J(float Y, int stage)\n  \{\n    const float F_L_Y = pow(F_L\[stage] * fabs(Y) / nl_normalise, nl_gamma);\n    return sign(Y) * nl_normalise * pow(((nl_scale * F_L_Y) / (nl_offset + F_L_Y)) / y_to_j_A_w\[stage], surround\[stage].y * z\[stage]);\n  \}\n\n  inline float Hellwig_J_to_Y(float J, int stage)\n  \{\n    const float A = y_to_j_A_w\[stage] * pow(fabs(J) / nl_normalise, 1.0f / (surround\[stage].y * z\[stage]));\n    return sign(J) * nl_normalise / F_L\[stage] * pow((nl_offset * A) / (nl_scale - A), 1.0f / nl_gamma); // TODO: fix me\n  \}\n\n  float3 forwardTonescale(float3 inputJMh, int conditions)\n  \{\n    float  linear        = Hellwig_J_to_Y(inputJMh.x, conditions);\n    float  luminanceTS   = aces_ts_fwd(linear);\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, conditions);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    return tonemappedJMh;\n  \}\n\nfloat3 inverseTonescale(float3 JMh, int conditions)\n  \{\n    float3 untonemappedColourJMh = JMh;\n    float  luminance             = Hellwig_J_to_Y(untonemappedColourJMh.x, conditions);\n    float  linear                = aces_ts_rev(luminance);\n    untonemappedColourJMh.x      = Y_to_Hellwig_J(linear, conditions);\n\n    return untonemappedColourJMh;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f); // TODO; majic constant\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, bool inverse, float limitJmax, float model_gamma,\n                          float sat, float sat_thr, float compr)\n  \{\n    // Assumes 'h' component is wrapped \[0.0, 360.0)\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = ccuspFromTable(JMh.z).y;\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!inverse)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      // Normalize M with the rendering space cusp M\n      M /= Mnorm;\n\n      // Expand the colorfulness by running the toe function in reverse.  The goal is to\n      // expand less saturated colors less and more saturated colors more.  The expansion\n      // increases saturation in the shadows and mid-tones but not in the highlights.\n      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n      // the toe less aggressive near black to reduce the expansion of noise.\n      M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n      // Compress the colorfulness.  The goal is to compress less saturated colors more and\n      // more saturated colors less, especially in the highlights.  This step creates the\n      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n      // mostly affects highlights and mid-tones, and does not compress shadows.\n      M = toe(M, limit, nJ * compr, snJ, 0);\n\n      // Denormalize\n      M *= Mnorm;\n    \}\n    else\n    \{\n      M /= Mnorm;\n      M = toe(M, limit, nJ * compr, snJ, 1);\n      M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n      M *= Mnorm;\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 compressChroma(float3 JMh, float originalJ, bool inverse)\n  \{\n    JMh.y = chromaCompression(JMh, originalJ, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);\n    if (inverse)\n      JMh.x = originalJ;\n    return JMh;\n  \}\n\n  float3 apply_DRT(float3 src)\n  \{\n    float3 JMh;\n    float3 tonemappedJMh;\n    float3 compressedJMh;\n    float3 gamutMappedJMh;\n    float3 output;\n\n     if (invert)\n      \{\n        gamutMappedJMh = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n        compressedJMh  = gamutMapper(gamutMappedJMh, INVERSE);\n        tonemappedJMh  = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);\n        JMh            = compressChroma(compressedJMh, tonemappedJMh.x, INVERSE);\n        output         = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);\n      \}\n      else\n      \{\n        float3 clamped = clamp_to_AP1(src);\n        JMh            = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);\n        tonemappedJMh  = forwardTonescale(JMh, SOURCE_CONDITIONS);\n        compressedJMh  = compressChroma(tonemappedJMh, JMh.x, FORWARDS);\n        gamutMappedJMh = gamutMapper(compressedJMh, FORWARDS);\n        output         = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);\n      \}\n    return output;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    const float3 src(source.x, source.y, source.z);\n    float3 output;\n\n#ifdef COMPILE_DIAGNOSTICS\n    if (APPLY_DRT == diagnosticMode)\n    \{\n        output = apply_DRT(src);\n    \}\n    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)\n    \{\n        output = clamp_to_AP1(src);\n    \}\n    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_forwardTonescale == diagnosticMode)\n    \{\n        output = forwardTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (FORWARDS_compressChroma == diagnosticMode)\n    \{\n        float3 JMh = inverseTonescale(src, SOURCE_CONDITIONS);\n        output     = compressChroma(src, JMh.x, FORWARDS);\n    \}\n    else if (FORWARDS_gamutMapper == diagnosticMode)\n    \{\n        output = gamutMapper(src, FORWARDS);\n    \}\n    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_XYZ_to_JMh == diagnosticMode)\n    \{\n        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);\n    \}\n    else if (INVERSE_gamutMapper == diagnosticMode)\n    \{\n        output = gamutMapper(src, INVERSE);\n    \}\n    else if (INVERSE_inverseTonescale == diagnosticMode)\n    \{\n        output = inverseTonescale(src, SOURCE_CONDITIONS);\n    \}\n    else if (INVERSE_compressChroma == diagnosticMode)\n    \{\n        float3 tonemappedJMh = forwardTonescale(src, SOURCE_CONDITIONS);\n        output               = compressChroma(src, tonemappedJMh.x, INVERSE);\n    \}\n    else if (INVERSE_JMh_to_XYZ == diagnosticMode)\n    \{\n        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);\n    \}\n    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)\n    \{\n        float2 cusp = limitingCuspFromTable(src.z);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_cgamutCuspTable == diagnosticMode)\n    \{\n        float2 cusp = ccuspFromTable(src.z);\n        output = float3(cusp.x, cusp.y, src.z);\n    \}\n    else if (DEBUG_limitingGamutGammas == diagnosticMode)\n    \{\n        float2 gammas = hueDependantHullGammas(src.z);\n        output = float3(gammas.x, gammas.y, src.z);\n    \}\n    else if (DEBUG_reachGamutCuspTable == diagnosticMode)\n    \{\n        float reachM = cReachFromTable(src.z);\n        output = float3(reachM, src.y, src.z);\n    \}\n    else\n    \{\n        output = src;\n    \}\n#else\n    output = apply_DRT(src);\n#endif\n    dst() = float4(output.x, output.y, output.z, source.w);\n  \}\n\};\n"
  rebuild ""
  "ACES_DRT_Kernel_User Surround Parameters" {0.8999999762 0.5899999738 0.8999999762}
  "ACES_DRT_Kernel_Cusp Smoothing Offset" {0 0.2700000107}
  "ACES_DRT_Kernel_Compression Function Parameters" {0.75 1.100000024 1.299999952 1}
  "ACES_DRT_Kernel_LMS Red Primary" {0.8335999846 0.1735000014}
  "ACES_DRT_Kernel_LMS Green Primary" {2.385400057 -1.465899944}
  "ACES_DRT_Kernel_LMS Blue Primary" {0.0869999975 -0.125}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 130
  ypos -110
 }
 Output {
  name Output1
  xpos 130
  ypos -10
 }
end_group
