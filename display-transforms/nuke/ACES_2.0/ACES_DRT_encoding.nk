set cut_paste_input [stack 0]
version 13.2 v8
push $cut_paste_input
Group {
 name ACES_DRT_Encoding
 selected true
 xpos 29
 ypos -26
 addUserKnob {20 User}
 addUserKnob {4 Direction M {Decode Encode}}
 addUserKnob {26 gamut l Gamut}
 addUserKnob {4 whitepoint l Whitepoint M {"Illuminant E" ACES D65 DCI Custom ""}}
 whitepoint D65
 addUserKnob {4 primaries l "" -STARTLINE M {XYZ AP0-ACES AP1-ACES "Rec.709  (sRGB)" Rec.2020 P3 Custom "" ""}}
 primaries AP0-ACES
 addUserKnob {20 Custom n 1}
 Custom 0
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Red" l "Custom Red" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Red"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Green" l "Custom Green" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Green"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom Blue" l "Custom Blue" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom Blue"}
 addUserKnob {41 "ACES_DRT_Encoding_Kernel_Custom White" l "Custom White" T "BlinkScript1.ACES_DRT_Encoding_Kernel_Custom White"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {7 referenceLuminance l "Reference Luminance" R 0 200}
 referenceLuminance 100
 addUserKnob {4 encoding l Encoding M {Linear ACEScct sRGB "BT.1886 (Gamma 2.4)" "Gamma 2.6" ST2084 ""}}
 encoding "BT.1886 (Gamma 2.4)"
}
 Input {
  inputs 0
  name Input1
  xpos 228
  ypos -39
 }
 Constant {
  inputs 0
  channels rgb
  format "256 256 0 0 256 256 1 square_256"
  name Constant1
  xpos 105
  ypos 1
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input]"}}
  name Switch1
  xpos 228
  ypos 25
 }
 BlinkScript {
  kernelSourceFile /mnt/scratch/kwheatle/git/output-transforms-dev/display-transforms/nuke/ACES_2.0/ACES_DRT_encoding.blink
  recompileCount 2
  ProgramGroup 1
  KernelDescription "2 \"ACES_DRT_Encoding_Kernel\" iterate pixelWise 1cfaa3a822b03436da1775b3e3decd81bf0946208da757282b0a18f3f259677d 2 \"src\" Read Point \"dst\" Write Point 9 \"Direction\" Bool 1 AA== \"Encoding\" Int 1 AAAAAA== \"Encoding Primaries\" Int 1 AwAAAA== \"Encoding Whitepoint\" Int 1 AgAAAA== \"Reference Luminance\" Float 1 AADIQg== \"Custom Red\" Float 2 CtcjP8P1qD4= \"Custom Green\" Float 2 mpmZPpqZGT8= \"Custom Blue\" Float 2 mpkZPo/CdT0= \"Custom White\" Float 2 NxqgPrByqD4= 9 \"invert\" 1 1 \"encoding\" 1 1 \"encodingPrimaries\" 1 1 \"encodingWhite\" 1 1 \"referenceLuminance\" 1 1 \"custom_red\" 2 1 \"custom_green\" 2 1 \"custom_blue\" 2 1 \"custom_white\" 2 1 11 \"st2084_m_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_c_3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_1_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_m_2_d\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"st2084_L_p\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_to_RGB\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_DRT_Encoding_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n#define FORWARDS false\n#define INVERSE  true\n  bool invert;\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encoding;\n\n  // Primaries of the Input Image\n  // 0: XYZ\n  // 1: AP0-ACES\n  // 2: AP1-ACES\n  // 3: sRGB/Rec.709-D65\n  // 4: Rec.2020-D65\n  // 5: P3-D65\n  // 6: Custom\n  int encodingPrimaries;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: Illuminant E\n  // 1: ACES white\n  // 2: D65\n  // 3: DCI\n  // 4: Custom\n  // Could add others, or user white point\n  int encodingWhite;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  float2 custom_red;\n  float2 custom_green;\n  float2 custom_blue;\n  float2 custom_white;\n\nlocal:\n  // ST2084 vars\n  float3 st2084_m_1;\n  float3 st2084_m_2;\n  float3 st2084_c_1;\n  float3 st2084_c_2;\n  float3 st2084_c_3;\n  float3 st2084_m_1_d;\n  float3 st2084_m_2_d;\n  float3 st2084_L_p;\n\n  float3x3 XYZ_to_RGB;\n  float3x3 RGB_to_XYZ;\n  float3x3 identity_matrix;\n\n  void define()\n  \{\n    defineParam(invert, \"Direction\", false);\n    defineParam(encoding, \"Encoding\", 0);\n    defineParam(referenceLuminance, \"Reference Luminance\", 100.0f);\n    defineParam(encodingPrimaries, \"Encoding Primaries\", 3);\n    defineParam(encodingWhite, \"Encoding Whitepoint\", 2);\n    defineParam(custom_red, \"Custom Red\", float2(0.6400f, 0.3300f));\n    defineParam(custom_green, \"Custom Green\", float2(0.3000f, 0.6000f));\n    defineParam(custom_blue, \"Custom Blue\", float2(0.1500f, 0.0600f));\n    defineParam(custom_white, \"Custom White\", float2(0.3127f, 0.3290f));\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 primaries\[3], float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    const float2 r = primaries\[0];\n    const float2 g = primaries\[1];\n    const float2 b = primaries\[2];\n    const float2 w = wxy;\n\n    const float X = w.x * Y / w.y;\n    const float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    // clang-format off\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sg * g.x, Sb * b.x,\n      Sr * r.y, Sg * g.y, Sb * b.y,\n      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),\n    \};\n    // clang-format on\n\n    float3x3 newMatrix;\n    newMatrix.setArray(Mdata);\n\n    // return forward or inverse matrix\n    if (direction == FORWARDS)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == INVERSE)\n    \{\n      // create inverse matrix\n      float3x3 newMatrixInverse = newMatrix.invert();\n      return newMatrixInverse;\n    \}\n  \}\n\n  float2 get_whitepoint(int which_white, float2 custom)\n  \{\n    if (which_white == 1)\n    \{\n      return float2(0.32168f, 0.33767f);\n    \}\n    else if (which_white == 2)\n    \{\n      return float2(0.3127f, 0.3290f);\n    \}\n    else if (which_white == 3)\n    \{\n      return float2(0.3140f, 0.3510f);\n    \}\n    else if (which_white == 4)\n    \{\n      return custom;\n    \}\n\n    // Case 0 and default\n    return float2(1.0f / 3.0f, 1.0f / 3.0f);\n  \}\n\n  void get_primaries(const int primaries, const float2 custom\[3], float2 primaries_out\[3])\n  \{\n    if (primaries == 1)\n    \{\n      primaries_out\[0] = float2(0.7347f, 0.2653f);\n      primaries_out\[1] = float2(0.0000f, 1.0000f);\n      primaries_out\[2] = float2(0.0001f, -0.0770f);\n    \}\n    else if (primaries == 2)\n    \{\n      primaries_out\[0] = float2(0.7130f, 0.2930f);\n      primaries_out\[1] = float2(0.1650f, 0.8300f);\n      primaries_out\[2] = float2(0.1280f, 0.0440f);\n    \}\n    else if (primaries == 3)\n    \{\n      primaries_out\[0] = float2(0.6400f, 0.3300f);\n      primaries_out\[1] = float2(0.3000f, 0.6000f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 4)\n    \{\n      primaries_out\[0] = float2(0.7080f, 0.2920f);\n      primaries_out\[1] = float2(0.1700f, 0.7970f);\n      primaries_out\[2] = float2(0.1310f, 0.0460f);\n    \}\n    else if (primaries == 5)\n    \{\n      primaries_out\[0] = float2(0.6800f, 0.3200f);\n      primaries_out\[1] = float2(0.2650f, 0.6900f);\n      primaries_out\[2] = float2(0.1500f, 0.0600f);\n    \}\n    else if (primaries == 6)\n    \{\n      primaries_out\[0] = custom\[0];\n      primaries_out\[1] = custom\[1];\n      primaries_out\[2] = custom\[2];\n    \}\n    else\n    \{\n      // Case 0 and default\n      primaries_out\[0] = float2(1.0f, 0.0f);\n      primaries_out\[1] = float2(0.0f, 1.0f);\n      primaries_out\[2] = float2(0.0f, 0.0f);\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 100.0f; // Scale so 100 is 1.0f for Nuke\n\n    float2 temp_primaries\[3];\n    const float2 custom_primaries\[3] =\n    \{\n      custom_red, custom_green, custom_blue\n    \};\n\n    get_primaries(encodingPrimaries, custom_primaries, temp_primaries);\n    const float2 encoding_whitepoint = get_whitepoint(encodingWhite, custom_white);\n    RGB_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, encoding_whitepoint, 1.0f, FORWARDS);\n    XYZ_to_RGB = RGB_to_XYZ.invert();\n \}\n\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : pow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  float3 sRGB_to_linear3(float3 v)\n  \{\n    return float3\{sRGB_to_linear(v.x), sRGB_to_linear(v.y), sRGB_to_linear(v.z)\};\n  \}\n\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055f * (pow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 linear_to_sRGB3(float3 v)\n  \{\n    return float3\{linear_to_sRGB(v.x), linear_to_sRGB(v.y), linear_to_sRGB(v.z)\};\n  \}\n\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? pow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  float3 ACEScct_to_linear3(float3 v)\n  \{\n    return float3\{ACEScct_to_linear(v.x), ACEScct_to_linear(v.y), ACEScct_to_linear(v.z)\};\n  \}\n\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  float3 linear_to_ACEScct3(float3 v)\n  \{\n    return float3\{linear_to_ACEScct(v.x), linear_to_ACEScct(v.y), linear_to_ACEScct(v.z)\};\n  \}\n\n  float3 ST2084_to_linear(float3 v)\n  \{\n    float3 V_p = pow(v, st2084_m_2_d);\n    return pow((max(float3\{0.0f, 0.0f, 0.0f\}, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  float3 linear_to_ST2084(float3 v)\n  \{\n    float3 Y_p = pow(max(float3\{0.0f, 0.0f, 0.0f\}, v) / st2084_L_p, st2084_m_1);\n    return pow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  float3 encodingToLuminance(int encoding, float3 v)\n  \{\n    if (encoding == 1)\n    \{\n      v = ACEScct_to_linear3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      v = sRGB_to_linear3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      v = pow(v, float3\{2.4f, 2.4f, 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      v = pow(v, float3\{2.6f, 2.6f, 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      v = ST2084_to_linear(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v * referenceLuminance;\n  \}\n\n  float3 luminanceToEncoding(int encoding, float3 v)\n  \{\n    v = v / referenceLuminance;\n\n    if (encoding == 1)\n    \{\n      return linear_to_ACEScct3(v);\n    \}\n    else if (encoding == 2)\n    \{\n      return linear_to_sRGB3(v);\n    \}\n    else if (encoding == 3)\n    \{\n      return pow(v, float3\{1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f\});\n    \}\n    else if (encoding == 4)\n    \{\n      return pow(v, float3\{1.0f / 2.6f, 1.0f / 2.6f, 1.0f / 2.6f\});\n    \}\n    else if (encoding == 5)\n    \{\n      return linear_to_ST2084(v);\n    \}\n\n    // default Linear scaling to our reference Luminace\n    return v;\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot(float3x3 m, float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c != 3; ++c)\n    \{\n      r\[c] = m\[c]\[0] * v\[0] + m\[c]\[1] * v\[1] + m\[c]\[2] * v\[2];\n    \}\n\n    return r;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 input(source.x, source.y, source.z);\n    float3 RGB;\n    float3 out;\n\n    if (invert)\n    \{\n      RGB = vector_dot(XYZ_to_RGB, input);\n      out = luminanceToEncoding(encoding, RGB);\n    \}\n    else\n    \{\n      RGB = encodingToLuminance(encoding, input);\n      out = vector_dot(RGB_to_XYZ, RGB);\n    \}\n    dst() = float4(out.x, out.y, out.z, source.w);\n  \}\n\};\n"
  rebuild ""
  ACES_DRT_Encoding_Kernel_Direction {{parent.Direction}}
  ACES_DRT_Encoding_Kernel_Encoding {{parent.encoding}}
  "ACES_DRT_Encoding_Kernel_Encoding Primaries" {{parent.primaries}}
  "ACES_DRT_Encoding_Kernel_Encoding Whitepoint" {{parent.whitepoint}}
  "ACES_DRT_Encoding_Kernel_Custom Red" {0.6399999857 0.3300000131}
  "ACES_DRT_Encoding_Kernel_Custom Green" {0.3000000119 0.6000000238}
  "ACES_DRT_Encoding_Kernel_Custom Blue" {0.150000006 0.05999999866}
  "ACES_DRT_Encoding_Kernel_Custom White" {0.3127000034 0.3289999962}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 228
  ypos 74
 }
 Output {
  name Output1
  xpos 228
  ypos 149
 }
end_group
