kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>
{
  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image
  Image<eWrite>                            dst; // the output image

param:
  // Toggle Inverse Transform
#define FORWARDS false
#define INVERSE  true
  bool invert;

  bool AP1Clamp;

  // Target Peak Luminance
  float _peakLuminance;

  // Primaries of the Target Gamut
  // 0: AP0-ACES
  // 1: AP1-ACES
  // 2: sRGB/Rec.709-D65 # now just Rec.709
  // 3: Rec.2020-D65 # now just Rec.2020
  // 4: P3-D65 # now just P3
  // 5: P3-DCI # no longer included
  int primariesLimit;

  // White point of the limiting gamut
  // effectively the "creative white"
  // 0: ACES white
  // 1: D65
  // Could add others, or user white point
  int whiteLimit;

  // Viewing Conditions (for output)
  // 0: Dark
  // 1: Dim
  // 2: Average
  int _inputViewingConditions;
  float L_A_in;
  float Y_b_in;

  int _outputViewingConditions;
  float L_A_out;
  float Y_b_out;

  float3 _userSurround;

  float  _XYZ_w_scaler;


  // Diagnostic path modes
#define COMPILE_DIAGNOSTICS

#define APPLY_DRT 0

#ifdef COMPILE_DIAGNOSTICS

#define FORWARDS_clamp_to_AP1 1
#define FORWARDS_XYZ_to_JMh 2
#define FORWARDS_forwardTonescale 3
#define FORWARDS_compressChroma 4
#define FORWARDS_gamutMapper 5
#define FORWARDS_JMh_to_XYZ 6

#define INVERSE_XYZ_to_JMh 11
#define INVERSE_gamutMapper 12
#define INVERSE_inverseTonescale 13
#define INVERSE_compressChroma 14
#define INVERSE_JMh_to_XYZ 15

#define DEBUG_limitingGamutCuspTable 50
#define DEBUG_limitingGamutGammas 52
#define DEBUG_reachGamutCuspTable 53

#define DEBUG_limitingGamutCuspTableRaw 60
#define DEBUG_limitingGamutCuspTableRaw2 61
#define DEBUG_reachMTableRaw 62


#define DEBUG_Jconstants 70
#define DEBUG_FocusConstants 71
#define DEBUG_limitingFocusJ 72
#define DEBUG_reachMConditions 73

#define DEBUG_gamutCompressAlphaFORWARDS 80
#define DEBUG_gamutCompressAlphaINVERSE 81

#endif

  int diagnosticMode;

  float  _smoothCusps;
  float2 _smoothOffset;
  float  _cuspMidBlend;

  float _focusGainBlend;
  float _focusAdjustGain;
  float _focusDistance;
  float _focusDistanceScaling;

  // Gamut Compression Fuction Parameters
  // Threshold
  float _compressionFuncParams;

  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;

  float chroma_compress;
  float chroma_compress_fact;
  float chroma_expand;
  float chroma_expand_fact;
  float chroma_expand_thr;

  float lowerHullGamma;
  float upperHullGamma;
  bool  disableUpperHullGamma;
  bool  disableLowerHullGamma;

  // aces_ts Curve (ACES2 candidate) parameters
  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)
  float aces_ts_g;         // surround / contrast
  float aces_ts_c;         // scene-referred grey
  float aces_ts_c_d;       // display-referred grey (in nits)
  float aces_ts_w_g;       // grey change between different peak luminance
  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it
  float aces_ts_r_hit_min; // Scene-referred value "hitting the roof" at 100 nits
  float aces_ts_r_hit_max; // Scene-referred value "hitting the roof" at 10,000 nits

local:
#define SOURCE_CONDITIONS  0
#define DISPLAY_CONDITIONS 1
#define NUMBER_CONDITIONS  2

#define PRIMARIES_AP0 0
#define PRIMARIES_AP1 1
#define PRIMARIES_Rec709 2
#define PRIMARIES_Rec2020 3
#define PRIMARIES_P3D65 4
#define PRIMARIES_P3DCI 5

  float3x3 identity_matrix;

  float3x3 CAT_CAT16;
  float3x3 CAT_CAT16_INVERSE;

  float3 DL_weights[NUMBER_CONDITIONS];
  float3 DM_weights[NUMBER_CONDITIONS];
  float3 DS_weights[NUMBER_CONDITIONS];
  
  float3 DL_weights_inv[NUMBER_CONDITIONS];
  float3 DM_weights_inv[NUMBER_CONDITIONS];
  float3 DS_weights_inv[NUMBER_CONDITIONS];

  float3 achromatic_w;
  float3 a_w;
  float3 b_w;

  float3 achromatic_weights[NUMBER_CONDITIONS];
  float3 a_weights[NUMBER_CONDITIONS];
  float3 b_weights[NUMBER_CONDITIONS];

  float3 achromatic_weights_inv[NUMBER_CONDITIONS];
  float3 a_weights_inv[NUMBER_CONDITIONS];
  float3 b_weights_inv[NUMBER_CONDITIONS];

  float3x3 panlrcm;

  float3x3 AP1_to_XYZ;
  float3x3 XYZ_to_AP1;
  float3x3 XYZ_to_RGB_limit;
  float3x3 RGB_to_XYZ_limit;

  // Reference Luminance in Cd/sqm
#define referenceLuminance 100.0f

  // Model Nonlinearity 'constants'
#define nl_gamma     0.42f
#define nl_normalise 100.0f
#define nl_scale     400.0f
#define nl_offset    27.13f

#define j_scale      100.0f

  float3 surround[NUMBER_CONDITIONS];
  //bool   HK_mode[NUMBER_CONDITIONS];
  float  F_L[NUMBER_CONDITIONS];
  float3 D_RGB[NUMBER_CONDITIONS];
  float  A_w[NUMBER_CONDITIONS];
  float  y_to_j_A_w[NUMBER_CONDITIONS];

//#define USE_DEGREES
#ifdef USE_DEGREES
#define hue_limit 360.0f
#else
#define hue_limit (2 * PI)
#endif
#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range [0.0, hue_limit) needs to be a multiple of 6 to sample hull corners
#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases
#define totalTableSize gamutCuspTableSize + additonal_entries
#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle

#define gammaAccuracy 5e-6
#define gammaMinimum 0.4f
#define gammaMaximum 2.0f
#define gammaSearchStep 0.2f

  // Non-uniform in h
  float  hueTable[totalTableSize];
  float4 limitingGamutCuspTable[totalTableSize];    // { J, M, Upper gamma, Lower gamma }
  float2 reachMTable[totalTableSize];               // { reachCuspM, reachM }

// Note reuse of Hue channel 2
#define UPPER_GAMMA 2
#define LOWER_GAMMA 3

#define REACHCUSPM 0
#define REACHM 1

  float3 inputWhite;
  float3 limitWhite;

  float  clamped_smoothness;
  float2 smooth_cusp_scale;
  float _focusDist;
  float _midJ;
  float _limitJmax;
  float _model_gamma; // TODO: investigate uses of this
  float _base_slope;

  // Chroma compression pre-calculated constants
  float _compr;   // Compression TODO rename
  float _sat;     // Saturation TODO rename
  float _sat_thr; // Threshold to start expanding saturation

  float aces_ts_n;         // peak white
  float aces_ts_u;
  float aces_ts_m;
  float aces_ts_c_t;
  float aces_ts_s_2;
  float aces_ts_u_2;
  float aces_ts_m_2;
  float aces_ts_inv_upper_limit;

  void define()
  {
    defineParam(invert, "Invert", FORWARDS);

    defineParam(AP1Clamp, "AP1 Clamp", true);

    defineParam(_peakLuminance, "Peak Luminance", 100.0f);
    defineParam(primariesLimit, "Limiting primaries", 2);
    defineParam(whiteLimit, "Limiting Whitepoint", 1);

    defineParam(_inputViewingConditions, "Input Viewing Conditions", 1);
    defineParam(L_A_in, "Input Adapting Luminance", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white
    defineParam(Y_b_in, "Input Background Luminance", 20.0f); // Note these are rediculously wrong depends on viewing conditions
    defineParam(_outputViewingConditions, "Output Viewing Conditions", 1);
    defineParam(L_A_out, "Output Adapting Luminance", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white
    defineParam(Y_b_out, "Output Background Luminance", 20.0f); // Note these are rediculously wrong depends on viewing conditions
    defineParam(_userSurround, "User Surround Parameters", float3(0.9, 0.59, 0.9));

    defineParam(_XYZ_w_scaler, "XYZ White Scaler", 100.0f);

    defineParam(diagnosticMode, "Disagnostics Mode", APPLY_DRT);
    
    defineParam(_smoothCusps, "Cusp Smoothing Factor", 0.12f);
    defineParam(_smoothOffset, "Cusp Smoothing Offset", float2(0.0f, 0.27f));
    defineParam(_cuspMidBlend, "Cusp Mid Blend", 1.3f);

    defineParam(_focusGainBlend, "Focus gain Blend", 0.3f);
    defineParam(_focusAdjustGain, "Focus Adjust Gain", 0.55f);
    defineParam(_focusDistance, "Focus Distance", 1.35f);
    defineParam(_focusDistanceScaling, "Focus Distance Scaling", 1.75f);

    defineParam(_compressionFuncParams, "Compression Function Parameters", 0.75f);
    defineParam(LMS_rxy, "LMS Red Primary", float2(0.8336f,  0.1735f));
    defineParam(LMS_gxy, "LMS Green Primary", float2(2.3854f, -1.4659f));
    defineParam(LMS_bxy, "LMS Blue Primary", float2(0.087f , -0.125f));
    defineParam(LMS_wxy, "LMS White Primary", float2(1.0f / 3.0f, 1.0f / 3.0f));

    // TODO: improve user facing labels
    defineParam(chroma_compress, "chroma_compress", 2.4f);
    defineParam(chroma_compress_fact, "chroma_compress_fact", 3.3f);
    defineParam(chroma_expand, "chroma_expand", 1.3f);
    defineParam(chroma_expand_fact, "chroma_expand_fact", 0.69f);
    defineParam(chroma_expand_thr, "chroma_expand_thr", 0.5f);

    defineParam(lowerHullGamma, "Lower Hull Gamma", 1.14f);
    defineParam(upperHullGamma, "Upper Hull Gamma", 1.0f);
    defineParam(disableLowerHullGamma, "Disable per hue Lower Hull Computation", true);
    defineParam(disableUpperHullGamma, "Disable per hue Upper Hull Computation", false);

    // aces_ts Curve (ACES2 candidate) parameters
    defineParam(aces_ts_n_r, "aces_ts_n_r", 100.0f);             // Normalized white in nits (what 1.0 should be)
    defineParam(aces_ts_g, "aces_ts_g", 1.15f);                  // surround / contrast
    defineParam(aces_ts_c, "aces_ts_c", 0.18f);                  // scene-referred 18% grey
    defineParam(aces_ts_c_d, "aces_ts_c_d", 10.013f);            // display-referred 18^grey (in nits)
    defineParam(aces_ts_w_g, "aces_ts_w_g", 0.14f);              // grey change between different peak luminance
    defineParam(aces_ts_t_1, "aces_ts_t_1", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it
    defineParam(aces_ts_r_hit_min, "aces_ts_r_hit_min", 128.0f); // Scene-referred value "hitting the roof" at 100 nits
    defineParam(aces_ts_r_hit_max, "aces_ts_r_hit_max", 896.0f); // Scene-referred value "hitting the roof" at 10,000 nits
  }

  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)
  {
    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ
    // # based on CtlColorSpace.cpp from the CTL source code : 77
    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc
    // # param: Y - luminance of "white" - defaults to 1.0
    // # param: inverse - calculate XYZ to RGB instead

    float2 r = rxy;
    float2 g = gxy;
    float2 b = bxy;
    float2 w = wxy;

    float X = w.x * Y / w.y;
    float Z = (1 - w.x - w.y) * Y / w.y;

    // # Scale factors for matrix rows
    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);

    // clang-format off
    float Sr =    (X * (b.y - g.y) -      \
            g.x * (Y * (b.y - 1.0f) +  \
            b.y * (X + Z)) +       \
            b.x * (Y * (g.y - 1.0f) + \
            g.y * (X + Z))) / d ;

    float Sg =    (X * (r.y - b.y) +      \
            r.x * (Y * (b.y - 1.0f) +  \
            b.y * (X + Z)) -        \
            b.x * (Y * (r.y - 1.0f) +  \
            r.y * (X + Z))) / d ;

    float Sb =    (X * (g.y - r.y) -      \
            r.x * (Y * (g.y - 1.0f) +  \
            g.y * (X + Z)) +        \
            g.x * (Y * (r.y - 1.0f) +  \
            r.y * (X + Z))) / d ;

    // # Assemble the matrix
    float Mdata[] =
    {
      Sr * r.x, Sg * g.x, Sb * b.x,
      Sr * r.y, Sg * g.y, Sb * b.y,
      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),
    };
    // clang-format on

    float3x3 newMatrix;
    newMatrix.setArray(Mdata);

    // return forward or inverse matrix
    if (direction == FORWARDS)
    {
      return newMatrix;
    }
    else if (direction == INVERSE)
    {
      // create inverse matrix
      float3x3 newMatrixInverse = newMatrix.invert();
      return newMatrixInverse;
    }
  }

  float3x3 generate_RGB_to_XYZ_matrix(const int which)
  {
    if (PRIMARIES_AP0 == which)
    {
      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f,
                                 FORWARDS);
    }
    else if (PRIMARIES_AP1 == which)
    {
      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f,
                                 FORWARDS);
    }
    else if (PRIMARIES_Rec709 == which)
    {
      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, FORWARDS);
    }
    else if (PRIMARIES_Rec2020 == which)
    {
      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f,
                                 FORWARDS);
    }
    else if (PRIMARIES_P3D65 == which)
    {
      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f,
                                 FORWARDS);
    }
    else if (PRIMARIES_P3DCI == which)
    {
      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, FORWARDS);
    }
    else
    {
      return identity_matrix;
    }
  }

  // Generate the Hellwig2022 post adaptation non-linear compression matrix
  // that is used in the inverse of the model (JMh-to-XYZ).
  //
  // Original:
  //  460.0f, 451.0f, 288.0f,
  //  460.0f, -891.0f, -261.0f,
  //  460.0f, -220.0f, -6300.0f
  void generate_panlrcm(float ra, float ba)
  {
    achromatic_w = nl_scale * float3(ra, 1.0f, ba);
    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;
    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;

    panlrcm =  constuct_inverse_matrix(achromatic_w, a_w, b_w);

    for (int i = 0; i < 3; i++)
    {
      float n = (460.0f / panlrcm[i][0]) / 1403.0f;
      panlrcm[i][0] *= n / nl_scale;
      panlrcm[i][1] *= n / nl_scale;
      panlrcm[i][2] *= n / nl_scale;
    }
  }

  float3 viewingConditionsToSurround(int condition)
  {
    float3 newSurround;
    // hack to turn incoming int value into surround coeffs
    if (condition == 0)
    {
      // "Dark": InductionFactors_CIECAM02(0.8, 0.525, 0.8),
      newSurround = float3(0.8, 0.525, 0.8);
    }
    else if (condition == 1)
    {
      // "Dim": InductionFactors_CIECAM02(0.9, 0.59, 0.9),
      newSurround = float3(0.9, 0.59, 0.9);
    }
    else if (condition == 2)
    {
      // "Average": InductionFactors_CIECAM02(1, 0.69, 1),
      newSurround = float3(1.0, 0.69, 1.0);
    }
    else if (condition == 3)
    {
      // Pull from external input
      newSurround = _userSurround;
    }
    return newSurround;
  }

  float2 get_whitepoint(int which)
  {
    if (which == 0)
    {
      return float2(0.32168f, 0.33767f);
    }
    else if (which == 1)
    {
      return float2(0.3127f, 0.3290f);
    }

    return  float2(1.0f / 3.0f, 1.0f / 3.0f);
  }

  void init_matrices()
  {
    identity_matrix.setIdentity();

    CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy, 1.0f, FORWARDS);
    CAT_CAT16 = CAT_CAT16_INVERSE.invert();

    // AP1 matrix
    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(PRIMARIES_AP1);
    XYZ_to_AP1 = AP1_to_XYZ.invert();

    // populate the limiting primaries matrix
    // RGBPrimsToXYZMatrix
    float2 limitWhiteForMatrix = get_whitepoint(whiteLimit);
    float2 limitRedForMatrix;
    float2 limitGreenForMatrix;
    float2 limitBlueForMatrix;

    // TODO: could we share these primaries with matrix generation code?
    if (primariesLimit == 0)
    {
      limitRedForMatrix   = float2(0.7347f, 0.2653f);
      limitGreenForMatrix = float2(0.0f, 1.0f);
      limitBlueForMatrix  = float2(0.0001f, -0.077f);
    }
    else if (primariesLimit == 1)
    {
      limitRedForMatrix   = float2(0.713f, 0.293f);
      limitGreenForMatrix = float2(0.165f, 0.830f);
      limitBlueForMatrix  = float2(0.128f, 0.044f);
    }
    else if (primariesLimit == 2)
    {
      limitRedForMatrix   = float2(0.64f, 0.33f);
      limitGreenForMatrix = float2(0.3f, 0.6f);
      limitBlueForMatrix  = float2(0.15f, 0.06f);
    }
    else if (primariesLimit == 3)
    {
      limitRedForMatrix   = float2(0.708f, 0.292f);
      limitGreenForMatrix = float2(0.170f, 0.797f);
      limitBlueForMatrix  = float2(0.131f, 0.046f);
    }
    else if (primariesLimit == 4)
    {
      limitRedForMatrix   = float2(0.680f, 0.320f);
      limitGreenForMatrix = float2(0.265f, 0.690f);
      limitBlueForMatrix  = float2(0.150f, 0.060f);
    }
    else
    {
      limitRedForMatrix   = float2(1.0f, 0.0f);
      limitGreenForMatrix = float2(0.0f, 1.0f);
      limitBlueForMatrix  = float2(0.0f, 0.0f);
    }
    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, FORWARDS);
    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();

    const float3 white(1.0f, 1.0f, 1.0f);
    inputWhite = vector_dot(AP1_to_XYZ, white);
    limitWhite = vector_dot(RGB_to_XYZ_limit, white);

    generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.
  }

  void init_chroma_compression(float log_peak)
  {
    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;
    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number
    _sat_thr = chroma_expand_thr / aces_ts_n;
  }

  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)
  {
    return 1.48f + sqrt(Y_background / Y_white);
  }

  void init_gamut_mapper(float log_peak)
  {
    clamped_smoothness  = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?
    smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;

    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    
    _midJ = XYZ_to_JMh(limitWhite * aces_ts_c_t * aces_ts_n, DISPLAY_CONDITIONS).x;

    // calculate the maximum expected J & M values for the given limit gamut
    // these are used as limiting values for the gamut boundary searches
    // limitJmax (assumed to match limitRGB white)
    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white
    _limitJmax = linear_RGB_to_JMh(float3(_peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;
    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));
    _base_slope = _limitJmax * _focusDist;
  }

  // convert HSV cylindrical projection values to RGB
  float3 HSV_to_RGB(float3 HSV)
  {
    float C = HSV.z * HSV.y;
    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));
    float m = HSV.z - C;

    float3 RGB;
    RGB.x = (HSV.x < 1.0f / 6.0f     ? C
               : HSV.x < 2.0f / 6.0f ? X
               : HSV.x < 3.0f / 6.0f ? 0.0f
               : HSV.x < 4.0f / 6.0f ? 0.0f
               : HSV.x < 5.0f / 6.0f ? X
                                     : C)
      + m;
    RGB.y = (HSV.x < 1.0f / 6.0f     ? X
               : HSV.x < 2.0f / 6.0f ? C
               : HSV.x < 3.0f / 6.0f ? C
               : HSV.x < 4.0f / 6.0f ? X
               : HSV.x < 5.0f / 6.0f ? 0.0f
                                     : 0.0f)
      + m;
    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f
               : HSV.x < 2.0f / 6.0f ? 0.0f
               : HSV.x < 3.0f / 6.0f ? X
               : HSV.x < 4.0f / 6.0f ? C
               : HSV.x < 5.0f / 6.0f ? C
                                     : X)
      + m;
    return RGB;
  }

  void initialise_cusp_table(float4 * output_table, const float3x3& matrix, const float luminance, const int conditions)
  {
    // the 'tempTableUnsorted' table is populated
    // in increments of H of the limiting gamut HSV space starting at H=0.0
    // since it is unlikely that HSV.H=0 and JMh.h=0 line up
    // the entries are then wrap-around shifted
    // so that the 'gamutCuspTable' starts with the lowest JMh.h value
    const int table_size = gamutCuspTableSize;
    float4 tempTableUnsorted[gamutCuspTableSize];
    int    minhIndex = 0;
    for (int i = 0; i < table_size; ++i)
    {
      const float  hNorm   = float(i) / (table_size);
      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f)) * float3(luminance);
      const float3 cusp    = linear_RGB_to_JMh(RGB, matrix, conditions);
      tempTableUnsorted[i] = float4(cusp.x, cusp.y, cusp.z, 0.0f);
      if (tempTableUnsorted[i].z < tempTableUnsorted[minhIndex].z)
      {
        minhIndex = i;
      }
    }
    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex, baseIndex);

    // Copy extra entries to ease the code to handle hues wrapping around
    output_table[0]                              = output_table[baseIndex + gamutCuspTableSize - 1];
    output_table[baseIndex + gamutCuspTableSize] = output_table[baseIndex];

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    output_table[0].z = output_table[0].z - hue_limit;
    output_table[baseIndex + gamutCuspTableSize].z = output_table[baseIndex + gamutCuspTableSize].z + hue_limit;
  }

  void copy_table_rotated(float4 * tableUnsorted, const int tableSize, float4 output_table[], const int offsetIndex, const int baseOffset)
  {
    for (int i = 0; i < tableSize; ++i)
    {
      output_table[i+baseOffset] = tableUnsorted[(offsetIndex + i) % tableSize];
    }
  }

  void extract_hue_table(const float4 * table, float * hueTable)
  {
    for (int i = 0; i < totalTableSize; ++i)
    {
      hueTable[i] = table[i].z;
    }
  }

  void smooth_cusp_table(float4 * table, const float2 scale)
  {
    for (int i = 0; i < totalTableSize; ++i)
    {
      const float hue = hueTable[i];
      table[i].x           = table[i].x * scale.x;
      table[i].y           = table[i].y * scale.y;
    }
  }

  void precompute_reach_table(float2 * reachMTable, float4 * reach_table, const float limitJ, const float3x3& xyz_matrix, const float3x3& rgb_matrix, const int conditions)
  {
    for (int i = 0; i < totalTableSize; ++i)
    {
      const float hue = hueTable[i];

      reachMTable[i][REACHCUSPM] = compressionCuspFromTable(hue, reach_table).y; // Resample compression cusp for Disply hues save on extra binary search 
      reachMTable[i][REACHM]     = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);
    }
  }

  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)
  {
    const float search_range = 100.0;
    float low     = 0.0;
    float high    = low + search_range;
    bool  outside = false;

    while (!outside && high < 1400.0)
    {
      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));
      if (!outside)
      {
        low  = high;
        high = high + search_range;
      }
    }

    while ((high - low) > threshold)
    {
      const float sampleM = midpoint(low, high);
      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));
      if (outside)
      {
        high = sampleM;
      }
      else
      {
        low = sampleM;
      }
    }
    return high;
  }

  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)
  {
    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||
        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)
    {
      return true;
    }
    return false;
  }

  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,
                               const float cuspMidBlend, const float focusAdjustGain, const float2 estimated_hull_gammas, const int conditions)
  {
    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);
    const float analytical_threshold = compute_analytical_threshold(JMcusp.x);
    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);

    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);
    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);
    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);
    const float2 approxLimit =
        findGamutBoundaryIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);
    const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh.z);
    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);
    return newLimitRGB;
  }

  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh[], const int test_count, const float2 estimated_hull_gammas,
                                     const float limitJmax, const float base_slope, const float midJ,
                                     const float cuspMidBlend, const float focusAdjustGain,
                                     const float luminance, const int conditions)
  {
    for (int testIndex = 0; testIndex < test_count; ++testIndex)
    {
      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh[testIndex], limitJmax, base_slope,
                                                       midJ, cuspMidBlend, focusAdjustGain, estimated_hull_gammas, conditions);

      if (!outside_hull(newLimitRGB, luminance))
      {
        return false;
      }
    }
    return true;
  }

  void initialise_upper_hull_gamma(float4 * table, const float midJ, const float cuspMidBlend, const float limitJmax,
                                   const float base_slope, const float focusAdjustGain,
                                   const float luminance, const int conditions)
  {
    // Find upper hull gamma values for the gamut mapper
    // start by taking a h angle
    // get the cusp J value for that angle
    // find a J value halfway to the Jmax
    // iterate through gamma values until the approximate max M is negative through the actual boundary

    // positions between the cusp and Jmax we will check
    // variables that get set as we iterate through, once all are set to true we break the loop
    const int   test_count                = 3;
    const float testPositions[test_count] = {0.01f, 0.5f, 0.99f};
    const float fixed_gamma = 1.0f / upperHullGamma;
    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)
    {
      table[i][UPPER_GAMMA] = -1.0f;
      if (disableUpperHullGamma)
      {
        table[i][UPPER_GAMMA] = fixed_gamma;
        continue;
      }

      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working
      const float  hue                 = hueTable[i];
      const float4 cusp                = table[i];
      const float2 JMcusp              = float2(cusp.x, cusp.y);

      float3 testJmh[test_count];
      for (int testIndex = 0; testIndex < test_count; ++testIndex)
      {
        // create test values between the cusp and the Jmax
        testJmh[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions[testIndex]), JMcusp.y, hue);
      }

      const float search_range = gammaSearchStep;
      float       low          = gammaMinimum;
      float       high         = low + search_range;
      bool        all_inside   = true;

      while (all_inside && high < gammaMaximum)
      {
        const float2 estimated_hull_gammas = float2(high, 1.0f / lowerHullGamma);
        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,
                                             luminance, conditions);
        if (all_inside)
        {
          low  = high;
          high = high + search_range;
        }
      }

      float testGamma = -1.0;
      while ((high - low) > gammaAccuracy)
      {
        testGamma  = midpoint(low, high);
        const float2 estimated_hull_gammas = float2(testGamma, 1.0f / lowerHullGamma);
        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,
                                             luminance, conditions);
        if (!all_inside)
        {
          high = testGamma;
        }
        else
        {
          low = testGamma;
        }
      }
      table[i][UPPER_GAMMA] = testGamma;
    }
    // Wrap the end entries
    table[0] = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  inline bool any_below_zero(const float3 newLimitRGB)
  {
    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)
    {
      return true;
    }
    return false;
  }

  void initialise_lower_hull_gamma(float4 * table, const float midJ, const float cuspMidBlend, const float limitJmax,
                                   const float base_slope, const float focusAdjustGain,
                                   const float luminance, const int conditions)
  {
    // Same process, for the bottom hull gamma
    const int   test_count                = 3;
    const float testPositions[test_count] = {0.01f, 0.4f, 0.75f};
    const float fixed_gamma = 1.0f / lowerHullGamma;
    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)
    {
      if (disableLowerHullGamma)
      {
        table[i][LOWER_GAMMA] = fixed_gamma;
        continue;
      }

      table[i][LOWER_GAMMA]    = -5.0f;
      const float4 cusp   = table[i];
      const float2 JMcusp = float2(cusp.x, cusp.y);
      const float  hue    = hueTable[i];

      float3       testJmh[test_count];
      for (int testIndex = 0; testIndex < test_count; ++testIndex)
      {
        testJmh[testIndex] = float3(JMcusp.x * testPositions[testIndex], JMcusp.y, hue);
      }

      const float search_range = gammaSearchStep;
      float       low          = gammaMinimum;
      float       high         = low + search_range;
      bool        all_inside   = true;

      while (all_inside && high < gammaMaximum)
      {
        const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, high);
        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,
                                             luminance, conditions);
        if (all_inside)
        {
          low  = high;
          high = high + search_range;
        }
      }

      float testGamma = -1.0;
      while ((high - low) > gammaAccuracy)
      {
        testGamma  = midpoint(low, high);
        const float2 estimated_hull_gammas = float2(1.0f / upperHullGamma, testGamma);
        all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                             base_slope, midJ, cuspMidBlend, focusAdjustGain,
                                             luminance, conditions);
        if (!all_inside)
        {
          high = testGamma;
        }
        else
        {
          low = testGamma;
        }
      }
      table[i][LOWER_GAMMA] = testGamma;
    }
    table[0] = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  float replace_gamma_entry(float4 * table, int entry, int channel)
  {
    // Very simple patch up, try to find good values either side and lerp a new value
    int lower = entry - 1;
    while (lower >= 0)
    {
      if (!bad_gamma_value(table[lower][channel]))
        break;
      lower = lower - 1;
    }
    if (lower < 0)
      return -1.0f; // Give up if we can't find a good entry below

    int upper = entry + 1;
    while (upper < baseIndex + gamutCuspTableSize)
    {
      if (!bad_gamma_value(table[upper][channel]))
        break;
      upper = upper + 1;
    }
    if (upper == totalTableSize)
      return -2.0f; // Give up nothing above us

    float lower_hue = hueTable[lower];
    float upper_hue = hueTable[upper];
    float entry_hue = hueTable[entry];
    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);
    return lerp(table[lower][channel], table[upper][channel], lerp_loc);
  }

  bool bad_gamma_value(const float value)
  {
    return ((value <= 0.0f) || (value <= gammaMinimum+1e-2) || (value >= gammaMaximum-1e-2));
  }

  void repair_broken_gamma_values(float4 * table)
  {
    for (int i = baseIndex; i < baseIndex + gamutCuspTableSize; ++i)
    {
      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)
      {
        if (bad_gamma_value(table[i][channel]))
        {
          table[i][channel] = replace_gamma_entry(table, i, channel);
        }
      }
    }
    table[0] = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  inline float degree_of_adaptation(float F, float _L_A)
  {
    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));
    return D;
  }

  inline float3 extract_row(const float3x3 matrix, int row)
  {
    return {matrix[row][0], matrix[row][1], matrix[row][2]};
  }

  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)
  {
    return weight * extract_row(matrix, row);
  }

  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)
  {
    float3x3 matrix;
    matrix[0][0] = a.x;
    matrix[0][1] = a.y;
    matrix[0][2] = a.z;
    matrix[1][0] = b.x;
    matrix[1][1] = b.y;
    matrix[1][2] = b.z;
    matrix[2][0] = c.x;
    matrix[2][1] = c.y;
    matrix[2][2] = c.z;
    return matrix.invert();
  }

  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK, bool discountIlluminant, int stage)
  {
    surround[stage] = viewingConditionsToSurround(conditions);
    //HK_mode[stage]  = HK;

    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;

    // # Step 0
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);

    // # Computing degree of adaptation :math:`D`.
    if (!discountIlluminant)
    {
      float D      = clamp(degree_of_adaptation(surround[stage].x, _L_A), 0.0f, 1.0f);
      D_RGB[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;
    }
    else
    {
      D_RGB[stage] = XYZ_w_scaled.y / RGB_w;
    }

    const float k    = 1.0f / (5.0f * _L_A + 1.0f);
    const float k4   = k * k * k * k;
    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f); // TODO 0.2 * 5 ... pow(, s)
    F_L[stage]       = _F_L / nl_normalise;

    // # FWd Step 1
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    //float3 RGB = vector_dot(CAT_CAT16, XYZ);
    //float3 RGB_c = D_RGB[conditions] * RGB; // combine with CAT16

    // Pre weight CAT16 matrix by D
    DL_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].x, CAT_CAT16, 0);
    DM_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].y, CAT_CAT16, 1);
    DS_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].z, CAT_CAT16, 2);

    // # Inv Step 6
    //const float3 RGB = RGB_c / D_RGB[conditions];
    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);
    const float3x3 tempmat = constuct_inverse_matrix(DL_weights[stage], DM_weights[stage], DS_weights[stage]);
    DL_weights_inv[stage] = extract_row(tempmat, 0);
    DM_weights_inv[stage] = extract_row(tempmat, 1);
    DS_weights_inv[stage] = extract_row(tempmat, 2);

    // Prescale values
    surround[stage].y = surround[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);
    surround[stage].z = surround[stage].z * 43.0f;

    // # Computing achromatic responses for the whitepoint.
    const float3 RGB_wc = D_RGB[stage] * RGB_w;
     // Needs to use original as we have not setup alternates at this point
     // Assumes White falls on the original curve
    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L[stage] * RGB_wc);
    A_w[stage]          = dot(achromatic_w, RGB_aw);

    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?
    y_to_j_A_w[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);

    achromatic_weights[stage] = achromatic_w / A_w[stage];
    a_weights[stage]          = surround[stage].z * a_w;
    b_weights[stage]          = surround[stage].z * b_w;

    const float3 column_weights = float3(A_w[stage], 1.0f / surround[stage].z, 1.0f / surround[stage].z);
    achromatic_weights_inv[stage]   = extract_row(panlrcm, 0) * column_weights;
    a_weights_inv[stage]            = extract_row(panlrcm, 1) * column_weights;
    b_weights_inv[stage]            = extract_row(panlrcm, 2) * column_weights;
  }

  void init()
  {
    init_tonescale_constants(_peakLuminance);

    const float log_peak = log10(aces_ts_n / aces_ts_n_r);

    init_matrices();

    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS);
    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS);

    init_chroma_compression(log_peak);
    init_gamut_mapper(log_peak);

    initialise_cusp_table(limitingGamutCuspTable, RGB_to_XYZ_limit, _peakLuminance, DISPLAY_CONDITIONS);
    extract_hue_table(limitingGamutCuspTable, hueTable);
    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);
    initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _peakLuminance, DISPLAY_CONDITIONS);
    initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _peakLuminance, DISPLAY_CONDITIONS);
    repair_broken_gamma_values(limitingGamutCuspTable);

    float4 compressionGamutCuspTable[totalTableSize];
    initialise_cusp_table(compressionGamutCuspTable, AP1_to_XYZ, _peakLuminance, SOURCE_CONDITIONS);
    precompute_reach_table(reachMTable, compressionGamutCuspTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS);
  }

  // convert radians to degrees
  inline float degrees(float radians)
  {
    return radians * 180.0f / PI;
  }

#ifdef USE_DEGREES
  // convert degrees to radians
  inline float radians(float hue)
  {
    return hue / 180.0f * PI;
  }
#else
  inline float radians(float hue)
  {
    return hue;
  }
#endif

  inline float wrap_hue(float hue)
  {
    float y = fmod(hue, hue_limit);
    if (y < 0.0)
    {
      y = y + hue_limit;
    }
    return y;
  }

  // multiplies a 3D vector with a 3x3 matrix
  inline float3 vector_dot(const float3x3& m, const float3 v)
  {
    float3 r;
    for (int c = 0; c < 3; c++)
    {
      r[c] = m[c][0] * v.x + m[c][1] * v.y + m[c][2] * v.z;
    }

    return r;
  }

  float3 clamp_to_AP1(float3 XYZ)
  {
    if (AP1Clamp)
    {
      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);
      RGB        = clamp(RGB, float3{0.0f}, float3(16384.0f)); // limit to nice power of 2 above that needed to max out a 10000 Nit output transform
      XYZ        = vector_dot(AP1_to_XYZ, RGB);
    }
    return XYZ;
  }

  inline float _post_adaptation_non_linear_response_compression_forward(float L)
  {
    const float F_L_L = pow(L, float(nl_gamma));
    return F_L_L / (nl_offset + F_L_L);
  }

  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)
  {
    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));
    return F_L_RGB / (nl_offset + F_L_RGB);
  }

  inline float _post_adaptation_non_linear_response_compression_inverse(float A)
  {
    const float F_L_A = (nl_offset * A) / (1.0 - A);
    return pow(F_L_A, 1.0f / nl_gamma);
  }

  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)
  {
    const float3 F_L_RGB = (nl_offset * RGB) / (1.0 - RGB);
    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));
    return RGB_p;
  }

  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)
  {
    const float3 absRGB  = fabs(RGB);
    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);
    return RGB_c;
  }

  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)
  {
    const float3 absRGB  = fabs(RGB);
    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);
    return RGB_p;
  }

//  // Return compression gamut cusp M scaled with an eccentricity factor
//  inline float eccentricity_factor(float hr, bool apply_eccentricity)
//  {
//    if (!apply_eccentricity)
//    {
//        return 1.0f;
//    }
//
//    // Hellwig2022/Helles2023
//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg
//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)
//    const float _2_hr = 2 * hr;
//    const float _3_hr = 3 * hr;
//    const float _4_hr = 4 * hr;
//    // clang-format off
//    return (
//        - 0.0582f * cos(_1_hr)
//        - 0.0258f * cos(_2_hr)
//        - 0.1347f * cos(_3_hr)
//        + 0.0289f * cos(_4_hr)
//        - 0.1475f * sin(_1_hr)
//        - 0.0308f * sin(_2_hr)
//        + 0.0385f * sin(_3_hr)
//        + 0.0096f * sin(_4_hr)
//        + 1.0f
//      );
//    // clang-format on
//  }

  // XYZ to Hellwig2020 JMh
  //
  //     XYZ
  //         *CIE XYZ* tristimulus values of test sample / stimulus.
  //     XYZ_w
  //         *CIE XYZ* tristimulus values of reference white.
  //     L_A
  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken
  //         to be 20% of the luminance of a white object in the scene).
  //     Y_b
  //         Luminous factor of background :math:`Y_b` such as
  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the
  //         light source and :math:`L_b` is the luminance of the background. For
  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the
  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,
  //         approximate an :math:`L^*` of 50 is used.
  //     surround // TODO
  //         Surround viewing conditions induction factors.
  //         Truth value indicating if the illuminant should be discounted.
  //     discount_illuminant
  //
  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:
  //
  // - Custom primaries
  //
  inline float _J_from_Achromatic(float A, int conditions)
  {
    return j_scale * pow(A, surround[conditions].y);
  }

  inline float _Achromatic_from_J(float J, int conditions)
  {
    return pow(J / j_scale, 1.0f / surround[conditions].y);
  }

  inline float J_from_Achromatic(float A, int conditions)
  {
    return sign(A) * _J_from_Achromatic(fabs(A), conditions);
  }

  inline float Achromatic_from_J(float J, int conditions)
  {
    return sign(J) * _Achromatic_from_J(fabs(J), conditions);
  }

  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates
  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters
  float3 XYZ_to_JMh(float3 XYZ, int conditions)
  {
    float3 RGB_c;
    RGB_c.x = dot(DL_weights[conditions], XYZ);
    RGB_c.y = dot(DM_weights[conditions], XYZ);
    RGB_c.z = dot(DS_weights[conditions], XYZ);

    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);

    const float A = dot(achromatic_weights[conditions], RGB_a);
    const float a = dot(a_weights[conditions], RGB_a);
    const float b = dot(b_weights[conditions], RGB_a);

    // # Computing the *hue* angle
    const float hr = atan2(b, a);
#ifdef USE_DEGREES
    const float h  = wrap_hue(degrees(hr));
#else
    const float h  = wrap_hue(hr);
#endif

    // # Step 7
    // # Computing the correlate of *Lightness*
    float J = J_from_Achromatic(A, conditions);

    //if (HK_mode[conditions])
    //{
    //  // # Computing the correlate of *chroma*
    //  const float C = 35.0f * M / A_w[conditions];
    //  J = sqrt(J * J + 66.0f * C);
    //}

    // # Step 9
    // # Computing the correlate of *colourfulness*
    //const float et = eccentricity_factor(hr, false);
    //float       M  = surround[conditions].z * et * sqrt(a * a + b * b);
    float M = sqrt(a * a + b * b); // Valid as et == 1.0

    if (J == 0.0f) // TODO: is this needed?
      M = 0.0f;
    return {J, M, h};
  }

  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values
  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters
  float3 JMh_to_XYZ(float3 JMh, int conditions)
  {
    float       J  = JMh.x;
    const float M  = JMh.y;
    const float hr = radians(JMh.z);

    // # *Helmholtzâ€“Kohlrausch* Effect Extension.
    //if (HK_mode[conditions])
    //{
    //  const float C = (M * 35.0f) / A_w[conditions];
    //  J             = sqrt(J * J - 66.0f * C);
    //}

    // # Computing achromatic response :math:`A` for the stimulus.
    const float _A = Achromatic_from_J(J, conditions);

    // # Computing *P_p_1* to *P_p_2*.
    //const float et    = eccentricity_factor(hr, false);
    //const float P_p_1 = surround[conditions].z; // * et;
    //const float P_p_2 = A;

    // # Step 3
    // # Computing opponent colour dimensions
    const float gamma = M;
    const float a     = gamma * cos(hr);
    const float b     = gamma * sin(hr);

    // # Step 4
    // # Applying post-adaptation non-linear response compression matrix.
    const float3 Aab = float3(_A, a, b);
    //const float3 RGB_a = vector_dot(panlrcm, Aab);
    float3 RGB_a;
    RGB_a.x = dot(achromatic_weights_inv[conditions], Aab);
    RGB_a.y = dot(a_weights_inv[conditions], Aab);
    RGB_a.z = dot(b_weights_inv[conditions], Aab);

    // # Step 5
    // # Applying inverse post-adaptation non-linear response compression.
    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);

    float3 XYZ;
    XYZ.x = dot(DL_weights_inv[conditions], RGB_c);
    XYZ.y = dot(DM_weights_inv[conditions], RGB_c);
    XYZ.z = dot(DS_weights_inv[conditions], RGB_c);

    return XYZ;
  }

  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)
  {
    return int(wrapped_hue / hue_limit * table_size);
  }

  // linear interpolation between two values a & b with the bias t
  inline float lerp(float a, float b, float t)
  {
    return a + t * (b - a);
  }
  inline float2 lerp(float2 a, float2 b, float t)
  {
    return a + t * (b - a);
  }
  inline float3 lerp(float3 a, float3 b, float t)
  {
    return a + t * (b - a);
  }
  inline float4 lerp(float4 a, float4 b, float t)
  {
    return a + t * (b - a);
  }

  // Smooth minimum of a and b (cubic polynomial)
  float smin(float a, float b, float s)
  {
    float h = max(s - fabs(a - b), 0.0f) / s;
    return min(a, b) - h * h * h * s * (1.0f / 6.0f);
  }

  inline int midpoint(int low, int high)
  {
    return int((high + low) / 2); // Integer division
  }

  inline float midpoint(float low, float high)
  {
    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document
    return (high + low) * 0.5f;
  }

  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'
  // cusps are very expensive to compute
  // and the DRT is only using them for lightness mapping
  // which does not require a high degree of accuracy
  // so instead we use a pre-computed table of cusp points
  // sampled at 1 degree hue intervals of the the RGB target gamut
  // and lerp between them to get the approximate J & M values
  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates
  // the samples are spaced by HSV hue increments of the limiting RGB gamut
  // so to find the correct entry for a given CAM hue (h) value
  // one must search the table entries for the matching entry.z component

  int lookupLimitingCuspHue(float wrapped_hue)
  {
    int low_i  = 0;
    int high_i = baseIndex + gamutCuspTableSize; // Allowed as we have extra entries in the table
    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;

    while (low_i + 1 < high_i)
    {
      if (wrapped_hue > hueTable[i])
      {
        low_i = i;
      }
      else
      {
        high_i = i;
      }
      i = midpoint(low_i, high_i);
    }
    return high_i;
  }

  float limiting_lerp_fraction(float wrapped_hue, int pos)
  {
    return (wrapped_hue - hueTable[pos - 1])
          / (hueTable[pos] - hueTable[pos - 1]);
  }

  inline float4 limitingCuspFromTable(int pos, float t)
  {
    return lerp(limitingGamutCuspTable[pos - 1], limitingGamutCuspTable[pos], t);
  }

  float4 compressionCuspFromTable(float wrapped_hue, float4 * compressionGamutCuspTable)
  {
    // Avoid use within main pixel loop
    float4 lo;
    float4 hi;

    int low_i  = 0;
    int high_i = baseIndex + gamutCuspTableSize; // Allowed as we have extra entry in the table
    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;

    while (low_i + 1 < high_i)
    {
      if (wrapped_hue > compressionGamutCuspTable[i].z)
      {
        low_i = i;
      }
      else
      {
        high_i = i;
      }
      i = midpoint(low_i, high_i);
    }
    lo = compressionGamutCuspTable[high_i - 1];
    hi = compressionGamutCuspTable[high_i];

    float t = (wrapped_hue - lo.z) / (hi.z - lo.z);

    return lerp(lo, hi, t);
  }

  inline float2 reachMFromTable(int pos, float t)
  {
    return lerp(reachMTable[pos - 1], reachMTable[pos], t);
  }

  // https://www.desmos.com/calculator/oe2fscya80
  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)
  {
    // Assume J (0.0, limitJmax)
    
    if (J <= analytical_threshold)
      return 1.0f; // makes the analytic inverse possible below cusp

    // Approximate inverse required above threshold TODO: explain why
    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));
    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;
  }

  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,
                                  const float focusAdjustGain, const float analytical_threshold)
  {
    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);
  }

  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py
  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)
  {
    float a = JM.y / (focusJ * slope_gain);
    float b;
    float c;

    if (JM.x < focusJ)
    {
      b = 1.0f - JM.y / slope_gain;
      c = -JM.x;
    }
    else
    {
      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));
      c = maxJ * JM.y / slope_gain + JM.x;
    }

    const float root = sqrt(b * b - 4.0f * a * c);

    if (JM.x < focusJ)
    {
      return 2.0f * c / (-b - root);
    }
    else
    {
      return 2.0f * c / (-b + root);
    }
  }

  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)
  {
    float direction_scaler;
    if (intersectJ <= focusJ)
    {
      direction_scaler = intersectJ;
    }
    else
    {
       direction_scaler = (limitJmax - intersectJ);
    }

    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);
  }

  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,
                                                         const float inv_gamma, const float J_max, const float M_max,
                                                         const float J_intersection_reference)
  {
    // Line defined by     J = slope * x + J_axis_intersect
    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)
    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential
    
    // We calculate a shifted intersection from the original intersection using the inverse of the exponential
    // and the provided reference
    const float normalised_J        = J_axis_intersect / J_intersection_reference;
    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);

    // Now we find the M intersection of two lines
    // line from origin to J,M Max       l1(x) = J/M * x
    // line from J Intersect' with slope l2(x) = slope * x + Intersect'

    //return shifted_intersecion / ((J_max / M_max) - slope);
    return shifted_intersecion * M_max / (J_max - slope * M_max);
  }

  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py
  float2 findGamutBoundaryIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,
                                       float2 estimated_hull_gammas, const float slope)
  {
    const float gamma_top    = estimated_hull_gammas.x;
    const float gamma_bottom = estimated_hull_gammas.y;

    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);

    // The upper hull is flipped and thus 'zerod' at J_max
    // Also note we negate the slope
    const float f_J_intersect_cusp = J_max - J_intersect_cusp;
    const float f_J_intersect_source = J_max - J_intersect_source;
    const float f_JM_cusp_J = J_max - JM_cusp.x;
    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);

    // Smooth minimum between the two calculated values for the M component
    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);

    const float J_boundary = slope * M_boundary + J_intersect_source;

    return float2(J_boundary, M_boundary);
  }

  inline float reinhard_compress(const float location, const float boundary_distance, const float reach_distance, bool direction)
  {
    // Assumes boundary_distance != reach_distance
    // Generaly speaking boundary should be < reach
    const float scale  = (reach_distance) / (((reach_distance) / (boundary_distance)) - 1.0f);
    const float factor = location / scale;

    if (INVERSE == direction)
    {
      if (factor >= 1.0f)
        return scale;
      else
        return scale * (-(factor / (factor - 1.0f)));
    }
    return scale * (factor) / (1.0f + factor);
  }

  inline float gamut_mapped_location(float location, const float gamutBoundary, const float reachBoundary, bool direction)
  {
    // Assumes _compressionFuncParams in [0.0, 1.0]
    const float threshold = max(_compressionFuncParams, gamutBoundary / reachBoundary) * gamutBoundary;

    // Values upto the threshold or when both boundaries are the same remain as is
    if (location <= threshold || threshold == gamutBoundary)
      return location / gamutBoundary; // Return normalised position

    // Translate to place threshold at zero
    const float location_offset = location - threshold;
    const float boundary_offset = gamutBoundary - threshold;
    const float reach_offset    = reachBoundary - threshold;

    const float relative_location = reinhard_compress(location_offset, boundary_offset, reach_offset, direction);

    return (threshold + relative_location) / gamutBoundary; // shift back to absolute and normalise
  }

  inline float gamut_compress_alpha(float initial, const float gamutBoundary, const float locusMaximum, bool direction) // TODO better name
  {
    float t               = initial / gamutBoundary;
    const float locus     = max(1.0001f, locusMaximum / gamutBoundary); // TODO: magic threshold? also in compressPowerP function needed here?
    const float threshold = max(_compressionFuncParams, 1.0f / locus);

    if (t < threshold)
      return t;
    
    const float scale  = (locus - threshold) / (((locus - threshold) / (1.0f - threshold)) - 1.0f);
    const float factor = (t - threshold) / scale;

    if (direction && factor > 1.0f)
      return t + scale;

    if (direction)
    {
      t = threshold + scale * (-(factor / (factor - 1.0f)));
    }
    else
    {
      t = threshold + scale * (factor) / (1.0f + factor);
    }

    return t;
  }

  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,
                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,
                    float reachMaxM, float model_gamma)
  {
    const float  intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);
    const float  slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);
    const float  J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);
    const float2 ganutBoundary    = findGamutBoundaryIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,
                                                                  smoothness, estimated_hull_gammas, slope);

    if (ganutBoundary.y <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)
    {
      return float2(JM.x, 0.0f);
    }

    // Compress the out of gamut color along the projection line
    const float  reachMax     = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);
    const float  t            = gamut_compress_alpha(JM.y, ganutBoundary.y, reachMax, direction);
    const float2 project_to   = float2(intersectJ, 0.0f);
    const float2 JMcompressed = lerp(project_to, ganutBoundary, t);
    return JMcompressed;
  }

  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)
  {
    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));
  }

  inline float compute_analytical_threshold(float cuspJ)
  {
    return lerp(cuspJ, _limitJmax, _focusGainBlend);
  }

  float3 gamutMapper(float3 JMh, const float4 cusp, const float2 reachM, bool direction)
  {
    // Limit to +ve values // TODO test this is neededS
    if (JMh.x <= 0.0f)
    {
      JMh.x = 0.0f;
      JMh.y = 0.0f;
    }
    // Above the expected maximum we explicitly map to 0 M
    if (JMh.x >= _limitJmax)
    {
      JMh.y = 0.0f;
    }

    // We compress M only so avoid mapping near zero
    if (JMh.y == 0.0f)
      return JMh;

    // Assumes 'h' component is wrapped [0.0, hue_limit)
    // Hue dependent, but as hue does not change we can compute them equally for both directions.

    const float2 JMcusp                = float2(cusp.x, cusp.y);
    const float  reachMaxM             = reachM[REACHM];
    const float2 estimated_hull_gammas = float2{cusp[UPPER_GAMMA], cusp[LOWER_GAMMA]};
    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x); 
    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);

    float  Jx         = JMh.x;
    float2 JM         = float2{JMh.x, JMh.y};
    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);
 
    if (INVERSE == direction)
    {
      // Inverse path is a multi-step iterative to solve for the original 'J'
      // Analytic inverse below threshold extra pass approximation above
      if (Jx > analytical_threshold)
      {
        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,
                        clamped_smoothness, reachMaxM, _model_gamma).x;
        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);
      }
    }
    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,
                    clamped_smoothness, reachMaxM, _model_gamma);

    return {JM.x, JM.y, JMh.z};
  }

  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates
  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, int conditions)
  {
    const float3 XYZ = vector_dot(matrix, RGB);
    const float3 JMh = XYZ_to_JMh(XYZ, conditions);
    return JMh;
  }

  float3 JMh_to_linear_RGB(float3 JMh, const float3x3& matrix, int conditions)
  {
    const float3 XYZ = JMh_to_XYZ(JMh, conditions);
    const float3 RGB = vector_dot(matrix, XYZ);
    return RGB;
  }

  void init_tonescale_constants(float peakLuminance)
  {
    // pre-calculate aces_ts  constants
    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions
    aces_ts_n = peakLuminance;
    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_n / aces_ts_n_r) / log(10000.0f / 100.0f));
    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;
    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));
    aces_ts_u                  = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);
    aces_ts_m                  = aces_ts_m_1 / aces_ts_u;
    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);
    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;
    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));
    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);
    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;
    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1) * referenceLuminance; // Factor in our reference
    aces_ts_u_2                = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);
    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;
    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?
  }

  // ACES Tonescale function, proposed by Daniele Siragusano
  inline float aces_ts_fwd(float Y)
  {
    // Assumes Y is >= +0.0
    float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);
    float h = max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility
    return h * aces_ts_n;
  }

  inline float aces_ts_rev(float Y)
  {
    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?
    float h = Y / aces_ts_n;
    float f = (h + sqrt(h * (4.0f * aces_ts_t_1 + h))) / 2.0f;
    f       = aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);
    return f;
  }

  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model
  inline float _Y_to_Hellwig_J(float Y, int conditions)
  {
    // Assumes Y is >= +0.0
    const float A = _post_adaptation_non_linear_response_compression_forward(F_L[conditions] * Y) / y_to_j_A_w[conditions];
    return _J_from_Achromatic(A, conditions);
  }

  inline float _Hellwig_J_to_Y(float J, int conditions)
  {
    // Assumes J is >= +0.0
    const float A = y_to_j_A_w[conditions] * _Achromatic_from_J(J, conditions);
    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L[conditions];
  }

  inline float Y_to_Hellwig_J(float Y, int conditions)
  {
    const float absY = fabs(Y);
    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?
  }

  inline float Hellwig_J_to_Y(float J, int conditions)
  {
    const float absJ = fabs(J);
    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?
  }

  float3 forwardTonescale(float3 inputJMh, int conditions)
  {
    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below
    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);
    const float  luminanceTS   = aces_ts_fwd(inputY);
    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);
    return float3(tonemappedJ, inputJMh.y, inputJMh.z);
  }

float3 inverseTonescale(float3 JMh, int conditions)
  {
    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);
    const float  linear          = aces_ts_rev(luminance);
    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);
    return float3(untonemappedJ, JMh.y, JMh.z);
  }

  // A "toe" function that remaps the given value x between 0 and limit.
  // The k1 and k2 parameters change the size and shape of the toe.
  // https://www.desmos.com/calculator/6vplvw14ti
  float toe(float x, float limit, float k1, float k2, bool inverse)
  {
    if (x > limit)
      return x;

    k2             = max(k2, 0.001f); // TODO; magic constant
    k1             = sqrt(k1 * k1 + k2 * k2);
    const float k3 = (limit + k1) / (limit + k2);

    if (!inverse)
    {
      const float minus_b = k3 * x - k1;
      const float minus_c = k2 * k3 * x;
      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2
    }
    else
      return (x * x + k1 * x) / (k3 * (x + k2));
  }

  // Chroma compression
  //
  // Compresses colors inside the gamut with the aim for colorfulness to have an
  // appropriate rate of change from display black to display white, and from
  // achromatic outward to purer colors.
  //
  inline float chromaCompression(float3 JMh, const float origJ, const float reachCuspM, const float reachMMax, const bool inverse,
                                 const float limitJmax, const float model_gamma,
                                 const float sat, const float sat_thr, const float compr)
  {
    // Assumes 'h' component is wrapped [0.0, hue_limit)
    float M = JMh.y;
    if (M == 0.0f)
      return M;

    const float  nJ         = JMh.x / limitJmax;
    const float  snJ        = max(0.0f, 1.0f - nJ);
    const float  limit      = pow(nJ, model_gamma) * reachMMax / reachCuspM;

    const float toe_limit           = limit - 0.001f;  // TODO; magic constant
    const float toe_snJ_sat         = snJ * sat;
    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);
    if (!inverse)
    {
      // Rescaling of M with the tonescaled J to get the M to the same range as
      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to
      // keep the M/J ratio correct (keeping the chromaticities constant).
      M *= pow(JMh.x / origJ, model_gamma);

      // Normalize M with the rendering space cusp M
      M /= reachCuspM;

      // Expand the colorfulness by running the toe function in reverse.  The goal is to
      // expand less saturated colors less and more saturated colors more.  The expansion
      // increases saturation in the shadows and mid-tones but not in the highlights.
      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes
      // the toe less aggressive near black to reduce the expansion of noise.
      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);

      // Compress the colorfulness.  The goal is to compress less saturated colors more and
      // more saturated colors less, especially in the highlights.  This step creates the
      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This
      // mostly affects highlights and mid-tones, and does not compress shadows.
      M = toe(M, limit, nJ * compr, snJ, FORWARDS);

      // Denormalize
      M *= reachCuspM;
    }
    else
    {
      M /= reachCuspM;
      M = toe(M, limit, nJ * compr, snJ, INVERSE);
      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);
      M *= reachCuspM;
      M *= pow(JMh.x / origJ, -model_gamma);
    }

    return M;
  }

  float3 compressChroma(float3 JMh, const float originalJ, const float2 reachM, const bool inverse)
  {
    JMh.y = chromaCompression(JMh, originalJ, reachM[REACHCUSPM], reachM[REACHM], inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);
    if (inverse)
      JMh.x = originalJ;
    return JMh;
  }

  float3 apply_DRT(float3 src)
  {
    float3 JMh;
    float3 tonemappedJMh;
    float3 compressedJMh;
    float3 gamutMappedJMh;
    float3 output;

     if (invert)
      {
        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);
        const int    pos    = lookupLimitingCuspHue(JMh.z);
        const float  t      = limiting_lerp_fraction(JMh.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float2 reachM = reachMFromTable(pos, t);
        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);
        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);
        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);
        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);
      }
      else
      {
        float3 clamped      = clamp_to_AP1(src);
        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);
        const int    pos    = lookupLimitingCuspHue(JMh.z);
        const float  t      = limiting_lerp_fraction(JMh.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float2 reachM = reachMFromTable(pos, t);
        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);
        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);
        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);
        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);
      }
    return output;
  }

  void process()
  {
    SampleType(src) source = src();
    const float3 src(source.x, source.y, source.z);
    float3 output;

#ifdef COMPILE_DIAGNOSTICS
    if (APPLY_DRT == diagnosticMode)
    {
        output = apply_DRT(src);
    }
    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)
    {
        output = clamp_to_AP1(src);
    }
    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)
    {
        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);
    }
    else if (FORWARDS_forwardTonescale == diagnosticMode)
    {
        output = forwardTonescale(src, SOURCE_CONDITIONS);
    }
    else if (FORWARDS_compressChroma == diagnosticMode)
    {
        const int    pos    = lookupLimitingCuspHue(src.z);
        const float  t      = limiting_lerp_fraction(src.z, pos);
        const float2 reachM = reachMFromTable(pos, t);
        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);
        output              = compressChroma(src, JMh.x, reachM, FORWARDS);
    }
    else if (FORWARDS_gamutMapper == diagnosticMode)
    {
        const int    pos    = lookupLimitingCuspHue(src.z);
        const float  t      = limiting_lerp_fraction(src.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float2 reachM = reachMFromTable(pos, t);
        output = gamutMapper(src, cusp, reachM, FORWARDS);
    }
    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)
    {
        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);
    }
    else if (INVERSE_XYZ_to_JMh == diagnosticMode)
    {
        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);
    }
    else if (INVERSE_gamutMapper == diagnosticMode)
    {
        const int    pos    = lookupLimitingCuspHue(src.z);
        const float  t      = limiting_lerp_fraction(src.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float2 reachM = reachMFromTable(pos, t);
        output = gamutMapper(src, cusp, reachM, INVERSE);
    }
    else if (INVERSE_inverseTonescale == diagnosticMode)
    {
        output = inverseTonescale(src, SOURCE_CONDITIONS);
    }
    else if (INVERSE_compressChroma == diagnosticMode)
    {
        const int    pos  = lookupLimitingCuspHue(src.z);
        const float  t    = limiting_lerp_fraction(src.z, pos);
        const float2 reachM = reachMFromTable(pos, t);
        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);
        output            = compressChroma(src, JMh.x, reachM, INVERSE);
    }
    else if (INVERSE_JMh_to_XYZ == diagnosticMode)
    {
        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);
    }
    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)
    {
        const float  wrapped_hue = wrap_hue(src.z);
        const int    pos         = lookupLimitingCuspHue(wrapped_hue);
        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
        const float4 cusp        = limitingCuspFromTable(pos, t);
        output = float3(cusp.x, cusp.y, src.z);
    }
    else if (DEBUG_limitingGamutGammas == diagnosticMode)
    {
        const float  wrapped_hue = wrap_hue(src.z);
        const int    pos         = lookupLimitingCuspHue(wrapped_hue);
        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
        const float4 cusp        = limitingCuspFromTable(pos, t);
        output = float3(cusp[UPPER_GAMMA], cusp[LOWER_GAMMA], t);
    }
    else if (DEBUG_reachGamutCuspTable == diagnosticMode)
    {
        const float  wrapped_hue = wrap_hue(src.z);
        const int    pos         = lookupLimitingCuspHue(wrapped_hue);
        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
        const float2 reachM      = reachMFromTable(pos, t);
        output = float3(reachM[REACHCUSPM], reachM[REACHM], wrapped_hue);
    }
    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)
    {
        int index = clamp(int(src.z), 0, totalTableSize);
        float4 cusp = limitingGamutCuspTable[index];
        output = float3(cusp.x, cusp.y, cusp.z);
    }
    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)
    {
        int index = clamp(int(src.z), 0, totalTableSize);
        float4 cusp = limitingGamutCuspTable[index];
        output = float3(cusp.x, cusp.y, cusp.w);
    }
    else if (DEBUG_reachMTableRaw == diagnosticMode)
    {
        int index = clamp(int(src.z), 0, totalTableSize);
        float2 reachM = reachMTable[index];
        output = float3(reachM.x, reachM.y, index);
    }
    
    else if (DEBUG_Jconstants == diagnosticMode)
    {
        output = float3(_midJ, _limitJmax, _focusDist);
    }
    else if (DEBUG_FocusConstants == diagnosticMode)
    {
        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);
    }
    else if (DEBUG_reachMConditions == diagnosticMode)
    {
        const float wrapped_hue = wrap_hue(src.z);
        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);
        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);

        output = float3(sM, dM, wrapped_hue); 
    }
    else
    {
        output = src;
    }
#else
    output = apply_DRT(src);
#endif
    dst() = float4(output.x, output.y, output.z, source.w);
  }
};
