kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>
{
  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image
  Image<eWrite>                            dst; // the output image

param:
  // Toggle Inverse Transform
#define FORWARDS false
#define INVERSE  true
  bool invert;

  bool AP1Clamp;

  // Target Peak Luminance
  float _peakLuminance;

#define PRIMARIES_XYZ     0
#define PRIMARIES_AP0     1
#define PRIMARIES_AP1     2
#define PRIMARIES_Rec709  3
#define PRIMARIES_Rec2020 4
#define PRIMARIES_P3      5
#define PRIMARIES_CUSTOM  6
  int primariesLimit;

  // White point of the limiting gamut
  // effectively the "creative white"
#define WHITE_E      0
#define WHITE_ACES   1
#define WHITE_D65    2
#define WHITE_DCI    3
#define WHITE_CUSTOM 4
  int whiteLimit;

  float2 custom_red;
  float2 custom_green;
  float2 custom_blue;
  float2 custom_white;

  // Viewing Conditions
#define SURROUND_DARK    0
#define SURROUND_DIM     1
#define SURROUND_AVERAGE 2
#define SURROUND_USER    3
  int   _inputViewingConditions;
  float L_A_in;
  float Y_b_in;

  int   _outputViewingConditions;
  float L_A_out;
  float Y_b_out;

  float3 _userSurround;

  float _XYZ_w_scaler;

  // Diagnostic path modes
#define COMPILE_DIAGNOSTICS

#define APPLY_DRT 0

#ifdef COMPILE_DIAGNOSTICS

#define FORWARDS_clamp_to_AP1            1
#define FORWARDS_XYZ_to_JMh              2
#define FORWARDS_forwardTonescale        3
#define FORWARDS_compressChroma          4
#define FORWARDS_gamutMapper             5
#define FORWARDS_JMh_to_XYZ              6
#define INVERSE_XYZ_to_JMh               11
#define INVERSE_gamutMapper              12
#define INVERSE_inverseTonescale         13
#define INVERSE_compressChroma           14
#define INVERSE_JMh_to_XYZ               15
#define DEBUG_limitingGamutCuspTable     50
#define DEBUG_limitingGamutGammas        52
#define DEBUG_reachGamutCuspTable        53
#define DEBUG_limitingGamutCuspTableRaw  60
#define DEBUG_limitingGamutCuspTableRaw2 61
#define DEBUG_reachMTableRaw             62
#define DEBUG_Jconstants                 70
#define DEBUG_FocusConstants             71
#define DEBUG_limitingFocusJ             72
#define DEBUG_reachMConditions           73
#define DEBUG_gamutCompressAlphaFORWARDS 80
#define DEBUG_gamutCompressAlphaINVERSE  81

#endif

  int diagnosticMode;

  float  _smoothCusps;
  float2 _smoothOffset;
  float  _cuspMidBlend;

  float _focusGainBlend;
  float _focusAdjustGain;
  float _focusDistance;
  float _focusDistanceScaling;

  // Gamut Compression Fuction Parameters
  // Threshold
  float _compressionFuncParams;

  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;

  float chroma_compress;
  float chroma_compress_fact;
  float chroma_expand;
  float chroma_expand_fact;
  float chroma_expand_thr;

  float lowerHullGamma;
  float upperHullGamma;
  bool  disableUpperHullGamma;
  bool  disableLowerHullGamma;

  // aces_ts Curve (ACES2 candidate) parameters
  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)
  float aces_ts_g;         // surround / contrast
  float aces_ts_c;         // scene-referred grey
  float aces_ts_c_d;       // display-referred grey (in nits)
  float aces_ts_w_g;       // grey change between different peak luminance
  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it
  float aces_ts_r_hit_min; // Scene-referred value "hitting the roof" at 100 nits
  float aces_ts_r_hit_max; // Scene-referred value "hitting the roof" at 10,000 nits

local:
#define SOURCE_CONDITIONS  0
#define DISPLAY_CONDITIONS 1
#define NUMBER_CONDITIONS  2

  float3 DL_weights[NUMBER_CONDITIONS];
  float3 DM_weights[NUMBER_CONDITIONS];
  float3 DS_weights[NUMBER_CONDITIONS];

  float3 DL_weights_inv[NUMBER_CONDITIONS];
  float3 DM_weights_inv[NUMBER_CONDITIONS];
  float3 DS_weights_inv[NUMBER_CONDITIONS];

  float3 achromatic_weights[NUMBER_CONDITIONS];
  float3 a_weights[NUMBER_CONDITIONS];
  float3 b_weights[NUMBER_CONDITIONS];

  float3 achromatic_weights_inv[NUMBER_CONDITIONS];
  float3 a_weights_inv[NUMBER_CONDITIONS];
  float3 b_weights_inv[NUMBER_CONDITIONS];

  float3x3 AP1_to_XYZ;
  float3x3 XYZ_to_AP1;
  float3x3 XYZ_to_RGB_limit;
  float3x3 RGB_to_XYZ_limit;

  // Model Nonlinearity 'constants'
#define nl_gamma     0.42f
#define nl_normalise 100.0f
#define nl_scale     400.0f
#define nl_offset    27.13f
#define j_scale      100.0f

  float3 surround[NUMBER_CONDITIONS]; // TODO: could shrink to single component
  //bool   HK_mode[NUMBER_CONDITIONS];
  float  F_L[NUMBER_CONDITIONS];
  float3 D_RGB[NUMBER_CONDITIONS];
  float  y_to_j_A_w[NUMBER_CONDITIONS];

//#define USE_DEGREES
#ifdef USE_DEGREES
#define hue_limit 360.0f
#else
#define hue_limit (2 * PI)
#endif

#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range [0.0, hue_limit)F
#define additional_entries 2   // Adds extra entries to wrap the hues without special cases
#define totalTableSize     gamutCuspTableSize + additional_entries
#define baseIndex          1   // array index for smallest hue, not necessarily actually a 0.0 hue angle

#define gammaAccuracy       5e-6
#define gammaMinimum        0.4f
#define gammaMaximum        2.0f
#define gammaSearchStep     0.2f
#define badGammaTolerance   1e-2f
#define hueFindingTolerance 1e-7f

#define UPPER_GAMMA 2
#define LOWER_GAMMA 3
  float  hueTable[totalTableSize];               // Non-uniform in h
  float4 limitingGamutCuspTable[totalTableSize]; // { J, M, Upper gamma, Lower gamma }
  float  reachMTable[totalTableSize];            // reachM

#define cuspCornerCount  6
#define totalCornerCount cuspCornerCount + additional_entries

#ifdef COMPILE_DIAGNOSTICS
  float3 reach_JMh_corners[totalCornerCount];
  float3 display_cusp_corners[totalCornerCount];
  float3 display_JMh_corners[totalCornerCount];
  float  cube_hues[2 * cuspCornerCount];
  int    unique_hues;
#endif

  float _clamped_smoothness;
  float _focusDist;
  float _midJ;
  float _limitJmax;
  float _model_gamma; // TODO: investigate uses of this
  float _base_slope;

  // Chroma compression pre-calculated constants
  float  _compr;               // Compression TODO rename
  float  _sat;                 // Saturation TODO rename
  float  _sat_thr;             // Threshold to start expanding saturation
  float3 _chromaCompress_cosFactors;
  float3 _chromaCompress_sinFactors;
  float  _chromaCompress_offset;
    
  float aces_ts_c_t;
  float aces_ts_s_2;
  float aces_ts_m_2;
  //float aces_ts_inv_upper_limit;
  float _input_upper_clamp;

  void define()
  {
    defineParam(invert, "Invert", FORWARDS);

    defineParam(AP1Clamp, "AP1 Clamp", true);

    defineParam(_peakLuminance, "Peak Luminance", 100.0f);
    defineParam(primariesLimit, "Limiting primaries", 2);
    defineParam(whiteLimit, "Limiting Whitepoint", 1);
    defineParam(custom_red, "Custom Red", float2(0.6400f, 0.3300f));
    defineParam(custom_green, "Custom Green", float2(0.3000f, 0.6000f));
    defineParam(custom_blue, "Custom Blue", float2(0.1500f, 0.0600f));
    defineParam(custom_white, "Custom White", float2(0.3127f, 0.3290f));

    defineParam(_inputViewingConditions, "Input Viewing Conditions", 1);
    defineParam(L_A_in, "Input Adapting Luminance", 100.0f);    // Note these are ridiculously wrong should be nearer 20% of diffuse white
    defineParam(Y_b_in, "Input Background Luminance", 20.0f);   // Note these are ridiculously wrong depends on viewing conditions
    defineParam(_outputViewingConditions, "Output Viewing Conditions", 1);
    defineParam(L_A_out, "Output Adapting Luminance", 100.0f);  // Note these are ridiculously wrong should be nearer 20% of diffuse white
    defineParam(Y_b_out, "Output Background Luminance", 20.0f); // Note these are ridiculously wrong depends on viewing conditions
    defineParam(_userSurround, "User Surround Parameters", float3(0.9f, 0.59f, 0.9f));

    defineParam(_XYZ_w_scaler, "XYZ White Scaler", 100.0f);

    defineParam(diagnosticMode, "Diagnostics Mode", APPLY_DRT);

    defineParam(_smoothCusps, "Cusp Smoothing Factor", 0.12f);
    defineParam(_smoothOffset, "Cusp Smoothing Offset", float2(0.0f, 0.27f));
    defineParam(_cuspMidBlend, "Cusp Mid Blend", 1.3f);

    defineParam(_focusGainBlend, "Focus gain Blend", 0.3f);
    defineParam(_focusAdjustGain, "Focus Adjust Gain", 0.55f);
    defineParam(_focusDistance, "Focus Distance", 1.35f);
    defineParam(_focusDistanceScaling, "Focus Distance Scaling", 1.75f);

    defineParam(_compressionFuncParams, "Compression Function Parameters", 0.75f);
    defineParam(LMS_rxy, "LMS Red Primary", float2(0.8336f, 0.1735f));
    defineParam(LMS_gxy, "LMS Green Primary", float2(2.3854f, -1.4659f));
    defineParam(LMS_bxy, "LMS Blue Primary", float2(0.087f, -0.125f));
    defineParam(LMS_wxy, "LMS White Primary", float2(1.0f / 3.0f, 1.0f / 3.0f));

    // TODO: improve user facing labels
    defineParam(chroma_compress, "chroma_compress", 2.4f);
    defineParam(chroma_compress_fact, "chroma_compress_fact", 3.3f);
    defineParam(chroma_expand, "chroma_expand", 1.3f);
    defineParam(chroma_expand_fact, "chroma_expand_fact", 0.69f);
    defineParam(chroma_expand_thr, "chroma_expand_thr", 0.5f);

    defineParam(lowerHullGamma, "Lower Hull Gamma", 1.14f);
    defineParam(upperHullGamma, "Upper Hull Gamma", 1.0f);
    defineParam(disableLowerHullGamma, "Disable per hue Lower Hull Computation", true);
    defineParam(disableUpperHullGamma, "Disable per hue Upper Hull Computation", false);

    // aces_ts Curve (ACES2 candidate) parameters
    defineParam(aces_ts_n_r, "aces_ts_n_r", 100.0f);             // Normalized white in nits (what 1.0 should be)
    defineParam(aces_ts_g, "aces_ts_g", 1.15f);                  // surround / contrast
    defineParam(aces_ts_c, "aces_ts_c", 0.18f);                  // scene-referred 18% grey
    defineParam(aces_ts_c_d, "aces_ts_c_d", 10.013f);            // display-referred 18^grey (in nits)
    defineParam(aces_ts_w_g, "aces_ts_w_g", 0.14f);              // grey change between different peak luminance
    defineParam(aces_ts_t_1, "aces_ts_t_1", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it
    defineParam(aces_ts_r_hit_min, "aces_ts_r_hit_min", 128.0f); // Scene-referred value "hitting the roof" at 100 nits
    defineParam(aces_ts_r_hit_max, "aces_ts_r_hit_max", 896.0f); // Scene-referred value "hitting the roof" at 10,000 nits
  }

#define INTERVAL_HIGH  0
#define INTERVAL_LOW   1
  inline int midpoint(const int2 interval)
  {
    return int((interval[INTERVAL_LOW] + interval[INTERVAL_HIGH]) / 2); // Integer division
  }

  inline float midpoint(const float2 interval)
  {
    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document
    return (interval[INTERVAL_LOW] + interval[INTERVAL_HIGH]) * 0.5f;
  }

  float3x3 RGBPrimsToXYZMatrix(float2 primaries[3], float2 wxy, float Y, const bool direction)
  {
    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ
    // # based on CtlColorSpace.cpp from the CTL source code : 77
    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc
    // # param: Y - luminance of "white" - defaults to 1.0
    // # param: inverse - calculate XYZ to RGB instead

    const float2 r = primaries[0];
    const float2 g = primaries[1];
    const float2 b = primaries[2];
    const float2 w = wxy;

    const float X = w.x * Y / w.y;
    const float Z = (1 - w.x - w.y) * Y / w.y;

    // # Scale factors for matrix rows
    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);

    // clang-format off
    float Sr =    (X * (b.y - g.y) -      \
            g.x * (Y * (b.y - 1.0f) +  \
            b.y * (X + Z)) +       \
            b.x * (Y * (g.y - 1.0f) + \
            g.y * (X + Z))) / d ;

    float Sg =    (X * (r.y - b.y) +      \
            r.x * (Y * (b.y - 1.0f) +  \
            b.y * (X + Z)) -        \
            b.x * (Y * (r.y - 1.0f) +  \
            r.y * (X + Z))) / d ;

    float Sb =    (X * (g.y - r.y) -      \
            r.x * (Y * (g.y - 1.0f) +  \
            g.y * (X + Z)) +        \
            g.x * (Y * (r.y - 1.0f) +  \
            r.y * (X + Z))) / d ;

    // # Assemble the matrix
    float3x3 newMatrix =
    {
      Sr * r.x, Sg * g.x, Sb * b.x,
      Sr * r.y, Sg * g.y, Sb * b.y,
      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),
    };
    // clang-format on

    if (direction == INVERSE)
    {
      return newMatrix.invert();
    }
    return newMatrix;
  }

  float2 get_whitepoint(int which_white, float2 custom)
  {
    if (WHITE_ACES == which_white)
    {
      return float2(0.32168f, 0.33767f);
    }
    else if (WHITE_D65 == which_white)
    {
      return float2(0.3127f, 0.3290f);
    }
    else if (WHITE_DCI == which_white)
    {
      return float2(0.3140f, 0.3510f);
    }
    else if (WHITE_CUSTOM == which_white)
    {
      return custom;
    }

    // Case WHITE_E and default
    return float2(1.0f / 3.0f, 1.0f / 3.0f);
  }

  void get_primaries(const int primaries, const float2 custom[3], float2 primaries_out[3])
  {
    if (PRIMARIES_AP0 == primaries)
    {
      primaries_out[0] = float2(0.7347f, 0.2653f);
      primaries_out[1] = float2(0.0000f, 1.0000f);
      primaries_out[2] = float2(0.0001f, -0.0770f);
    }
    else if (PRIMARIES_AP1 == primaries)
    {
      primaries_out[0] = float2(0.7130f, 0.2930f);
      primaries_out[1] = float2(0.1650f, 0.8300f);
      primaries_out[2] = float2(0.1280f, 0.0440f);
    }
    else if (PRIMARIES_Rec709 == primaries)
    {
      primaries_out[0] = float2(0.6400f, 0.3300f);
      primaries_out[1] = float2(0.3000f, 0.6000f);
      primaries_out[2] = float2(0.1500f, 0.0600f);
    }
    else if (PRIMARIES_Rec2020 == primaries)
    {
      primaries_out[0] = float2(0.7080f, 0.2920f);
      primaries_out[1] = float2(0.1700f, 0.7970f);
      primaries_out[2] = float2(0.1310f, 0.0460f);
    }
    else if (PRIMARIES_P3 == primaries)
    {
      primaries_out[0] = float2(0.6800f, 0.3200f);
      primaries_out[1] = float2(0.2650f, 0.6900f);
      primaries_out[2] = float2(0.1500f, 0.0600f);
    }
    else if (PRIMARIES_CUSTOM == primaries)
    {
      primaries_out[0] = custom[0];
      primaries_out[1] = custom[1];
      primaries_out[2] = custom[2];
    }
    else
    {
      // Case PRIMARIES_XYZ and default
      primaries_out[0] = float2(1.0f, 0.0f);
      primaries_out[1] = float2(0.0f, 1.0f);
      primaries_out[2] = float2(0.0f, 0.0f);
    }
  }

  // Generate the Hellwig2022 post adaptation non-linear compression matrix
  // that is used in the inverse of the model (JMh-to-XYZ).
  //
  // Original:
  //  460.0f, 451.0f, 288.0f,
  //  460.0f, -891.0f, -261.0f,
  //  460.0f, -220.0f, -6300.0f
  void generate_panlrcm(float3 panlrcm_fwd[3], float3 panlrcm_inv[3])
  {
    panlrcm_fwd[0] = nl_scale * float3(2.0f, 1.0f, 0.05f);
    panlrcm_fwd[1] = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;
    panlrcm_fwd[2] = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;

    float3x3 mat = constuct_inverse_matrix(panlrcm_fwd[0], panlrcm_fwd[1], panlrcm_fwd[2]);

    for (int i = 0; i != 3; ++i)
    {
      const float n = ((460.0f / mat[i][0]) / 1403.0f) / nl_scale;
      panlrcm_inv[i][0] = mat[i][0] * n;
      panlrcm_inv[i][1] = mat[i][1] * n;
      panlrcm_inv[i][2] = mat[i][2] * n;
    }
  }

  float3 viewingConditionsToSurround(int condition)
  {
    float3 newSurround;
    if (SURROUND_DARK == condition)
    {
      newSurround = float3(0.8f, 0.525f, 0.8f);
    }
    else if (SURROUND_DIM == condition)
    {
      newSurround = float3(0.9f, 0.59f, 0.9f);
    }
    else if (SURROUND_AVERAGE == condition)
    {
      newSurround = float3(1.0f, 0.69f, 1.0f);
    }
    else if (SURROUND_USER == condition)
    {
      newSurround = _userSurround;
    }
    return newSurround;
  }

  void init_matrices(float3x3 & CAT_CAT16)
  {
    const float2 custom_primaries[3] = {custom_red, custom_green, custom_blue};
    float2       temp_primaries[3]   = {LMS_rxy, LMS_gxy, LMS_bxy};

    CAT_CAT16 = RGBPrimsToXYZMatrix(temp_primaries, LMS_wxy, 1.0f, INVERSE);

    get_primaries(PRIMARIES_AP1, custom_primaries, temp_primaries);
    float2 whitepoint = get_whitepoint(WHITE_ACES, custom_white);
    AP1_to_XYZ        = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);
    XYZ_to_AP1        = AP1_to_XYZ;
    XYZ_to_AP1        = XYZ_to_AP1.invert();

    get_primaries(primariesLimit, custom_primaries, temp_primaries);
    whitepoint       = get_whitepoint(whiteLimit, custom_white);
    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);
    XYZ_to_RGB_limit = RGB_to_XYZ_limit;
    XYZ_to_RGB_limit = XYZ_to_RGB_limit.invert();
  }

  void init_chroma_compression(const float peakLuminance, const float log_peak)
  {
    _compr              = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;
    _sat                = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number
    _sat_thr            = chroma_expand_thr / peakLuminance;

    // Compression normalisation factors, magic numbers come from fitting Against AP1
    const float chromaCompressScale = pow(0.03379f * peakLuminance, 0.30596f) - 0.45135f;
    _chromaCompress_cosFactors      = float3(11.34072f, 16.46899f, 7.88380f) * chromaCompressScale;
    _chromaCompress_sinFactors      = float3(14.66441f, -6.37224f, 9.19364f) * chromaCompressScale;
    _chromaCompress_offset          = 77.12896f * chromaCompressScale;
  }

  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)
  {
    return 1.48f + sqrt(Y_background / Y_white);
  }

  float2 init_gamut_mapper(const float peakLuminance, const float log_peak, const float3 white)
  {
    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;
    _midJ      = XYZ_to_JMh(white * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?

    // calculate the maximum expected J & M values for the given limit gamut
    // these are used as limiting values for the gamut boundary searches
    // limitJmax (assumed to match limitRGB white)
    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white
    _limitJmax   = linear_RGB_to_JMh(float3(peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;
    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));
    _base_slope  = _limitJmax * _focusDist;

    _clamped_smoothness            = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?
    const float2 smooth_cusp_scale = 1.0f + _smoothOffset * _clamped_smoothness;
    return smooth_cusp_scale;
  }

  inline float3 generate_unit_cube_corners(const int corner)
  {
    // Generation order R, Y, G, C, B, M to ensure hues rotate in correct order
    return float3(int(((corner + 1) % cuspCornerCount) < 3), int(((corner + 5) % cuspCornerCount) < 3),
                  int(((corner + 3) % cuspCornerCount) < 3));
  }

  void build_cusp_corners_tables(float3 XYZ_corners[totalCornerCount], float3 JMh_corners[totalCornerCount], const int rgb_conditions,
                                 const float3x3& rgb_matrix, const float peakLuminance)
  {
    float3 temp_cusp_corners[cuspCornerCount];
    float3 temp_JMh_corners[cuspCornerCount];
    int    min_index = 0;
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      temp_cusp_corners[i] = vector_dot(rgb_matrix, peakLuminance * generate_unit_cube_corners(i));
      temp_JMh_corners[i]  = XYZ_to_JMh(temp_cusp_corners[i], rgb_conditions);
      if (temp_JMh_corners[i].z < temp_JMh_corners[min_index].z)
        min_index = i;
    }

    // Rotate entries placing lowest at [1] (not [0])
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      XYZ_corners[i + 1] = temp_cusp_corners[(i + min_index) % cuspCornerCount];
      JMh_corners[i + 1] = temp_JMh_corners[(i + min_index) % cuspCornerCount];
    }

    // Copy end elements to create a cycle
    XYZ_corners[0]                   = XYZ_corners[cuspCornerCount];
    XYZ_corners[cuspCornerCount + 1] = XYZ_corners[1];
    JMh_corners[0]                   = JMh_corners[cuspCornerCount];
    JMh_corners[cuspCornerCount + 1] = JMh_corners[1];

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    JMh_corners[0].z                   = JMh_corners[0].z - hue_limit;
    JMh_corners[cuspCornerCount + 1].z = JMh_corners[cuspCornerCount + 1].z + hue_limit;
  }

  float RGB_c_to_J(float3 RGB_c, int conditions)
  {
    const float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);
    const float  A     = dot(achromatic_weights[conditions], RGB_a);
    return J_from_Achromatic(A, conditions);
  }

  void find_reach_corners_tables(float3 JMh_corners[totalCornerCount], const int rgb_conditions, const float3x3& rgb_matrix, const float limitJ,
                                 const float maximum_source)
  {
    float3 temp_JMh_corners[cuspCornerCount];

    int min_index = 0;
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      const float3 xyz_vector = vector_dot(rgb_matrix, generate_unit_cube_corners(i));
      float3       RGB_c;
      RGB_c.x = dot(DL_weights[rgb_conditions], xyz_vector);
      RGB_c.y = dot(DM_weights[rgb_conditions], xyz_vector);
      RGB_c.z = dot(DS_weights[rgb_conditions], xyz_vector);

      float2 bounds = { maximum_source, 0.0f }; // Order mx, min for binary search assignment
      while ((bounds[INTERVAL_HIGH] - bounds[INTERVAL_LOW]) > 1e-3) // TODO: tolerance pass as parameter
      {
        const float  test        = midpoint(bounds);
        const float3 test_corner = test * RGB_c;
        const float  J           = RGB_c_to_J(test_corner, rgb_conditions);

        bounds[(J < limitJ)]     = test; // Binary search
        if (J == limitJ)
          break;
      }
      temp_JMh_corners[i] = XYZ_to_JMh(bounds[INTERVAL_HIGH] * xyz_vector, rgb_conditions);

      if (temp_JMh_corners[i].z < temp_JMh_corners[min_index].z)
        min_index = i;
    }

    // Rotate entries placing lowest at [1] (not [0])
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      JMh_corners[i + 1] = temp_JMh_corners[(i + min_index) % cuspCornerCount];
    }

    // Copy end elements to create a cycle
    JMh_corners[0]                   = JMh_corners[cuspCornerCount];
    JMh_corners[cuspCornerCount + 1] = JMh_corners[1];

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    JMh_corners[0].z                   = JMh_corners[0].z - hue_limit;
    JMh_corners[cuspCornerCount + 1].z = JMh_corners[cuspCornerCount + 1].z + hue_limit;
  }

  int extract_sorted_cube_hues(float sorted_hues[12], const float3 reach_JMh[totalCornerCount], const float3 display_JMh[totalCornerCount])
  {
    // Basic merge of 2 sorted arrays, extracting the unique hues.
    // Return the count of the unique hues
    int idx         = 0;
    int reach_idx   = 1;
    int display_idx = 1;
    while ((reach_idx < (cuspCornerCount + 1)) || (display_idx < (cuspCornerCount + 1)))
    {
      const float reach_hue   = reach_JMh[reach_idx].z;
      const float display_hue = display_JMh[display_idx].z;
      if (reach_hue == display_hue)
      {
        sorted_hues[idx] = reach_hue;
        ++reach_idx;
        ++display_idx; // When equal consume both
      }
      else
      {
        if (reach_hue < display_hue)
        {
          sorted_hues[idx] = reach_hue;
          ++reach_idx;
        }
        else
        {
          sorted_hues[idx] = display_hue;
          ++display_idx;
        }
      }
      ++idx;
    }
    return idx;
  }

  void build_hue_sample_interval(const int samples, const float lower, const float upper, float hueTable[totalTableSize], const int base)
  {
    const float delta = (upper - lower) / float(samples);
    for (int i = 0; i != samples; ++i)
    {
      hueTable[base + i] = lower + float(i) * delta;
    }
  }

  void build_hue_table(float hueTable[totalTableSize], const float cube_hues[2 * cuspCornerCount], const int unique_hues)
  {
    const float ideal_spacing = gamutCuspTableSize / hue_limit;
    int         samples_count[2 * cuspCornerCount + 2];
    int         last_idx  = -1;
    int         min_index = cube_hues[0] == 0.0f ? 0 : 1; // Ensure we can always sample at 0.0 hue
    for (int hue_idx = 0; hue_idx != unique_hues; ++hue_idx)
    {
      // BUG: "gamutCuspTableSize - 1" will fail if we have multiple hues mapping near the top of the table
      int nominal_idx = clamp(int(round(cube_hues[hue_idx] * ideal_spacing)), min_index, gamutCuspTableSize - 1);
      if (last_idx == nominal_idx)
      {
        // Last two hues should sample at same index, need to adjust them
        // Adjust previous sample down if we can
        if (hue_idx > 1 && samples_count[hue_idx - 2] != (samples_count[hue_idx - 1] - 1))
        {
          samples_count[hue_idx - 1] = samples_count[hue_idx - 1] - 1;
        }
        else
        {
          nominal_idx = nominal_idx + 1;
        }
      }
      samples_count[hue_idx] = min(nominal_idx, gamutCuspTableSize - 1);
      last_idx = min_index = nominal_idx;
    }

    int total_samples = 0;
    // Special cases for ends
    int i = 0;
    build_hue_sample_interval(samples_count[i], 0.0f, cube_hues[i], hueTable, total_samples + 1);
    total_samples += samples_count[i];
    for (++i; i != unique_hues; ++i)
    {
      const int samples = samples_count[i] - samples_count[i - 1];
      build_hue_sample_interval(samples, cube_hues[i - 1], cube_hues[i], hueTable, total_samples + 1);
      total_samples += samples;
    }
    // BUG: could break if we are unlucky with samples all being used up by this point
    build_hue_sample_interval(gamutCuspTableSize - total_samples, cube_hues[i - 1], hue_limit, hueTable, total_samples + 1);

    hueTable[0]                  = hueTable[totalTableSize - 2] - hue_limit;
    hueTable[totalTableSize - 1] = hueTable[1] + hue_limit;
  }

  float2 find_display_cusp_for_hue(float hue, const float3 display_cusp_corners[totalCornerCount],
                                   const float3 display_JMh_corners[totalCornerCount], const int rgb_conditions, const float tolerance,
                                   float2 & previous)
  {
    // This works by finding the required line segment between two of the XYZ cusp corners, then binary searching
    // along the line calculating the JMh of points along the line till we find the required value.
    // All values on the line segments are valid cusp locations.

    int upper_corner = 1;
    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?
    {
      if (display_JMh_corners[i].z > hue)
      {
        upper_corner = i;
        break;
      }
    }
    const int lower_corner = upper_corner - 1;

    // hue should now be within [lower_corner, upper_corner), handle exact match
    if (display_JMh_corners[lower_corner].z == hue)
    {
      return float2(display_JMh_corners[lower_corner].x, display_JMh_corners[lower_corner].y);
    }

    // search by lerping between RGB corners for the hue
    const float3 cusp_lower = display_cusp_corners[lower_corner];
    const float3 cusp_upper = display_cusp_corners[upper_corner];
    float3       sample;

    float sample_t;
    float2 bounds = {
      1.0f,
      (upper_corner == previous.x) ? previous.y : 0.0f // If we are still on the same segment start from where we left off
    };

    float3 JMh;

    while ((bounds[INTERVAL_HIGH] - bounds[INTERVAL_LOW]) > tolerance)
    {
      sample_t = midpoint(bounds);
      sample   = lerp(cusp_lower, cusp_upper, sample_t);
      JMh      = XYZ_to_JMh(sample, rgb_conditions);
     
      // There is an edge case where we need to search towards the range when across the [0.0f, hue_limit) boundary
      // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make
      // sure we are still in the expected range between the lower and upper corner hue limits
      //
      // Complex conditional we are looking inside the interval
      //
      //    Lower      hue     Upper     =>   Condition        =>  Bound to change
      //     (          |        )
      //  z                              =>   sample <= lower  =>  upper
      //        z                        =>   sample <= hue    =>  lower
      //                   z             =>   sample >  hue    =>  uppper
      //                             z   =>   sample >= upper  =>  lower
      bounds[(JMh.z >= display_JMh_corners[upper_corner].z)
          || (JMh.z <= hue && JMh.z > display_JMh_corners[lower_corner].z)] = sample_t;
    }

    // Use the midpoint of the final interval for the actual samples
    sample_t = midpoint(bounds);
    sample   = lerp(cusp_lower, cusp_upper, sample_t);
    JMh      = XYZ_to_JMh(sample, rgb_conditions);

    previous.x = upper_corner;
    previous.y = sample_t;

    return float2(JMh.x, JMh.y);
  }

  void initialise_cusp_table(float4 output_table[totalTableSize], const float luminance, const float3 display_cusp_corners[totalCornerCount],
                             const float3 display_JMh_corners[totalCornerCount], const int conditions,
                             const float2 smooth_cusp_scale, float upperHullGamma, float lowerHullGamma)
  {
    upperHullGamma = 1.0f / upperHullGamma;
    lowerHullGamma = 1.0f / lowerHullGamma;

    // the 'tempTableUnsorted' table is populated
    // in increments of H of the limiting gamut HSV space starting at H=0.0
    // since it is unlikely that HSV.H=0 and JMh.h=0 line up
    // the entries are then wrap-around shifted
    // so that the 'gamutCuspTable' starts with the lowest JMh.h value
    float2 previous = { 0.0f, 0.0f };
    for (int i = 1; i != gamutCuspTableSize + 1; ++i)
    {
      const float  hue = hueTable[i];
      const float2 JM  = find_display_cusp_for_hue(hue, display_cusp_corners, display_JMh_corners, conditions, hueFindingTolerance, previous) * smooth_cusp_scale;
      output_table[i]  = float4(JM.x, JM.y, upperHullGamma, lowerHullGamma);
    }

    // Copy extra entries to ease the code to handle hues wrapping around
    output_table[0]                              = output_table[baseIndex + gamutCuspTableSize - 1];
    output_table[baseIndex + gamutCuspTableSize] = output_table[baseIndex];
  }

  void precompute_reach_table(float reachMTable[totalTableSize], const float limitJ, const float3x3& xyz_matrix, const float3x3& rgb_matrix,
                              const int conditions)
  {
    float guestimate = 100.0f; // TODO: probably could scale this based on peak luminance
    for (int i = 0; i != totalTableSize; ++i)
    {
      const float hue = hueTable[i];
      reachMTable[i]  = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions, guestimate);
      guestimate = reachMTable[i];
    }
  }

  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions, float & high)
  {
    const float search_range = 50.0;
    float2      bounds       = { high, min(0.0f, high - search_range) };  // TODO: is this enough of a range for worst case?
    bool        outside      = false;

    while (!outside && bounds[INTERVAL_HIGH] < 1400.0)
    {
      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, bounds[INTERVAL_HIGH], hue), matrix, conditions));
      if (!outside)
      {
        bounds[INTERVAL_LOW]  =  bounds[INTERVAL_HIGH];
        bounds[INTERVAL_HIGH] += search_range;
      }
    }

    while ((bounds[INTERVAL_HIGH] - bounds[INTERVAL_LOW]) > threshold)
    {
      const float sampleM = midpoint(bounds);
      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));
      bounds[!outside] = sampleM;
    }
    return bounds[INTERVAL_HIGH];
  }

  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)
  {
    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f || newLimitRGB.x > maxRGBtestVal
            || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal);
  }

  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope, const float midJ,
                               const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,
                               const float2 estimated_hull_gammas, const int conditions)
  {
    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);
    const float analytical_threshold = compute_analytical_threshold(JMcusp.x, limitJmax, focusGainBlend);
    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);

    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);
    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);
    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);
    const float approxLimit =
      findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, _clamped_smoothness, estimated_hull_gammas, slope);
    const float J_boundary = slope * approxLimit + intersectJ;

    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);
    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);
    return newLimitRGB;
  }

  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh[], const int test_count, const float2 estimated_hull_gammas,
                               const float limitJmax, const float base_slope, const float midJ, const float cuspMidBlend,
                               const float focusAdjustGain, const float focusGainBlend, const float luminance, const int conditions)
  {
    for (int testIndex = 0; testIndex != test_count; ++testIndex)
    {
      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh[testIndex], limitJmax, base_slope, midJ, cuspMidBlend, focusAdjustGain,
                                                       focusGainBlend, estimated_hull_gammas, conditions);

      if (!outside_hull(newLimitRGB, luminance))
      {
        return false;
      }
    }
    return true;
  }

  void initialise_upper_hull_gamma(float4 table[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,
                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend, const float luminance,
                                   const int conditions)
  {
    // Find upper hull gamma values for the gamut mapper
    // start by taking a h angle
    // get the cusp J value for that angle
    // find a J value halfway to the Jmax
    // iterate through gamma values until the approximate max M is negative through the actual boundary

    // positions between the cusp and Jmax we will check
    // variables that get set as we iterate through, once all are set to true we break the loop
    const int   test_count                = 5;
    const float testPositions[test_count] = {0.01f, 0.1f, 0.5f, 0.8f, 0.99f};
    if (!disableUpperHullGamma)
    {
      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)
      {
        //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working
        const float  hue    = hueTable[i];
        const float4 cusp   = table[i];
        const float2 JMcusp = float2(cusp.x, cusp.y);

        float3 testJmh[test_count];
        for (int testIndex = 0; testIndex != test_count; ++testIndex)
        {
          // create test values between the cusp and the Jmax
          testJmh[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions[testIndex]), JMcusp.y, hue);
        }

        const float search_range = gammaSearchStep;
        float2      bounds       = { gammaMinimum + search_range, gammaMinimum };
        bool        all_inside   = true;

        while (all_inside && bounds[INTERVAL_HIGH] < gammaMaximum)
        {
          const float2 estimated_hull_gammas = float2(bounds[INTERVAL_HIGH], table[i][LOWER_GAMMA]);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax, base_slope, midJ, cuspMidBlend,
                                               focusAdjustGain, focusGainBlend, luminance, conditions);
          if (all_inside)
          {
            bounds[INTERVAL_LOW]  =  bounds[INTERVAL_HIGH];
            bounds[INTERVAL_HIGH] += search_range;
          }
        }

        float testGamma = -1.0;
        while ((bounds[INTERVAL_HIGH] - bounds[INTERVAL_LOW]) > gammaAccuracy)
        {
          testGamma                          = midpoint(bounds);
          const float2 estimated_hull_gammas = float2(testGamma, table[i][LOWER_GAMMA]);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax, base_slope, midJ, cuspMidBlend,
                                               focusAdjustGain, focusGainBlend, luminance, conditions);
          bounds[all_inside] = testGamma;
        }
        table[i][UPPER_GAMMA] = testGamma;
      }
    }
    // Wrap the end entries
    table[0]                              = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  inline bool any_below_zero(const float3 newLimitRGB)
  {
    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f);
  }

  void initialise_lower_hull_gamma(float4 table[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,
                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend, const float luminance,
                                   const int conditions)
  {
    // Same process, for the bottom hull gamma
    const int   test_count                = 5;
    const float testPositions[test_count] = {0.01f, 0.1f, 0.4f, 0.6f, 0.75f};
    const float fixed_gamma               = 1.0f / lowerHullGamma;
    if (!disableLowerHullGamma)
    {
      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)
      {
        const float4 cusp   = table[i];
        const float2 JMcusp = float2(cusp.x, cusp.y);
        const float  hue    = hueTable[i];

        float3 testJmh[test_count];
        for (int testIndex = 0; testIndex != test_count; ++testIndex)
        {
          testJmh[testIndex] = float3(JMcusp.x * testPositions[testIndex], JMcusp.y, hue);
        }

        const float search_range = gammaSearchStep;
        float2      bounds       = { gammaMinimum + search_range, gammaMinimum };
        bool        all_inside   = true;

        while (all_inside && bounds[INTERVAL_HIGH] < gammaMaximum)
        {
          const float2 estimated_hull_gammas = float2(table[i][UPPER_GAMMA], bounds[INTERVAL_HIGH]);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax, base_slope, midJ, cuspMidBlend,
                                               focusAdjustGain, focusGainBlend, luminance, conditions);
          if (all_inside)
          {
            bounds[INTERVAL_LOW]  =  bounds[INTERVAL_HIGH];
            bounds[INTERVAL_HIGH] += search_range;
          }
        }

        float testGamma = -1.0;
        while ((bounds[INTERVAL_HIGH] - bounds[INTERVAL_LOW]) > gammaAccuracy)
        {
          testGamma                          = midpoint(bounds);
          const float2 estimated_hull_gammas = float2(table[i][UPPER_GAMMA], testGamma);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax, base_slope, midJ, cuspMidBlend,
                                               focusAdjustGain, focusGainBlend, luminance, conditions);
          bounds[all_inside] = testGamma;
        }
        table[i][LOWER_GAMMA] = testGamma;
      }
    }
    table[0]                              = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  float replace_gamma_entry(float4 table[totalTableSize], int entry, int channel)
  {
    // Very simple patch up, try to find good values either side and lerp a new value
    int lower = entry - 1;
    while (lower >= 0)
    {
      if (!bad_gamma_value(table[lower][channel]))
        break;
      lower = lower - 1;
    }
    if (lower < 0)
      return -1.0f; // Give up if we can't find a good entry below

    int upper = entry + 1;
    while (upper < baseIndex + gamutCuspTableSize)
    {
      if (!bad_gamma_value(table[upper][channel]))
        break;
      upper = upper + 1;
    }
    if (upper == totalTableSize)
      return -2.0f; // Give up nothing above us

    float lower_hue = hueTable[lower];
    float upper_hue = hueTable[upper];
    float entry_hue = hueTable[entry];
    float lerp_loc  = (entry_hue - lower_hue) / (upper_hue - lower_hue);
    return lerp(table[lower][channel], table[upper][channel], lerp_loc);
  }

  bool bad_gamma_value(const float value)
  {
    return ((value <= 0.0f) || (value <= gammaMinimum + badGammaTolerance) || (value >= gammaMaximum - badGammaTolerance));
  }

  void repair_broken_gamma_values(float4 table[totalTableSize])
  {
    for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)
    {
      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)
      {
        if (bad_gamma_value(table[i][channel]))
        {
          table[i][channel] = replace_gamma_entry(table, i, channel);
        }
      }
    }
    table[0]                              = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  inline float degree_of_adaptation(float F, float _L_A)
  {
    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));
    return D;
  }

  inline float3 extract_row(const float3x3 matrix, int row)
  {
    return {matrix[row][0], matrix[row][1], matrix[row][2]};
  }

  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)
  {
    return weight * extract_row(matrix, row);
  }

  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)
  {
    float3x3 matrix = {a.x, a.y, a.z, b.x, b.y, b.z, c.x, c.y, c.z};
    return matrix.invert();
  }

  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK, bool discountIlluminant,
                          int stage, float3x3 CAT_CAT16, const float3 panlrcm_fwd[3], float3 panlrcm_inv[3])
  {
    surround[stage] = viewingConditionsToSurround(conditions);
    //HK_mode[stage]  = HK;

    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;

    // # Step 0
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);

    // # Computing degree of adaptation :math:`D`.
    if (!discountIlluminant)
    {
      float D      = clamp(degree_of_adaptation(surround[stage].x, _L_A), 0.0f, 1.0f);
      D_RGB[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;
    }
    else
    {
      D_RGB[stage] = XYZ_w_scaled.y / RGB_w;
    }

    const float k    = 1.0f / (5.0f * _L_A + 1.0f);
    const float k4   = k * k * k * k;
    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);
    F_L[stage]       = _F_L / nl_normalise; //TODO white scale?

    // # FWd Step 1
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    //float3 RGB = vector_dot(CAT_CAT16, XYZ);
    //float3 RGB_c = D_RGB[conditions] * RGB; // combine with CAT16

    // Pre weight CAT16 matrix by D
    DL_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].x, CAT_CAT16, 0);
    DM_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].y, CAT_CAT16, 1);
    DS_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].z, CAT_CAT16, 2);

    // # Inv Step 6
    //const float3 RGB = RGB_c / D_RGB[conditions];
    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);
    const float3x3 tempmat = constuct_inverse_matrix(DL_weights[stage], DM_weights[stage], DS_weights[stage]);
    DL_weights_inv[stage]  = extract_row(tempmat, 0);
    DM_weights_inv[stage]  = extract_row(tempmat, 1);
    DS_weights_inv[stage]  = extract_row(tempmat, 2);

    // Prescale values
    surround[stage].y = surround[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);
    surround[stage].z = surround[stage].z * 43.0f;

    // # Computing achromatic responses for the whitepoint.
    const float3 RGB_wc = D_RGB[stage] * RGB_w;
    // Needs to use original as we have not setup alternates at this point
    // Assumes White falls on the original curve
    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L[stage] * RGB_wc);
    const float  A_w    = dot(panlrcm_fwd[0], RGB_aw);

    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?
    y_to_j_A_w[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);

    F_L[stage] *= XYZ_w_scaler; // Allows tonescale multiplier to be removed

    achromatic_weights[stage] = panlrcm_fwd[0] / A_w;
    a_weights[stage]          = panlrcm_fwd[1] * surround[stage].z;
    b_weights[stage]          = panlrcm_fwd[2] * surround[stage].z;

    const float3 column_weights   = float3(A_w, 1.0f / surround[stage].z, 1.0f / surround[stage].z);
    achromatic_weights_inv[stage] = panlrcm_inv[0] * column_weights;
    a_weights_inv[stage]          = panlrcm_inv[1] * column_weights;
    b_weights_inv[stage]          = panlrcm_inv[2] * column_weights;
  }

  void init_Hellwig_model(float3x3 CAT_CAT16, const float3 inputWhite, const float3 limitWhite)
  {
    float3 panlrcm_fwd[3];
    float3 panlrcm_inv[3];
    generate_panlrcm(panlrcm_fwd, panlrcm_inv);
    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS, CAT_CAT16,
                       panlrcm_fwd, panlrcm_inv);
    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS, CAT_CAT16,
                       panlrcm_fwd, panlrcm_inv);
  }

  void init_cusp_tables(const float2 smooth_cusp_scale)
  {
#ifndef COMPILE_DIAGNOSTICS
    float3 reach_JMh_corners[totalCornerCount];
    float3 display_cusp_corners[totalCornerCount];
    float3 display_JMh_corners[totalCornerCount];
    float  cube_hues[2 * cuspCornerCount];
    int    unique_hues;
#endif
    // Fist find the unique hues for the cusp corners, then fill in the table uniformly between those hues
    find_reach_corners_tables(reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _limitJmax, _input_upper_clamp);
    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);
    unique_hues = extract_sorted_cube_hues(cube_hues, reach_JMh_corners, display_JMh_corners);
    build_hue_table(hueTable, cube_hues, unique_hues);

    initialise_cusp_table(limitingGamutCuspTable, _peakLuminance, display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS,
                           smooth_cusp_scale, upperHullGamma, lowerHullGamma);
    // Iterate gamma finding based on previous values
    for (int i = 0; i != 3; ++i)
    {
      initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend,
                                  _peakLuminance, DISPLAY_CONDITIONS);
      initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend,
                                  _peakLuminance, DISPLAY_CONDITIONS);
    }
    repair_broken_gamma_values(limitingGamutCuspTable);

    precompute_reach_table(reachMTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS);
  }

  void init()
  {
    const float log_peak = init_tonescale_constants(_peakLuminance);

    float3x3 CAT_CAT16;
    init_matrices(CAT_CAT16);

    const float3   white(1.0f, 1.0f, 1.0f);
    const float3   inputWhite = vector_dot(AP1_to_XYZ, white);
    const float3   limitWhite = vector_dot(RGB_to_XYZ_limit, white);

    init_Hellwig_model(CAT_CAT16, inputWhite, limitWhite);

    init_chroma_compression(_peakLuminance, log_peak);
    const float2 smooth_cusp_scale = init_gamut_mapper(_peakLuminance, log_peak, limitWhite);

    init_cusp_tables(smooth_cusp_scale);
  }

#ifdef USE_DEGREES
  // convert radians to degrees
  inline float degrees(float radians)
  {
    return radians * 180.0f / PI;
  }

  // convert degrees to radians
  inline float to_radians(float hue)
  {
    return hue / 180.0f * PI;
  }
#endif

  inline float wrap_hue(float hue)
  {
    float y = fmod(hue, hue_limit);
    if (y < 0.0)
    {
      y = y + hue_limit;
    }
    return y;
  }

  // multiplies a 3D vector with a 3x3 matrix
  inline float3 vector_dot(const float3x3& m, const float3 v)
  {
    float3 r;
    for (int c = 0; c != 3; ++c)
    {
      r[c] = m[c][0] * v.x + m[c][1] * v.y + m[c][2] * v.z;
    }

    return r;
  }

  float3 clamp_to_AP1(float3 XYZ)
  {
    if (AP1Clamp)
    {
      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);
      RGB        = clamp(RGB, float3(0.0f), float3(_input_upper_clamp));
      XYZ        = vector_dot(AP1_to_XYZ, RGB);
    }
    return XYZ;
  }

  inline float _post_adaptation_non_linear_response_compression_forward(float L)
  {
    const float F_L_L = pow(L, float(nl_gamma));
    return F_L_L / (nl_offset + F_L_L);
  }

  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)
  {
    const float3 F_L_RGB = pow(RGB, float3(nl_gamma));
    return F_L_RGB / (nl_offset + F_L_RGB);
  }

  inline float _post_adaptation_non_linear_response_compression_inverse(float A)
  {
    const float F_L_A = (nl_offset * A) / (1.0f - A);
    return pow(F_L_A, 1.0f / nl_gamma);
  }

  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)
  {
    const float3 F_L_RGB = (nl_offset * RGB) / (1.0f - RGB);
    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma));
    return RGB_p;
  }

  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)
  {
    const float3 absRGB = fabs(RGB);
    const float3 RGB_c  = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);
    return RGB_c;
  }

  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)
  {
    const float3 absRGB = fabs(RGB);
    const float3 RGB_p  = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);
    return RGB_p;
  }

  //  // Return compression gamut cusp M scaled with an eccentricity factor
  //  inline float eccentricity_factor(float hr, bool apply_eccentricity)
  //  {
  //    if (!apply_eccentricity)
  //    {
  //        return 1.0f;
  //    }
  //
  //    // Hellwig2022/Helles2023
  //    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg
  //    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)
  //    const float _2_hr = 2 * hr;
  //    const float _3_hr = 3 * hr;
  //    const float _4_hr = 4 * hr;
  //    // clang-format off
  //    return (
  //        - 0.0582f * cos(_1_hr)
  //        - 0.0258f * cos(_2_hr)
  //        - 0.1347f * cos(_3_hr)
  //        + 0.0289f * cos(_4_hr)
  //        - 0.1475f * sin(_1_hr)
  //        - 0.0308f * sin(_2_hr)
  //        + 0.0385f * sin(_3_hr)
  //        + 0.0096f * sin(_4_hr)
  //        + 1.0f
  //      );
  //    // clang-format on
  //  }

  // XYZ to Hellwig2020 JMh
  //
  //     XYZ
  //         *CIE XYZ* tristimulus values of test sample / stimulus.
  //     XYZ_w
  //         *CIE XYZ* tristimulus values of reference white.
  //     L_A
  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken
  //         to be 20% of the luminance of a white object in the scene).
  //     Y_b
  //         Luminous factor of background :math:`Y_b` such as
  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the
  //         light source and :math:`L_b` is the luminance of the background. For
  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the
  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,
  //         approximate an :math:`L^*` of 50 is used.
  //     surround // TODO
  //         Surround viewing conditions induction factors.
  //         Truth value indicating if the illuminant should be discounted.
  //     discount_illuminant
  //
  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:
  //
  // - Custom primaries
  //
  inline float _J_from_Achromatic(float A, int conditions)
  {
    return j_scale * pow(A, surround[conditions].y);
  }

  inline float _Achromatic_from_J(float J, int conditions)
  {
    return pow(J / j_scale, 1.0f / surround[conditions].y);
  }

  inline float J_from_Achromatic(float A, int conditions)
  {
    return sign(A) * _J_from_Achromatic(fabs(A), conditions);
  }

  inline float Achromatic_from_J(float J, int conditions)
  {
    return sign(J) * _Achromatic_from_J(fabs(J), conditions);
  }

  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates
  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters
  float3 XYZ_to_JMh(float3 XYZ, int conditions)
  {
    float3 RGB_c;
    RGB_c.x = dot(DL_weights[conditions], XYZ);
    RGB_c.y = dot(DM_weights[conditions], XYZ);
    RGB_c.z = dot(DS_weights[conditions], XYZ);

    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);

    const float A = dot(achromatic_weights[conditions], RGB_a);
    const float a = dot(a_weights[conditions], RGB_a);
    const float b = dot(b_weights[conditions], RGB_a);

    // # Computing the *hue* angle
    const float hr = atan2(b, a);
#ifdef USE_DEGREES
    const float h = wrap_hue(degrees(hr));
#else
    const float h = wrap_hue(hr);
#endif

    // # Step 7
    // # Computing the correlate of *Lightness*
    float J = J_from_Achromatic(A, conditions);

    //if (HK_mode[conditions])
    //{
    //  // # Computing the correlate of *chroma*
    //  const float C = 35.0f * M / A_w[conditions];
    //  J = sqrt(J * J + 66.0f * C);
    //}

    // # Step 9
    // # Computing the correlate of *colourfulness*
    //const float et = eccentricity_factor(hr, false);
    //float       M  = surround[conditions].z * et * sqrt(a * a + b * b);
    float M = sqrt(a * a + b * b); // Valid as et == 1.0

    return {J, M, h};
  }

  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values
  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters
  float3 JMh_to_XYZ(float3 JMh, int conditions)
  {
    float       J = JMh.x;
    const float M = JMh.y;
#ifdef USE_DEGREES
    const float hr = to_radians(JMh.z);
#else
    const float hr = JMh.z;
#endif

    // # *HelmholtzKohlrausch* Effect Extension.
    //if (HK_mode[conditions])
    //{
    //  const float C = (M * 35.0f) / A_w[conditions];
    //  J             = sqrt(J * J - 66.0f * C);
    //}

    // # Computing achromatic response :math:`A` for the stimulus.
    const float _A = Achromatic_from_J(J, conditions);

    // # Computing *P_p_1* to *P_p_2*.
    //const float et    = eccentricity_factor(hr, false);
    //const float P_p_1 = surround[conditions].z; // * et;
    //const float P_p_2 = A;

    // # Step 3
    // # Computing opponent colour dimensions
    const float gamma = M;
    const float a     = gamma * cos(hr);
    const float b     = gamma * sin(hr);

    // # Step 4
    // # Applying post-adaptation non-linear response compression matrix.
    const float3 Aab = float3(_A, a, b);
    //const float3 RGB_a = vector_dot(panlrcm, Aab);
    float3 RGB_a;
    RGB_a.x = dot(achromatic_weights_inv[conditions], Aab);
    RGB_a.y = dot(a_weights_inv[conditions], Aab);
    RGB_a.z = dot(b_weights_inv[conditions], Aab);

    // # Step 5
    // # Applying inverse post-adaptation non-linear response compression.
    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);

    float3 XYZ;
    XYZ.x = dot(DL_weights_inv[conditions], RGB_c);
    XYZ.y = dot(DM_weights_inv[conditions], RGB_c);
    XYZ.z = dot(DS_weights_inv[conditions], RGB_c);

    return XYZ;
  }

  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)
  {
    return int(wrapped_hue / hue_limit * table_size);
  }

  // linear interpolation between two values a & b with the bias t
  inline float lerp(float a, float b, float t)
  {
    return a + t * (b - a);
  }
  inline float2 lerp(float2 a, float2 b, float t)
  {
    return a + t * (b - a);
  }
  inline float3 lerp(float3 a, float3 b, float t)
  {
    return a + t * (b - a);
  }
  inline float4 lerp(float4 a, float4 b, float t)
  {
    return a + t * (b - a);
  }

  // Smooth minimum of a and b (cubic polynomial)
  float smin(float a, float b, float s)
  {
    float h = max(s - fabs(a - b), 0.0f) / s;
    return min(a, b) - h * h * h * s * (1.0f / 6.0f);
  }

  inline float smin_s(float a, float b, float s, float normalise)
  {
    const float s_scaled     = s * normalise;
    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;
    const float h            = max(scaled_delta, 0.0f);
    return min(a, b) - h * h * h * s * (1.0f / 6.0f);
  }

  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'
  // cusps are very expensive to compute
  // and the DRT is only using them for lightness mapping
  // which does not require a high degree of accuracy
  // so instead we use a pre-computed table of cusp points
  // sampled at 1 degree hue intervals of the the RGB target gamut
  // and lerp between them to get the approximate J & M values
  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates
  // the samples are spaced by HSV hue increments of the limiting RGB gamut
  // so to find the correct entry for a given CAM hue (h) value
  // one must search the table entries for the matching entry.z component

  int lookupLimitingCuspHue(float wrapped_hue)
  {
    // samples are almost uniform should be able to find the correct entry +/- 6 entries from middle
    // on average it is actually in a narrow range than this, left as an exercise for the reader to
    // improve this, typically lies in upper half
    // either way log2(search_range*2) is way smaller than log2(gamutCuspTableSize)
    // BUG: needs checking if this range is too small should all the hues cluster together due to a
    // pathological triangle formed by two primaries from one gamut closely bracketing one from the other
#define search_range 2
    int  i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;
    int2 bounds = {
      // Order is high value, low value for the address calculation below to be correct
      min(baseIndex + gamutCuspTableSize, i + search_range), // Allowed as we have extra entries in the table
      max(0, i - search_range)
    };

    while (bounds[INTERVAL_LOW] + 1 < bounds[INTERVAL_HIGH])
    {
      bounds[wrapped_hue > hueTable[i]] = i; // Note this address calculation relies on 'true' mapping to 1 and 'false' to 0
      i = midpoint(bounds);
    }
    return bounds[INTERVAL_HIGH];
  }

  float limiting_lerp_fraction(float wrapped_hue, int pos)
  {
    return (wrapped_hue - hueTable[pos - 1]) / (hueTable[pos] - hueTable[pos - 1]);
  }

  inline float4 limitingCuspFromTable(int pos, float t)
  {
    return lerp(limitingGamutCuspTable[pos - 1], limitingGamutCuspTable[pos], t);
  }

  inline float reachMFromTable(int pos, float t)
  {
    return lerp(reachMTable[pos - 1], reachMTable[pos], t);
  }

  // https://www.desmos.com/calculator/oe2fscya80
  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)
  {
    // Assume J (0.0, limitJmax)

    if (J <= analytical_threshold)
      return 1.0f; // makes the analytic inverse possible below cusp

    // Approximate inverse required above threshold TODO: explain why
    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));
    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;
  }

  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax, const float focusAdjustGain,
                                  const float analytical_threshold)
  {
    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);
  }

  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py
  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)
  {
    const float a = JM.y / (focusJ * slope_gain);
    float b;
    float c;
    float root;

    if (JM.x < focusJ)
    {
      b = 1.0f - JM.y / slope_gain;
      c = -JM.x;
      root = -sqrt(b * b - 4.0f * a * c); // Note negative
    }
    else
    {
      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));
      c = maxJ * JM.y / slope_gain + JM.x;
      root = sqrt(b * b - 4.0f * a * c);
    }
    return 2.0f * c / (-b + root);
  }

  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)
  {
    float direction_scaler;
    if (intersectJ <= focusJ)
    {
      direction_scaler = intersectJ;
    }
    else
    {
      direction_scaler = (limitJmax - intersectJ);
    }

    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);
  }

  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope, const float inv_gamma,
                                                         const float J_max, const float M_max, const float J_intersection_reference)
  {
    // Line defined by     J = slope * x + J_axis_intersect
    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)
    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential

    // We calculate a shifted intersection from the original intersection using the inverse of the exponential
    // and the provided reference
    const float normalised_J         = J_axis_intersect / J_intersection_reference;
    const float shifted_intersection = J_intersection_reference * pow(normalised_J, inv_gamma);

    // Now we find the M intersection of two lines
    // line from origin to J,M Max       l1(x) = J/M * x
    // line from J Intersect' with slope l2(x) = slope * x + Intersect'

    return shifted_intersection / ((J_max / M_max) - slope);
    //return shifted_intersection * M_max / (J_max - slope * M_max);
  }

  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py
  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,
                                       float2 estimated_hull_gammas, const float slope)
  {
    const float gamma_top    = estimated_hull_gammas.x;
    const float gamma_bottom = estimated_hull_gammas.y;

    const float M_boundary_lower =
      estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);

    // The upper hull is flipped and thus 'zeroed' at J_max
    // Also note we negate the slope
    const float f_J_intersect_cusp   = J_max - J_intersect_cusp;
    const float f_J_intersect_source = J_max - J_intersect_source;
    const float f_JM_cusp_J          = J_max - JM_cusp.x;
    const float M_boundary_upper =
      estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);

    // Smooth minimum between the two calculated values for the M component
    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);
    return M_boundary;
    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);
  }

  inline float reinhard_compress(const float scale, const float factor, const bool direction)
  {
    if (INVERSE == direction)
    {
      if (factor >= 1.0f)
        return scale;
      else
        return scale * (-(factor / (factor - 1.0f)));
    }
    return scale * (factor) / (1.0f + factor);
  }

  inline float gamut_mapped_location(const float location, const float gamutBoundary, const float reachBoundary, const bool direction)
  {
    // Assumes _compressionFuncParams in (0.0, 1.0)
    const float threshold = clamp(gamutBoundary / reachBoundary, _compressionFuncParams, 0.99999f) * gamutBoundary;

    // Values upto the threshold or when both boundaries are the same remain as is
    if (location <= threshold || gamutBoundary == reachBoundary)
      return location;

    // Translate to place threshold at zero
    const float location_offset = location - threshold;
    const float boundary_offset = gamutBoundary - threshold;
    const float reach_offset    = reachBoundary - threshold;

    // Assumes boundary != reach
    // Generally speaking boundary should be < reach
    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);
    const float factor = location_offset / scale;

    const float relative_location = reinhard_compress(scale, factor, direction);

    return (threshold + relative_location); // shift back to absolute
  }

  float2 gamutMapJM(float2 JM, const bool direction, float limitJmax, float slope_gain, float2 JMcusp, float focusJ, float2 estimated_hull_gammas,
                    float smoothness, float reachMaxM, float model_gamma)
  {
    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);
    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);
    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);
    const float ganutBoundaryM =
      findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, smoothness, estimated_hull_gammas, slope);

    if (ganutBoundaryM <= 0.0f)
    {
      // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)
      return float2(JM.x, 0.0f);
    }

    // Compress the out of gamut color along the projection line
    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);
    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);
    const float mappedJ  = slope * mappedM + intersectJ;

    return float2{mappedJ, mappedM};
  }

  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)
  {
    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));
  }

  inline float compute_analytical_threshold(const float cuspJ, const float limitJmax, const float focusGainBlend)
  {
    return lerp(cuspJ, limitJmax, focusGainBlend);
  }

  float3 _gamutMapper(const float3 JMh, const float4 cusp, const float reachM, const bool direction)
  {
    // Hue dependent, but as hue does not change we can compute them equally for both directions.
    const float2 JMcusp                = float2(cusp.x, cusp.y);
    const float2 estimated_hull_gammas = float2{cusp[UPPER_GAMMA], cusp[LOWER_GAMMA]};
    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x, _limitJmax, _focusGainBlend);
    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);

    float  Jx         = JMh.x;
    float2 JM         = float2{JMh.x, JMh.y};
    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);

    if (INVERSE == direction)
    {
      // Inverse path is a multi-step iterative to solve for the original 'J'
      // Analytic inverse below threshold extra pass approximation above
      if (Jx > analytical_threshold)
      {
        Jx =
          gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas, _clamped_smoothness, reachM, _model_gamma).x;
        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);
      }
    }
    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas, _clamped_smoothness, reachM, _model_gamma);

    return {JM.x, JM.y, JMh.z};
  }

  inline float3 gamutMapper(float3 JMh, const float4 cusp, const float reachM, const bool direction)
  {
    // Limit to +ve values // TODO test this is needed
    if (JMh.x <= 0.0f)
    {
      JMh.x = 0.0f;
      JMh.y = 0.0f;
    }
    // Above the expected maximum we explicitly map to 0 M
    if (JMh.x >= _limitJmax)
    {
      JMh.y = 0.0f;
    }

    // We compress M only so avoid mapping zero
    if (JMh.y == 0.0f)
      return JMh;

    return _gamutMapper(JMh, cusp, reachM, direction);
  }

  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates
  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, const int conditions)
  {
    const float3 XYZ = vector_dot(matrix, RGB);
    const float3 JMh = XYZ_to_JMh(XYZ, conditions);
    return JMh;
  }

  float3 JMh_to_linear_RGB(const float3 JMh, const float3x3& matrix, const int conditions)
  {
    const float3 XYZ = JMh_to_XYZ(JMh, conditions);
    const float3 RGB = vector_dot(matrix, XYZ);
    return RGB;
  }

  float init_tonescale_constants(float peakLuminance)
  {
    // pre-calculate aces_ts  constants
    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions

    const float aces_ts_n     = peakLuminance;
    const float aces_ts_m_0   = aces_ts_n / aces_ts_n_r;
    const float aces_ts_r_hit = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_m_0) / log(10000.0f / 100.0f));
    _input_upper_clamp =
      aces_ts_r_hit * 8.0f * _XYZ_w_scaler; // (3 stops) above that needed to max out // TODO magic 8 ball factor needs assessing

    const float aces_ts_m_1  = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));
    const float aces_ts_u    = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);
    const float aces_ts_m    = aces_ts_m_1 / aces_ts_u;
    const float aces_ts_w_i  = log(aces_ts_n / 100.0f) / log(2.0f);
    aces_ts_c_t              = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;
    const float aces_ts_g_ip = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));
    const float aces_ts_g_ipp2 =
      -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);
    const float aces_ts_w_2 = aces_ts_c / aces_ts_g_ipp2;
    aces_ts_s_2             = (aces_ts_w_2 * aces_ts_m_1);
    const float aces_ts_u_2 = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);
    aces_ts_m_2             = aces_ts_m_1 / aces_ts_u_2;
    //aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?
    return log10(aces_ts_m_0);
  }

  // ACES Tonescale function, proposed by Daniele Siragusano
  inline float aces_ts_fwd(const float Y)
  {
    // Assumes Y is >= +0.0
    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);
    return max(0.0f, f * f / (f + aces_ts_t_1)); // max prevents -ve values being output also handles division by zero possibility
  }

  inline float aces_ts_rev(const float Y)
  {
    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?
    const float f = (Y + sqrt(Y * (4.0f * aces_ts_t_1 + Y))) / 2.0f;
    return aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);
  }

  // Short cut functions used to convert known mono-chromatic Y<->J rather than the full model
  inline float _Y_to_Hellwig_J(float Y, int conditions)
  {
    // Assumes Y is >= +0.0
    const float A = _post_adaptation_non_linear_response_compression_forward(F_L[conditions] * Y) / y_to_j_A_w[conditions];
    return _J_from_Achromatic(A, conditions);
  }

  inline float _Hellwig_J_to_Y(float J, int conditions)
  {
    // Assumes J is >= +0.0
    const float A = y_to_j_A_w[conditions] * _Achromatic_from_J(J, conditions);
    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L[conditions];
  }

  //  inline float Y_to_Hellwig_J(float Y, int conditions)
  //  {
  //    const float absY = fabs(Y);
  //    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?
  //  }
  //
  //  inline float Hellwig_J_to_Y(float J, int conditions)
  //  {
  //    const float absJ = fabs(J);
  //    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?
  //  }

  float3 forwardTonescale(float3 inputJMh, int conditions)
  {
    const float inputJ      = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below
    const float inputY      = _Hellwig_J_to_Y(inputJ, conditions);
    const float luminanceTS = aces_ts_fwd(inputY);
    const float tonemappedJ = _Y_to_Hellwig_J(luminanceTS, conditions);
    return float3(tonemappedJ, inputJMh.y, inputJMh.z);
  }

  float3 inverseTonescale(float3 JMh, int conditions)
  {
    const float luminance     = _Hellwig_J_to_Y(JMh.x, conditions);
    const float linear        = aces_ts_rev(luminance);
    const float untonemappedJ = _Y_to_Hellwig_J(linear, conditions);
    return float3(untonemappedJ, JMh.y, JMh.z);
  }

  // A "toe" function that remaps the given value x between 0 and limit.
  // The k1 and k2 parameters change the size and shape of the toe.
  // https://www.desmos.com/calculator/6vplvw14ti
  inline float toe(const float x, const float limit, float k1, float k2, const bool inverse)
  {
    if (x > limit)
      return x;

    k2             = max(k2, 0.001f); // TODO; magic constant
    k1             = sqrt(k1 * k1 + k2 * k2);
    const float k3 = (limit + k1) / (limit + k2);

    if (!inverse)
    {
      const float minus_b = k3 * x - k1;
      const float minus_c = k2 * k3 * x;
      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2
    }
    else
      return (x * x + k1 * x) / (k3 * (x + k2));
  }

  // Chroma compression
  //
  // Compresses colors inside the gamut with the aim for colorfulness to have an
  // appropriate rate of change from display black to display white, and from
  // achromatic outward to purer colors.
  //
  float chromaCompressionNorm(float h)
  {
#ifdef USE_DEGREES
    const float  hr = to_radians(h);
#else
    const float  hr = h;
#endif
    const float  cos_hr  = cos(hr);
    const float  sin_hr  = sin(hr);
    const float3 cosines =
    {
      cos_hr,
      2.0f * cos_hr * cos_hr - 1.0f,
      4.0f * cos_hr * cos_hr * cos_hr - 3.0f * cos_hr
    };
    const float3 sines =
    {
      sin_hr,
      2.0f * cos_hr * sin_hr,
      3.0f * sin_hr - 4.0f * sin_hr * sin_hr * sin_hr
    }; 

    return dot(cosines, _chromaCompress_cosFactors) + dot(sines, _chromaCompress_sinFactors) + _chromaCompress_offset;
  }

  inline float _chromaCompression(const float3 JMh, const float origJ, const float reachMMax, const bool inverse, const float limitJmax,
                                  const float model_gamma, const float sat, const float sat_thr, const float compr)
  {
    // Assumes 'h' component is wrapped [0.0, hue_limit)
    float       M                    = JMh.y;
    const float nJ                   = JMh.x / limitJmax;
    const float snJ                  = max(0.0f, 1.0f - nJ);
    const float normalisation_factor = chromaCompressionNorm(JMh.z);
    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor;
    const float toe_limit            = limit - 0.001f; // TODO; magic constant
    const float toe_snJ_sat          = snJ * sat;
    const float toe_sqrt_nJ_sat_thr  = sqrt(nJ * nJ + sat_thr);
    const float toe_nJ_compr         = nJ * compr;
    if (!inverse)
    {
      // Rescaling of M with the tonescaled J to get the M to the same range as
      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to
      // keep the M/J ratio correct (keeping the chromaticities constant).
      M *= pow(JMh.x / origJ, model_gamma);

      // Normalize M with the rendering space cusp M
      M /= normalisation_factor;

      // Expand the colorfulness by running the toe function in reverse.  The goal is to
      // expand less saturated colors less and more saturated colors more.  The expansion
      // increases saturation in the shadows and mid-tones but not in the highlights.
      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes
      // the toe less aggressive near black to reduce the expansion of noise.
      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);

      // Compress the colorfulness.  The goal is to compress less saturated colors more and
      // more saturated colors less, especially in the highlights.  This step creates the
      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This
      // mostly affects highlights and mid-tones, and does not compress shadows.
      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);

      // Denormalize
      M *= normalisation_factor;
    }
    else
    {
      M /= normalisation_factor;
      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);
      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);
      M *= normalisation_factor;
      M *= pow(JMh.x / origJ, -model_gamma);
    }

    return M;
  }

  inline float3 compressChroma(float3 JMh, const float originalJ, const float reachM, const bool inverse)
  {
    if (JMh.y == 0.0f)
      return JMh.y;

    JMh.y = _chromaCompression(JMh, originalJ, reachM, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);
    if (inverse)
      JMh.x = originalJ;

    return JMh;
  }

  float3 apply_DRT(float3 src)
  {
    float3 JMh;
    float3 tonemappedJMh;
    float3 compressedJMh;
    float3 gamutMappedJMh;
    float3 output;

    if (invert)
    {
      gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);
      const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);
      const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);
      const float4 cusp   = limitingCuspFromTable(pos, t);
      const float  reachM = reachMFromTable(pos, t);
      compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);
      tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);
      JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);
      output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);
    }
    else
    {
      float3 clamped      = clamp_to_AP1(src);
      JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);
      const int    pos    = lookupLimitingCuspHue(JMh.z);
      const float  t      = limiting_lerp_fraction(JMh.z, pos);
      const float4 cusp   = limitingCuspFromTable(pos, t);
      const float  reachM = reachMFromTable(pos, t);
      tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);
      compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);
      gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);
      output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);
    }
    return output;
  }

  void process()
  {
    SampleType(src) source = src();
    const float3 src(source.x, source.y, source.z);
    float3       output;

#ifdef COMPILE_DIAGNOSTICS
    if (APPLY_DRT == diagnosticMode)
    {
      output = apply_DRT(src);
    }
    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)
    {
      output = clamp_to_AP1(src);
    }
    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)
    {
      output = XYZ_to_JMh(src, SOURCE_CONDITIONS);
    }
    else if (FORWARDS_forwardTonescale == diagnosticMode)
    {
      output = forwardTonescale(src, SOURCE_CONDITIONS);
    }
    else if (FORWARDS_compressChroma == diagnosticMode)
    {
      const int   pos    = lookupLimitingCuspHue(src.z);
      const float t      = limiting_lerp_fraction(src.z, pos);
      const float reachM = reachMFromTable(pos, t);
      float3      JMh    = inverseTonescale(src, SOURCE_CONDITIONS);
      output             = compressChroma(src, JMh.x, reachM, FORWARDS);
    }
    else if (FORWARDS_gamutMapper == diagnosticMode)
    {
      const int    pos    = lookupLimitingCuspHue(src.z);
      const float  t      = limiting_lerp_fraction(src.z, pos);
      const float4 cusp   = limitingCuspFromTable(pos, t);
      const float  reachM = reachMFromTable(pos, t);
      output              = gamutMapper(src, cusp, reachM, FORWARDS);
    }
    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)
    {
      output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);
    }
    else if (INVERSE_XYZ_to_JMh == diagnosticMode)
    {
      output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);
    }
    else if (INVERSE_gamutMapper == diagnosticMode)
    {
      const int    pos    = lookupLimitingCuspHue(src.z);
      const float  t      = limiting_lerp_fraction(src.z, pos);
      const float4 cusp   = limitingCuspFromTable(pos, t);
      const float  reachM = reachMFromTable(pos, t);
      output              = gamutMapper(src, cusp, reachM, INVERSE);
    }
    else if (INVERSE_inverseTonescale == diagnosticMode)
    {
      output = inverseTonescale(src, SOURCE_CONDITIONS);
    }
    else if (INVERSE_compressChroma == diagnosticMode)
    {
      const int   pos    = lookupLimitingCuspHue(src.z);
      const float t      = limiting_lerp_fraction(src.z, pos);
      const float reachM = reachMFromTable(pos, t);
      float3      JMh    = inverseTonescale(src, SOURCE_CONDITIONS);
      output             = compressChroma(src, JMh.x, reachM, INVERSE);
    }
    else if (INVERSE_JMh_to_XYZ == diagnosticMode)
    {
      output = JMh_to_XYZ(src, SOURCE_CONDITIONS);
    }
    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)
    {
      const float  wrapped_hue = wrap_hue(src.z);
      const int    pos         = lookupLimitingCuspHue(wrapped_hue);
      const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
      const float4 cusp        = limitingCuspFromTable(pos, t);
      output                   = float3(cusp.x, cusp.y, src.z);
    }
    else if (DEBUG_limitingGamutGammas == diagnosticMode)
    {
      const float  wrapped_hue = wrap_hue(src.z);
      const int    pos         = lookupLimitingCuspHue(wrapped_hue);
      const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
      const float4 cusp        = limitingCuspFromTable(pos, t);
      output                   = float3(cusp[UPPER_GAMMA], cusp[LOWER_GAMMA], t);
    }
    else if (DEBUG_reachGamutCuspTable == diagnosticMode)
    {
      const float wrapped_hue = wrap_hue(src.z);
      const int   pos         = lookupLimitingCuspHue(wrapped_hue);
      const float t           = limiting_lerp_fraction(wrapped_hue, pos);
      const float reachM      = reachMFromTable(pos, t);
      output                  = float3(chromaCompressionNorm(src.z), reachM, wrapped_hue);
    }
    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)
    {
      int    index = clamp(int(src.z), 0, totalTableSize);
      float4 cusp  = limitingGamutCuspTable[index];
      output       = float3(cusp.x, cusp.y, cusp.z);
    }
    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)
    {
      int    index = clamp(int(src.z), 0, totalTableSize);
      float4 cusp  = limitingGamutCuspTable[index];
      output       = float3(cusp.x, cusp.y, cusp.w);
    }
    else if (DEBUG_reachMTableRaw == diagnosticMode)
    {
      int   index  = clamp(int(src.z), 0, totalTableSize);
      float reachM = reachMTable[index];
      output       = float3(reachM, src.z, index);
    }

    else if (DEBUG_Jconstants == diagnosticMode)
    {
      output = float3(_midJ, _limitJmax, _focusDist);
    }
    else if (DEBUG_FocusConstants == diagnosticMode)
    {
      output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);
    }
    else if (DEBUG_reachMConditions == diagnosticMode)
    {
      const float wrapped_hue = wrap_hue(src.z);
      float       guestimate  = 100.0f;
      const float sM          = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS, guestimate);
      const float dM          = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS, guestimate);

      output = float3(sM, dM, wrapped_hue);
    }
    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)
    {
      const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);
      output          = float3(gml, src.y, src.z);
    }
    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)
    {
      const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);
      output          = float3(gml, src.y, src.z);
    }
    else if (100 == diagnosticMode)
    {
      const float sm  = src.z * smin(src.x / src.z, src.y / src.z, _clamped_smoothness);
      const float sms = smin_s(src.x, src.y, _clamped_smoothness, src.z);
      output          = float3(sm, sms, src.z);
    }
    else if (102 == diagnosticMode)
    {
      float2 previous = { 0.0f, 0.0f };
      const float  wrapped_hue = wrap_hue(src.z);
      const float2 found       = find_display_cusp_for_hue(wrapped_hue, display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, hueFindingTolerance, previous);
      const float  norm        = chromaCompressionNorm(wrapped_hue);
      output                   = float3(found.x, found.y, norm);
    }
    else if (103 == diagnosticMode)
    {
      const int index = int(src.z) % totalCornerCount;
      output          = reach_JMh_corners[index];
    }

    else if (105 == diagnosticMode)
    {
      const int index = int(src.z) % totalCornerCount;
      output          = display_JMh_corners[index];
    }
    else if (106 == diagnosticMode)
    {
      output = float3(_input_upper_clamp / _XYZ_w_scaler);
    }
    else if (107 == diagnosticMode)
    {
      const int index = int(src.z) % (2 * cuspCornerCount);
      output          = float3(cube_hues[index], index, unique_hues);
    }
    else if (108 == diagnosticMode)
    {
      const float wrapped_hue = wrap_hue(src.z);
      const int   pos         = lookupLimitingCuspHue(wrapped_hue);
      const float t           = limiting_lerp_fraction(wrapped_hue, pos);
      const int   i           = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;

      output = float3(float(pos), pos + t, float(i));
    }
    else if (109 == diagnosticMode)
    {
      int   index = clamp(int(src.z), 0, totalTableSize);
      float hue   = hueTable[index];
      output      = float3(float(index), hue, hue);
    }
    else if (110 == diagnosticMode)
    {
      const float wrapped_hue  = wrap_hue(src.z);
      const int   pos          = lookupLimitingCuspHue(wrapped_hue);
      const float t            = limiting_lerp_fraction(wrapped_hue, pos);
      const float computed_hue = lerp(hueTable[pos - 1], hueTable[pos], t);
      output                   = float3(computed_hue, wrapped_hue, src.z);
    }
    else if (111 == diagnosticMode)
    {
      const int stage = clamp(int(src.z), 0, NUMBER_CONDITIONS);
      output          = DL_weights[stage];
    }
    else if (112 == diagnosticMode)
    {
      const int stage = clamp(int(src.z), 0, NUMBER_CONDITIONS);
      output          = DM_weights[stage];
    }
    else if (113 == diagnosticMode)
    {
      const int stage = clamp(int(src.z), 0, NUMBER_CONDITIONS);
      output          = DS_weights[stage];
    }
    else
    {
      output = src;
    }
#else
    output = apply_DRT(src);
#endif
    dst() = float4(output.x, output.y, output.z, source.w);
  }
};
