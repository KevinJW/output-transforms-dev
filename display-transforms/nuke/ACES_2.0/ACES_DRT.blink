kernel ACES_DRT_Kernel : ImageComputationKernel<ePixelWise>
{
  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image
  Image<eWrite>                            dst; // the output image

param:
  // Toggle Inverse Transform
#define FORWARDS false
#define INVERSE  true
  bool invert;

  bool AP1Clamp;

  // Target Peak Luminance
  float _peakLuminance;

  // Primaries of the Input Image
  // 0: XYZ
  // 1: AP0-ACES
  // 2: AP1-ACES
  // 3: sRGB/Rec.709-D65
  // 4: Rec.2020-D65
  // 5: P3-D65
  // 6: Custom
  int primariesLimit;

  // White point of the limiting gamut
  // effectively the "creative white"
  // 0: Illuminant E
  // 1: ACES white
  // 2: D65
  // 3: DCI
  // 4: Custom
  // Could add others, or user white point
  int whiteLimit;

  float2 custom_red;
  float2 custom_green;
  float2 custom_blue;
  float2 custom_white;

  // Viewing Conditions (for output)
  // 0: Dark
  // 1: Dim
  // 2: Average
  int _inputViewingConditions;
  float L_A_in;
  float Y_b_in;

  int _outputViewingConditions;
  float L_A_out;
  float Y_b_out;

  float3 _userSurround;

  float  _XYZ_w_scaler;

  // Diagnostic path modes
#define COMPILE_DIAGNOSTICS

#define APPLY_DRT 0

#ifdef COMPILE_DIAGNOSTICS

#define FORWARDS_clamp_to_AP1 1
#define FORWARDS_XYZ_to_JMh 2
#define FORWARDS_forwardTonescale 3
#define FORWARDS_compressChroma 4
#define FORWARDS_gamutMapper 5
#define FORWARDS_JMh_to_XYZ 6

#define INVERSE_XYZ_to_JMh 11
#define INVERSE_gamutMapper 12
#define INVERSE_inverseTonescale 13
#define INVERSE_compressChroma 14
#define INVERSE_JMh_to_XYZ 15

#define DEBUG_limitingGamutCuspTable 50
#define DEBUG_limitingGamutGammas 52
#define DEBUG_reachGamutCuspTable 53

#define DEBUG_limitingGamutCuspTableRaw 60
#define DEBUG_limitingGamutCuspTableRaw2 61
#define DEBUG_reachMTableRaw 62


#define DEBUG_Jconstants 70
#define DEBUG_FocusConstants 71
#define DEBUG_limitingFocusJ 72
#define DEBUG_reachMConditions 73

#define DEBUG_gamutCompressAlphaFORWARDS 80
#define DEBUG_gamutCompressAlphaINVERSE 81

#endif

  int diagnosticMode;

  float  _smoothCusps;
  float2 _smoothOffset;
  float  _cuspMidBlend;

  float _focusGainBlend;
  float _focusAdjustGain;
  float _focusDistance;
  float _focusDistanceScaling;

  // Gamut Compression Fuction Parameters
  // Threshold
  float _compressionFuncParams;

  float2 LMS_rxy, LMS_gxy, LMS_bxy, LMS_wxy;

  float chroma_compress;
  float chroma_compress_fact;
  float chroma_expand;
  float chroma_expand_fact;
  float chroma_expand_thr;

  float lowerHullGamma;
  float upperHullGamma;
  bool  disableUpperHullGamma;
  bool  disableLowerHullGamma;

  // aces_ts Curve (ACES2 candidate) parameters
  float aces_ts_n_r;       // Normalized white in nits (what 1.0 should be)
  float aces_ts_g;         // surround / contrast
  float aces_ts_c;         // scene-referred grey
  float aces_ts_c_d;       // display-referred grey (in nits)
  float aces_ts_w_g;       // grey change between different peak luminance
  float aces_ts_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it
  float aces_ts_r_hit_min; // Scene-referred value "hitting the roof" at 100 nits
  float aces_ts_r_hit_max; // Scene-referred value "hitting the roof" at 10,000 nits

local:
#define SOURCE_CONDITIONS  0
#define DISPLAY_CONDITIONS 1
#define NUMBER_CONDITIONS  2

#define PRIMARIES_AP0 0
#define PRIMARIES_AP1 1
#define PRIMARIES_Rec709 2
#define PRIMARIES_Rec2020 3
#define PRIMARIES_P3D65 4
#define PRIMARIES_P3DCI 5

  float3 DL_weights[NUMBER_CONDITIONS];
  float3 DM_weights[NUMBER_CONDITIONS];
  float3 DS_weights[NUMBER_CONDITIONS];
  
  float3 DL_weights_inv[NUMBER_CONDITIONS];
  float3 DM_weights_inv[NUMBER_CONDITIONS];
  float3 DS_weights_inv[NUMBER_CONDITIONS];

  float3 achromatic_w;
  float3 a_w;
  float3 b_w;

  float3 achromatic_weights[NUMBER_CONDITIONS];
  float3 a_weights[NUMBER_CONDITIONS];
  float3 b_weights[NUMBER_CONDITIONS];

  float3 achromatic_weights_inv[NUMBER_CONDITIONS];
  float3 a_weights_inv[NUMBER_CONDITIONS];
  float3 b_weights_inv[NUMBER_CONDITIONS];

  float3x3 AP1_to_XYZ;
  float3x3 XYZ_to_AP1;
  float3x3 XYZ_to_RGB_limit;
  float3x3 RGB_to_XYZ_limit;

  // Reference Luminance in Cd/sqm
#define referenceLuminance 100.0f

  // Model Nonlinearity 'constants'
#define nl_gamma     0.42f
#define nl_normalise 100.0f
#define nl_scale     400.0f
#define nl_offset    27.13f

#define j_scale      100.0f

  float3 surround[NUMBER_CONDITIONS];
  //bool   HK_mode[NUMBER_CONDITIONS];
  float  F_L[NUMBER_CONDITIONS];
  float3 D_RGB[NUMBER_CONDITIONS];
  float  y_to_j_A_w[NUMBER_CONDITIONS];

//#define USE_DEGREES
#ifdef USE_DEGREES
#define hue_limit 360.0f
#else
#define hue_limit (2 * PI)
#endif
#define gamutCuspTableSize 360 // Nominal count of hues sampled in the half open range [0.0, hue_limit) needs to be a multiple of 6 to sample hull corners
#define additonal_entries 2    // Adds extra entries to wrap the hues without special cases
#define totalTableSize gamutCuspTableSize + additonal_entries
#define baseIndex 1            // array index for smallest hue, not necessarily actually a 0.0 hue angle

#define gammaAccuracy 5e-6
#define gammaMinimum 0.4f
#define gammaMaximum 2.0f
#define gammaSearchStep 0.2f
#define badGammaTollerance 1e-2f
#define hueFindingTollerance 1e-7f

  // Non-uniform in h
  float  hueTable[totalTableSize];
  float4 limitingGamutCuspTable[totalTableSize];    // { J, M, Upper gamma, Lower gamma }
  float reachMTable[totalTableSize];                // reachM 

// Note reuse of Hue channel 2
#define UPPER_GAMMA 2
#define LOWER_GAMMA 3

#define cuspCornerCount 6
#define totalCornerCount cuspCornerCount + additonal_entries

  float3 reach_cusp_corners[totalCornerCount];
  float3 reach_JMh_corners[totalCornerCount];

  float3 display_cusp_corners[totalCornerCount];
  float3 display_JMh_corners[totalCornerCount];

  float cube_hues[2*cuspCornerCount];
  int unique_hues;

  float  clamped_smoothness;
  float _focusDist;
  float _midJ;
  float _limitJmax;
  float _model_gamma; // TODO: investigate uses of this
  float _base_slope;

  // Chroma compression pre-calculated constants
  float _compr;   // Compression TODO rename
  float _sat;     // Saturation TODO rename
  float _sat_thr; // Threshold to start expanding saturation
  float chromaCompressScale; // Scaling foactor for 'cusp' normalisation factor

  float aces_ts_c_t;
  float aces_ts_s_2;
  float aces_ts_m_2;
  float aces_ts_inv_upper_limit;
  float input_upper_clamp;

  void define()
  {
    defineParam(invert, "Invert", FORWARDS);

    defineParam(AP1Clamp, "AP1 Clamp", true);

    defineParam(_peakLuminance, "Peak Luminance", 100.0f);
    defineParam(primariesLimit, "Limiting primaries", 2);
    defineParam(whiteLimit, "Limiting Whitepoint", 1);
    defineParam(custom_red, "Custom Red", float2(0.6400f, 0.3300f));
    defineParam(custom_green, "Custom Green", float2(0.3000f, 0.6000f));
    defineParam(custom_blue, "Custom Blue", float2(0.1500f, 0.0600f));
    defineParam(custom_white, "Custom White", float2(0.3127f, 0.3290f));

    defineParam(_inputViewingConditions, "Input Viewing Conditions", 1);
    defineParam(L_A_in, "Input Adapting Luminance", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white
    defineParam(Y_b_in, "Input Background Luminance", 20.0f); // Note these are rediculously wrong depends on viewing conditions
    defineParam(_outputViewingConditions, "Output Viewing Conditions", 1);
    defineParam(L_A_out, "Output Adapting Luminance", 100.0f); // Note these are rediculously wrong should be nearer 20% of diffuse white
    defineParam(Y_b_out, "Output Background Luminance", 20.0f); // Note these are rediculously wrong depends on viewing conditions
    defineParam(_userSurround, "User Surround Parameters", float3(0.9f, 0.59f, 0.9f));

    defineParam(_XYZ_w_scaler, "XYZ White Scaler", 100.0f);

    defineParam(diagnosticMode, "Disagnostics Mode", APPLY_DRT);
    
    defineParam(_smoothCusps, "Cusp Smoothing Factor", 0.12f);
    defineParam(_smoothOffset, "Cusp Smoothing Offset", float2(0.0f, 0.27f));
    defineParam(_cuspMidBlend, "Cusp Mid Blend", 1.3f);

    defineParam(_focusGainBlend, "Focus gain Blend", 0.3f);
    defineParam(_focusAdjustGain, "Focus Adjust Gain", 0.55f);
    defineParam(_focusDistance, "Focus Distance", 1.35f);
    defineParam(_focusDistanceScaling, "Focus Distance Scaling", 1.75f);

    defineParam(_compressionFuncParams, "Compression Function Parameters", 0.75f);
    defineParam(LMS_rxy, "LMS Red Primary", float2(0.8336f,  0.1735f));
    defineParam(LMS_gxy, "LMS Green Primary", float2(2.3854f, -1.4659f));
    defineParam(LMS_bxy, "LMS Blue Primary", float2(0.087f , -0.125f));
    defineParam(LMS_wxy, "LMS White Primary", float2(1.0f / 3.0f, 1.0f / 3.0f));

    // TODO: improve user facing labels
    defineParam(chroma_compress, "chroma_compress", 2.4f);
    defineParam(chroma_compress_fact, "chroma_compress_fact", 3.3f);
    defineParam(chroma_expand, "chroma_expand", 1.3f);
    defineParam(chroma_expand_fact, "chroma_expand_fact", 0.69f);
    defineParam(chroma_expand_thr, "chroma_expand_thr", 0.5f);

    defineParam(lowerHullGamma, "Lower Hull Gamma", 1.14f);
    defineParam(upperHullGamma, "Upper Hull Gamma", 1.0f);
    defineParam(disableLowerHullGamma, "Disable per hue Lower Hull Computation", true);
    defineParam(disableUpperHullGamma, "Disable per hue Upper Hull Computation", false);

    // aces_ts Curve (ACES2 candidate) parameters
    defineParam(aces_ts_n_r, "aces_ts_n_r", 100.0f);             // Normalized white in nits (what 1.0 should be)
    defineParam(aces_ts_g, "aces_ts_g", 1.15f);                  // surround / contrast
    defineParam(aces_ts_c, "aces_ts_c", 0.18f);                  // scene-referred 18% grey
    defineParam(aces_ts_c_d, "aces_ts_c_d", 10.013f);            // display-referred 18^grey (in nits)
    defineParam(aces_ts_w_g, "aces_ts_w_g", 0.14f);              // grey change between different peak luminance
    defineParam(aces_ts_t_1, "aces_ts_t_1", 0.04f);              // shadow toe, flare/glare compensation - how ever you want to call it
    defineParam(aces_ts_r_hit_min, "aces_ts_r_hit_min", 128.0f); // Scene-referred value "hitting the roof" at 100 nits
    defineParam(aces_ts_r_hit_max, "aces_ts_r_hit_max", 896.0f); // Scene-referred value "hitting the roof" at 10,000 nits
  }

  float3x3 RGBPrimsToXYZMatrix(float2 primaries[3], float2 wxy, float Y, bool direction)
  {
    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ
    // # based on CtlColorSpace.cpp from the CTL source code : 77
    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc
    // # param: Y - luminance of "white" - defaults to 1.0
    // # param: inverse - calculate XYZ to RGB instead

    const float2 r = primaries[0];
    const float2 g = primaries[1];
    const float2 b = primaries[2];
    const float2 w = wxy;

    const float X = w.x * Y / w.y;
    const float Z = (1 - w.x - w.y) * Y / w.y;

    // # Scale factors for matrix rows
    const float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);

    // clang-format off
    float Sr =    (X * (b.y - g.y) -      \
            g.x * (Y * (b.y - 1.0f) +  \
            b.y * (X + Z)) +       \
            b.x * (Y * (g.y - 1.0f) + \
            g.y * (X + Z))) / d ;

    float Sg =    (X * (r.y - b.y) +      \
            r.x * (Y * (b.y - 1.0f) +  \
            b.y * (X + Z)) -        \
            b.x * (Y * (r.y - 1.0f) +  \
            r.y * (X + Z))) / d ;

    float Sb =    (X * (g.y - r.y) -      \
            r.x * (Y * (g.y - 1.0f) +  \
            g.y * (X + Z)) +        \
            g.x * (Y * (r.y - 1.0f) +  \
            r.y * (X + Z))) / d ;

    // # Assemble the matrix
    float3x3 newMatrix =
    {
      Sr * r.x, Sg * g.x, Sb * b.x,
      Sr * r.y, Sg * g.y, Sb * b.y,
      Sr * (1.0f - r.x - r.y), Sg * (1.0f - g.x - g.y), Sb * (1.0f - b.x - b.y),
    };
    // clang-format on

    if (direction == INVERSE)
    {
      return newMatrix.invert();
    }
    return newMatrix;
  }

  float2 get_whitepoint(int which_white, float2 custom)
  {
    if (which_white == 1)
    {
      return float2(0.32168f, 0.33767f);
    }
    else if (which_white == 2)
    {
      return float2(0.3127f, 0.3290f);
    }
    else if (which_white == 3)
    {
      return float2(0.3140f, 0.3510f);
    }
    else if (which_white == 4)
    {
      return custom;
    }

    // Case 0 and default
    return float2(1.0f / 3.0f, 1.0f / 3.0f);
  }

  void get_primaries(const int primaries, const float2 custom[3], float2 primaries_out[3])
  {
    if (primaries == 1)
    {
      primaries_out[0] = float2(0.7347f, 0.2653f);
      primaries_out[1] = float2(0.0000f, 1.0000f);
      primaries_out[2] = float2(0.0001f, -0.0770f);
    }
    else if (primaries == 2)
    {
      primaries_out[0] = float2(0.7130f, 0.2930f);
      primaries_out[1] = float2(0.1650f, 0.8300f);
      primaries_out[2] = float2(0.1280f, 0.0440f);
    }
    else if (primaries == 3)
    {
      primaries_out[0] = float2(0.6400f, 0.3300f);
      primaries_out[1] = float2(0.3000f, 0.6000f);
      primaries_out[2] = float2(0.1500f, 0.0600f);
    }
    else if (primaries == 4)
    {
      primaries_out[0] = float2(0.7080f, 0.2920f);
      primaries_out[1] = float2(0.1700f, 0.7970f);
      primaries_out[2] = float2(0.1310f, 0.0460f);
    }
    else if (primaries == 5)
    {
      primaries_out[0] = float2(0.6800f, 0.3200f);
      primaries_out[1] = float2(0.2650f, 0.6900f);
      primaries_out[2] = float2(0.1500f, 0.0600f);
    }
    else if (primaries == 6)
    {
      primaries_out[0] = custom[0];
      primaries_out[1] = custom[1];
      primaries_out[2] = custom[2];
    }
    else
    {
      // Case 0 and default
      primaries_out[0] = float2(1.0f, 0.0f);
      primaries_out[1] = float2(0.0f, 1.0f);
      primaries_out[2] = float2(0.0f, 0.0f);
    }
  }

  // Generate the Hellwig2022 post adaptation non-linear compression matrix
  // that is used in the inverse of the model (JMh-to-XYZ).
  //
  // Original:
  //  460.0f, 451.0f, 288.0f,
  //  460.0f, -891.0f, -261.0f,
  //  460.0f, -220.0f, -6300.0f
  float3x3 generate_panlrcm(float ra, float ba)
  {
    achromatic_w = nl_scale * float3(ra, 1.0f, ba);
    a_w          = nl_scale * float3(11.0f, -12.0f, 1.0f) / 11.0f;
    b_w          = nl_scale * float3(1.0f, 1.0f, -2.0f) / 9.0f;

    float3x3 mat =  constuct_inverse_matrix(achromatic_w, a_w, b_w);

    for (int i = 0; i != 3; ++i)
    {
      float n = (460.0f / mat[i][0]) / 1403.0f;
      mat[i][0] *= n / nl_scale;
      mat[i][1] *= n / nl_scale;
      mat[i][2] *= n / nl_scale;
    }
    return mat;
  }

  float3 viewingConditionsToSurround(int condition)
  {
    float3 newSurround;
    // hack to turn incoming int value into surround coeffs
    if (condition == 0)
    {
      // "Dark": InductionFactors_CIECAM02(0.8, 0.525, 0.8),
      newSurround = float3(0.8f, 0.525f, 0.8f);
    }
    else if (condition == 1)
    {
      // "Dim": InductionFactors_CIECAM02(0.9, 0.59, 0.9),
      newSurround = float3(0.9f, 0.59f, 0.9f);
    }
    else if (condition == 2)
    {
      // "Average": InductionFactors_CIECAM02(1, 0.69, 1),
      newSurround = float3(1.0f, 0.69f, 1.0f);
    }
    else if (condition == 3)
    {
      // Pull from external input
      newSurround = _userSurround;
    }
    return newSurround;
  }

  void init_matrices(float3x3& CAT_CAT16)
  {
    const float2 custom_primaries[3] =
    {
      custom_red, custom_green, custom_blue
    };
    float2 temp_primaries[3] =
    {
      LMS_rxy, LMS_gxy, LMS_bxy
    };
  
    float3x3 CAT_CAT16_INVERSE = RGBPrimsToXYZMatrix(temp_primaries, LMS_wxy, 1.0f, FORWARDS);
    CAT_CAT16 = CAT_CAT16_INVERSE;  // Future Nuke versions make the inverse an inplace operator
    CAT_CAT16 = CAT_CAT16.invert(); // So we copy it then invert, this extra assignment could be dropped in the future

    // AP1 matrix
    get_primaries(2, custom_primaries, temp_primaries);
    float2 whitepoint = get_whitepoint(1, custom_white);
    AP1_to_XYZ = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);
    XYZ_to_AP1 = AP1_to_XYZ;
    XYZ_to_AP1 = XYZ_to_AP1.invert();

    get_primaries(primariesLimit, custom_primaries, temp_primaries);
    whitepoint = get_whitepoint(whiteLimit, custom_white);
    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(temp_primaries, whitepoint, 1.0f, FORWARDS);
    XYZ_to_RGB_limit = RGB_to_XYZ_limit;
    XYZ_to_RGB_limit = XYZ_to_RGB_limit.invert();
  }

  void init_chroma_compression(const float peakLuminance, const float log_peak)
  {
    _compr   = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;
    _sat     = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak); // TODO; magic number
    _sat_thr = chroma_expand_thr / peakLuminance;
    chromaCompressScale = pow(0.03379f * peakLuminance, 0.30596f) - 0.45135f;
  }

  inline float compute_base_exponential_nonlinearity(float Y_background, float Y_white)
  {
    return 1.48f + sqrt(Y_background / Y_white);
  }

  float2 init_gamut_mapper(const float peakLuminance, const float log_peak, const float3 white)
  {
    _focusDist = _focusDistance + _focusDistance * _focusDistanceScaling * log_peak;;    
    _midJ = XYZ_to_JMh(white * aces_ts_c_t * _XYZ_w_scaler, DISPLAY_CONDITIONS).x; // TODO: scale white scaler ?

    // calculate the maximum expected J & M values for the given limit gamut
    // these are used as limiting values for the gamut boundary searches
    // limitJmax (assumed to match limitRGB white)
    // BUG: this fails for HK mode as HK will be increased for highly saturated colours above white
    _limitJmax = linear_RGB_to_JMh(float3(peakLuminance), RGB_to_XYZ_limit, DISPLAY_CONDITIONS).x;
    _model_gamma = 1.0f / (viewingConditionsToSurround(_outputViewingConditions).y * compute_base_exponential_nonlinearity(Y_b_out, L_A_out));
    _base_slope = _limitJmax * _focusDist;

    clamped_smoothness             = max(0.000001f, _smoothCusps); // TODO: max() needed because smin() would have a divide by zero?
    const float2 smooth_cusp_scale = 1.0f + _smoothOffset * clamped_smoothness;
    return smooth_cusp_scale;
  }

  inline float3 generate_unit_cube_corners(const int corner)
  {
    // Generation order R, Y, G, C, B, M to ensure hues rotate in correct order
    return float3(int(((corner+1)%cuspCornerCount) < 3), int(((corner+5)%cuspCornerCount) < 3), int(((corner+3)%cuspCornerCount) < 3));
  }

  void build_cusp_corners_tables(float3 XYZ_corners[totalCornerCount], float3 JMh_corners[totalCornerCount], const int rgb_conditions, const float3x3& rgb_matrix, const float peakLuminance)
  {
    float3 temp_cusp_corners[cuspCornerCount];
    float3 temp_JMh_corners[cuspCornerCount];
    int min_index = 0;
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      temp_cusp_corners[i] = vector_dot(rgb_matrix, peakLuminance * generate_unit_cube_corners(i));
      temp_JMh_corners[i] = XYZ_to_JMh(temp_cusp_corners[i], rgb_conditions);
      if (temp_JMh_corners[i].z < temp_JMh_corners[min_index].z)
        min_index = i;
    }

    // Rotate entries placing lowest at [1] (not [0])
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      XYZ_corners[i + 1] = temp_cusp_corners[(i + min_index) % cuspCornerCount];
      JMh_corners[i + 1] = temp_JMh_corners[(i + min_index) % cuspCornerCount];
    }

    // Copy end elements to create a cycle
    XYZ_corners[0]                   = XYZ_corners[cuspCornerCount];
    XYZ_corners[cuspCornerCount+1]   = XYZ_corners[1];
    JMh_corners[0]                   = JMh_corners[cuspCornerCount];
    JMh_corners[cuspCornerCount+1]   = JMh_corners[1];

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    JMh_corners[0].z                 = JMh_corners[0].z - hue_limit;
    JMh_corners[cuspCornerCount+1].z = JMh_corners[cuspCornerCount+1].z + hue_limit;
  }

  void find_reach_corners_tables(float3 XYZ_corners[totalCornerCount], float3 JMh_corners[totalCornerCount],
                                const int rgb_conditions, const float3x3& rgb_matrix, const float limitJ, const float maximum_source)
  {
    float3 temp_cusp_corners[cuspCornerCount];
    float3 temp_JMh_corners[cuspCornerCount];

    int min_index = 0;
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      const float3 xyz_vector = vector_dot(rgb_matrix, generate_unit_cube_corners(i));
      float3 JMh = float3(0.0f);

      float lower = 0.0f;
      float upper = maximum_source;
      while ((upper - lower) > 1e-3)
      {
        float test = midpoint(lower, upper);
        const float3 test_corner = test * xyz_vector;
        JMh = XYZ_to_JMh(test_corner, rgb_conditions);
        if (JMh.x < limitJ)
        {
          lower = test;
        }
        else
        {
          upper = test;
        }
        if (JMh.x == limitJ)
          break;
      }
      temp_cusp_corners[i] = upper * xyz_vector;
      temp_JMh_corners[i] = XYZ_to_JMh(temp_cusp_corners[i], rgb_conditions);
 
      if (temp_JMh_corners[i].z < temp_JMh_corners[min_index].z)
        min_index = i;
    }

    // Rotate entries placing lowest at [1] (not [0])
    for (int i = 0; i != cuspCornerCount; ++i)
    {
      XYZ_corners[i + 1] = temp_cusp_corners[(i + min_index) % cuspCornerCount];
      JMh_corners[i + 1] = temp_JMh_corners[(i + min_index) % cuspCornerCount];
    }

    // Copy end elements to create a cycle
    XYZ_corners[0]                   = XYZ_corners[cuspCornerCount];
    XYZ_corners[cuspCornerCount+1]   = XYZ_corners[1];
    JMh_corners[0]                   = JMh_corners[cuspCornerCount];
    JMh_corners[cuspCornerCount+1]   = JMh_corners[1];

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    JMh_corners[0].z                 = JMh_corners[0].z - hue_limit;
    JMh_corners[cuspCornerCount+1].z = JMh_corners[cuspCornerCount+1].z + hue_limit;
  }

  int extract_sorted_cube_hues(float sorted_hues[12], const float3 reach_JMh[totalCornerCount], const float3 display_JMh[totalCornerCount])
  {
    // Basic merge of 2 sorted arrays, extracting the unique hues.
    // Return the count of the unique hues
    int idx = 0;
    int reach_idx = 1;
    int display_idx = 1;
    while ((reach_idx < (cuspCornerCount + 1)) || (display_idx < (cuspCornerCount + 1)))
    {
      const float reach_hue = reach_JMh[reach_idx].z;
      const float display_hue = display_JMh[display_idx].z;
      if (reach_hue == display_hue)
      {
        sorted_hues[idx] = reach_hue;
        ++reach_idx;
        ++display_idx; // When equal consume both
      }
      else
      {
        if (reach_hue < display_hue)
        {
          sorted_hues[idx] = reach_hue;
          ++reach_idx;
        }
        else
        {
          sorted_hues[idx] = display_hue;
          ++display_idx;
        }
      }
      ++idx;
    }
    return idx;
  }

  void build_hue_sample_interval(const int samples, const float lower, const float upper, float hueTable[totalTableSize], const int base)
  {
    const float delta = (upper - lower) / float(samples);
    for (int i = 0; i != samples; ++i)
    {
      hueTable[base + i] = lower + float(i) * delta;
    }
  }

  void build_hue_table(float hueTable[totalTableSize], const float cube_hues[2*cuspCornerCount], const int unique_hues)
  {
    const float ideal_spacing = hue_limit / gamutCuspTableSize;
    int samples_count[2*cuspCornerCount+2];
    int total_samples = 0;

    // Special case for ends
    int i = 0;
    samples_count[i] = max(1.0f, round(cube_hues[i] / ideal_spacing)); // samples between 0.0f and first hue
    build_hue_sample_interval(samples_count[i], 0.0f, cube_hues[i], hueTable, total_samples+1);
    total_samples += samples_count[i];
    for (++i; i != unique_hues; ++i)
    {
      samples_count[i] = max(1.0f, round((cube_hues[i] - cube_hues[i-1]) / ideal_spacing)); 
      build_hue_sample_interval(samples_count[i], cube_hues[i-1], cube_hues[i], hueTable, total_samples+1);
      total_samples += samples_count[i];
    }
    samples_count[i] = gamutCuspTableSize - total_samples; //max(1.0f, round((hue_limit - cube_hues[i - 1]) / ideal_spacing)); // samples remaining
    build_hue_sample_interval(samples_count[i], cube_hues[i-1], hue_limit, hueTable, total_samples+1);
    total_samples += samples_count[i];

    hueTable[0] = hueTable[totalTableSize - 2] - hue_limit;
    hueTable[totalTableSize - 1] = hueTable[1] + hue_limit;
  }

  float2 find_reach_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)
  {
    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching
    // along the line calculating the JMh of points along the line till we find the required value.
    // All values on the line segments are valid cusp locations.

    int upper_corner = 1;
    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?
    {
       if (reach_JMh_corners[i].z > hue)
       {
        upper_corner = i;
        break;
       }
    }
    const int lower_corner = upper_corner - 1;

    // hue should now be within [lower_corner, upper_corner), handle exact match
    if (reach_JMh_corners[lower_corner].z == hue)
    {
      return float2(reach_JMh_corners[lower_corner].x, reach_JMh_corners[lower_corner].y);
    }
 
    // search by lerping between RGB corners for the hue
    const float3 cusp_lower = reach_cusp_corners[lower_corner];
    const float3 cusp_upper = reach_cusp_corners[upper_corner];
    float3 sample;

    float sample_t;
    float lower_t = 0.0f;
    float upper_t = 1.0f;

    float3 JMh;

    // There is an edge case where we need to search towards the range when across the [0.0f, hue_limit) boundary
    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make
    // sure we are still in the expected range between the lower and upper corner hue limits
    if (upper_corner > cuspCornerCount)
    {
      while((upper_t - lower_t) > tollerance)
      {
        sample_t = midpoint(lower_t, upper_t);
        sample = lerp(cusp_lower, cusp_upper, sample_t);
        JMh = XYZ_to_JMh(sample, rgb_conditions);
        if ((JMh.z < reach_JMh_corners[lower_corner].z) || (JMh.z > hue))
        {
          upper_t = sample_t;
        }
        else
        {
          lower_t = sample_t;
        }
      }
    }
    else
    {
      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication
      // we can use it for all the remaining segments as it still produces the correct result 
      while((upper_t - lower_t) > tollerance)
      {
        sample_t = midpoint(lower_t, upper_t);
        sample = lerp(cusp_lower, cusp_upper, sample_t);
        JMh = XYZ_to_JMh(sample, rgb_conditions);
        if ((JMh.z > reach_JMh_corners[upper_corner].z) || (JMh.z <= hue))
        {
          lower_t = sample_t;
        }
        else
        {
          upper_t = sample_t;
        }
      }
    }

    // Use the midpoint of the final interval for the actual sampls
    sample_t = midpoint(lower_t, upper_t);
    sample = lerp(cusp_lower, cusp_upper, sample_t);
    JMh = XYZ_to_JMh(sample, rgb_conditions);

    return float2(JMh.x, JMh.y);
  }

  float2 find_display_cusp_for_hue(float hue, const int rgb_conditions, const float tollerance)
  {
    // This works by finding the required line segment between two of the RGB cusp corners, then binary searching
    // along the line calculating the JMh of points along the line till we find the required value.
    // All values on the line segments are valid cusp locations.

    int upper_corner = 1;
    for (int i = upper_corner; i != totalCornerCount; ++i) // TODO: binary search?
    {
       if (display_JMh_corners[i].z > hue)
       {
        upper_corner = i;
        break;
       }
    }
    const int lower_corner = upper_corner - 1;

    // hue should now be within [lower_corner, upper_corner), handle exact match
    if (display_JMh_corners[lower_corner].z == hue)
    {
      return float2(display_JMh_corners[lower_corner].x, display_JMh_corners[lower_corner].y);
    }
 
    // search by lerping between RGB corners for the hue
    const float3 cusp_lower = display_cusp_corners[lower_corner];
    const float3 cusp_upper = display_cusp_corners[upper_corner];
    float3 sample;

    float sample_t;
    float lower_t = 0.0f;
    float upper_t = 1.0f;

    float3 JMh;

    // There is an edge case where we need to search towards the range when across the [0.0f, hue_limit) boundary
    // each edge needs the directions swapped. This is handled by comparing against the appropriate corner to make
    // sure we are still in the expected range between the lower and upper corner hue limits
    if (upper_corner > cuspCornerCount)
    {
      while((upper_t - lower_t) > tollerance)
      {
        sample_t = midpoint(lower_t, upper_t);
        sample = lerp(cusp_lower, cusp_upper, sample_t);
        JMh = XYZ_to_JMh(sample, rgb_conditions);
        if ((JMh.z < display_JMh_corners[lower_corner].z) || (JMh.z > hue))
        {
          upper_t = sample_t;
        }
        else
        {
          lower_t = sample_t;
        }
      }
    }
    else
    {
      // Note the following corner comparison is only needed for the loweest line segment but to avoid more duplication
      // we can use it for all the remaining segments as it still produces the correct result 
      while((upper_t - lower_t) > tollerance)
      {
        sample_t = midpoint(lower_t, upper_t);
        sample = lerp(cusp_lower, cusp_upper, sample_t);
        JMh = XYZ_to_JMh(sample, rgb_conditions);
        if ((JMh.z > display_JMh_corners[upper_corner].z) || (JMh.z <= hue))
        {
          lower_t = sample_t;
        }
        else
        {
          upper_t = sample_t;
        }
      }
    }

    // Use the midpoint of the final interval for the actual sampls
    sample_t = midpoint(lower_t, upper_t);
    sample = lerp(cusp_lower, cusp_upper, sample_t);
    JMh = XYZ_to_JMh(sample, rgb_conditions);

    return float2(JMh.x, JMh.y);
  }

  void initialise_cusp_table(float4 output_table[totalTableSize], const float luminance, const int conditions)
  {
    // the 'tempTableUnsorted' table is populated
    // in increments of H of the limiting gamut HSV space starting at H=0.0
    // since it is unlikely that HSV.H=0 and JMh.h=0 line up
    // the entries are then wrap-around shifted
    // so that the 'gamutCuspTable' starts with the lowest JMh.h value
    for (int i = 1; i != gamutCuspTableSize + 1; ++i)
    {
      const float hue = hueTable[i];
      const float2 JM = find_display_cusp_for_hue(hue, conditions, hueFindingTollerance);
      output_table[i] = float4(JM.x, JM.y, hue, 0.0f);
    }

    // Copy extra entries to ease the code to handle hues wrapping around
    output_table[0]                              = output_table[baseIndex + gamutCuspTableSize - 1];
    output_table[baseIndex + gamutCuspTableSize] = output_table[baseIndex];

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    output_table[0].z = output_table[0].z - hue_limit;
    output_table[baseIndex + gamutCuspTableSize].z = output_table[baseIndex + gamutCuspTableSize].z + hue_limit;
  }

  void smooth_cusp_table(float4 table[totalTableSize], const float2 scale)
  {
    for (int i = 0; i != totalTableSize; ++i)
    {
      const float hue = hueTable[i];
      //table[i].x      = table[i].x * scale.x; // Not needed as the scale is unity
      table[i].y      = table[i].y * scale.y;
    }
  }

  void precompute_reach_table(float reachMTable[totalTableSize], const float limitJ, const float3x3& xyz_matrix,
                              const float3x3& rgb_matrix, const int conditions)
  {
    for (int i = 0; i != totalTableSize; ++i)
    {
      const float hue = hueTable[i];
      reachMTable[i] = find_reach_boundaryM(hue, limitJ, xyz_matrix, 1e-4, conditions);
    }
  }

  float find_reach_boundaryM(const float hue, const float givenJ, const float3x3& matrix, const float threshold, const int conditions)
  {
    const float search_range = 100.0;
    float low     = 0.0;
    float high    = low + search_range;
    bool  outside = false;

    while (!outside && high < 1400.0)
    {
      outside = any_below_zero(JMh_to_linear_RGB(float3(givenJ, high, hue), matrix, conditions));
      if (!outside)
      {
        low  = high;
        high = high + search_range;
      }
    }

    while ((high - low) > threshold)
    {
      const float sampleM = midpoint(low, high);
      outside             = any_below_zero(JMh_to_linear_RGB(float3(givenJ, sampleM, hue), matrix, conditions));
      if (outside)
      {
        high = sampleM;
      }
      else
      {
        low = sampleM;
      }
    }
    return high;
  }

  void fill_initial_hull_gammas(float4 table[totalTableSize], float upperHullGamma, float lowerHullGamma)
  {
    upperHullGamma = 1.0f / upperHullGamma;
    lowerHullGamma = 1.0f / lowerHullGamma;
    for (int i = 0; i != totalTableSize; ++i)
    {
      table[i][UPPER_GAMMA] = upperHullGamma;
      table[i][LOWER_GAMMA] = lowerHullGamma;
    }
  }

  inline bool outside_hull(const float3 newLimitRGB, const float maxRGBtestVal)
  {
    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f ||
        newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal);
  }

  float3 compute_test_location(const float2 JMcusp, float3 testJmh, const float limitJmax, const float base_slope,  const float midJ,
                               const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,
                               const float2 estimated_hull_gammas, const int conditions)
  {
    const float focusJ               = compute_focusJ(JMcusp.x, midJ, _cuspMidBlend, limitJmax);
    const float analytical_threshold = compute_analytical_threshold(JMcusp.x, limitJmax, focusGainBlend);
    const float slope_gain           = compute_slope_gain(testJmh.x, base_slope, limitJmax, focusAdjustGain, analytical_threshold);

    const float intersectJ       = solve_J_intersect(float2(testJmh.x, testJmh.y), focusJ, limitJmax, slope_gain);
    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);
    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);
    const float approxLimit =
        findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ, clamped_smoothness, estimated_hull_gammas, slope);
    const float J_boundary       = slope * approxLimit + intersectJ;

    const float3 approximate_JMh = float3(J_boundary, approxLimit, testJmh.z);
    const float3 newLimitRGB     = JMh_to_linear_RGB(approximate_JMh, XYZ_to_RGB_limit, conditions);
    return newLimitRGB;
  }

  bool evaluate_hull_gamma_fit(const float2 JMcusp, float3 testJmh[], const int test_count, const float2 estimated_hull_gammas,
                                     const float limitJmax, const float base_slope, const float midJ,
                                     const float cuspMidBlend, const float focusAdjustGain, const float focusGainBlend,
                                     const float luminance, const int conditions)
  {
    for (int testIndex = 0; testIndex != test_count; ++testIndex)
    {
      const float3 newLimitRGB = compute_test_location(JMcusp, testJmh[testIndex], limitJmax, base_slope,
                                                       midJ, cuspMidBlend, focusAdjustGain, focusGainBlend, estimated_hull_gammas, conditions);

      if (!outside_hull(newLimitRGB, luminance))
      {
        return false;
      }
    }
    return true;
  }

  void initialise_upper_hull_gamma(float4 table[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,
                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,
                                   const float luminance, const int conditions)
  {
    // Find upper hull gamma values for the gamut mapper
    // start by taking a h angle
    // get the cusp J value for that angle
    // find a J value halfway to the Jmax
    // iterate through gamma values until the approximate max M is negative through the actual boundary

    // positions between the cusp and Jmax we will check
    // variables that get set as we iterate through, once all are set to true we break the loop
    const int   test_count                = 5;
    const float testPositions[test_count] = {0.01f, 0.1f, 0.5f, 0.8f, 0.99f};
    if (!disableUpperHullGamma)
    {
      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)
      {
        //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working
        const float  hue                 = hueTable[i];
        const float4 cusp                = table[i];
        const float2 JMcusp              = float2(cusp.x, cusp.y);

        float3 testJmh[test_count];
        for (int testIndex = 0; testIndex != test_count; ++testIndex)
        {
          // create test values between the cusp and the Jmax
          testJmh[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions[testIndex]), JMcusp.y, hue);
        }

        const float search_range = gammaSearchStep;
        float       low          = gammaMinimum;
        float       high         = low + search_range;
        bool        all_inside   = true;

        while (all_inside && high < gammaMaximum)
        {
          const float2 estimated_hull_gammas = float2(high, table[i][LOWER_GAMMA]);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,
                                              luminance, conditions);
          if (all_inside)
          {
            low  = high;
            high = high + search_range;
          }
        }

        float testGamma = -1.0;
        while ((high - low) > gammaAccuracy)
        {
          testGamma  = midpoint(low, high);
          const float2 estimated_hull_gammas = float2(testGamma, table[i][LOWER_GAMMA]);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,
                                              luminance, conditions);
          if (!all_inside)
          {
            high = testGamma;
          }
          else
          {
            low = testGamma;
          }
        }
        table[i][UPPER_GAMMA] = testGamma;
      }
    }
    // Wrap the end entries
    table[0] = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  inline bool any_below_zero(const float3 newLimitRGB)
  {
    return (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f);
  }

  void initialise_lower_hull_gamma(float4 table[totalTableSize], const float midJ, const float cuspMidBlend, const float limitJmax,
                                   const float base_slope, const float focusAdjustGain, const float focusGainBlend,
                                   const float luminance, const int conditions)
  {
    // Same process, for the bottom hull gamma
    const int   test_count                = 5;
    const float testPositions[test_count] = {0.01f, 0.1f, 0.4f, 0.6f, 0.75f};
    const float fixed_gamma = 1.0f / lowerHullGamma;
    if (!disableLowerHullGamma)
    {
      for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)
      {
        const float4 cusp   = table[i];
        const float2 JMcusp = float2(cusp.x, cusp.y);
        const float  hue    = hueTable[i];

        float3       testJmh[test_count];
        for (int testIndex = 0; testIndex != test_count; ++testIndex)
        {
          testJmh[testIndex] = float3(JMcusp.x * testPositions[testIndex], JMcusp.y, hue);
        }

        const float search_range = gammaSearchStep;
        float       low          = gammaMinimum;
        float       high         = low + search_range;
        bool        all_inside   = true;

        while (all_inside && high < gammaMaximum)
        {
          const float2 estimated_hull_gammas = float2(table[i][UPPER_GAMMA], high);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,
                                              luminance, conditions);
          if (all_inside)
          {
            low  = high;
            high = high + search_range;
          }
        }

        float testGamma = -1.0;
        while ((high - low) > gammaAccuracy)
        {
          testGamma  = midpoint(low, high);
          const float2 estimated_hull_gammas = float2(table[i][UPPER_GAMMA], testGamma);
          all_inside = evaluate_hull_gamma_fit(JMcusp, testJmh, test_count, estimated_hull_gammas, limitJmax,
                                              base_slope, midJ, cuspMidBlend, focusAdjustGain, focusGainBlend,
                                              luminance, conditions);
          if (!all_inside)
          {
            high = testGamma;
          }
          else
          {
            low = testGamma;
          }
        }
        table[i][LOWER_GAMMA] = testGamma;
      }
    }
    table[0] = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  float replace_gamma_entry(float4 table[totalTableSize], int entry, int channel)
  {
    // Very simple patch up, try to find good values either side and lerp a new value
    int lower = entry - 1;
    while (lower >= 0)
    {
      if (!bad_gamma_value(table[lower][channel]))
        break;
      lower = lower - 1;
    }
    if (lower < 0)
      return -1.0f; // Give up if we can't find a good entry below

    int upper = entry + 1;
    while (upper < baseIndex + gamutCuspTableSize)
    {
      if (!bad_gamma_value(table[upper][channel]))
        break;
      upper = upper + 1;
    }
    if (upper == totalTableSize)
      return -2.0f; // Give up nothing above us

    float lower_hue = hueTable[lower];
    float upper_hue = hueTable[upper];
    float entry_hue = hueTable[entry];
    float lerp_loc = (entry_hue - lower_hue) / (upper_hue - lower_hue);
    return lerp(table[lower][channel], table[upper][channel], lerp_loc);
  }

  bool bad_gamma_value(const float value)
  {
    return ((value <= 0.0f) || (value <= gammaMinimum+badGammaTollerance) || (value >= gammaMaximum-badGammaTollerance));
  }

  void repair_broken_gamma_values(float4 table[totalTableSize])
  {
    for (int i = baseIndex; i != (baseIndex + gamutCuspTableSize); ++i)
    {
      for (int channel = UPPER_GAMMA; channel <= LOWER_GAMMA; ++channel)
      {
        if (bad_gamma_value(table[i][channel]))
        {
          table[i][channel] = replace_gamma_entry(table, i, channel);
        }
      }
    }
    table[0] = table[baseIndex + gamutCuspTableSize - 1];
    table[baseIndex + gamutCuspTableSize] = table[baseIndex];
  }

  inline float degree_of_adaptation(float F, float _L_A)
  {
    float D = F * (1.0 - (1.0 / 3.6) * exp((-_L_A - 42.0f) / 92.0f));
    return D;
  }

  inline float3 extract_row(const float3x3 matrix, int row)
  {
    return {matrix[row][0], matrix[row][1], matrix[row][2]};
  }

  inline float3 weight_matrix_row(float weight, float3x3 matrix, int row)
  {
    return weight * extract_row(matrix, row);
  }

  inline float3x3 constuct_inverse_matrix(float3 a, float3 b, float3 c)
  {
    float3x3 matrix;
    matrix[0][0] = a.x;
    matrix[0][1] = a.y;
    matrix[0][2] = a.z;
    matrix[1][0] = b.x;
    matrix[1][1] = b.y;
    matrix[1][2] = b.z;
    matrix[2][0] = c.x;
    matrix[2][1] = c.y;
    matrix[2][2] = c.z;
    return matrix.invert();
  }

  void precompute_hellwig(float3 referenceWhite, float XYZ_w_scaler, int conditions, float _L_A, float Y_b, bool HK,
                          bool discountIlluminant, int stage, float3x3 CAT_CAT16, float3x3 panlrcm)
  {
    surround[stage] = viewingConditionsToSurround(conditions);
    //HK_mode[stage]  = HK;

    const float3 XYZ_w_scaled = referenceWhite * XYZ_w_scaler;

    // # Step 0
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    const float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w_scaled);

    // # Computing degree of adaptation :math:`D`.
    if (!discountIlluminant)
    {
      float D      = clamp(degree_of_adaptation(surround[stage].x, _L_A), 0.0f, 1.0f);
      D_RGB[stage] = D * XYZ_w_scaled.y / RGB_w + 1 - D;
    }
    else
    {
      D_RGB[stage] = XYZ_w_scaled.y / RGB_w;
    }

    const float k    = 1.0f / (5.0f * _L_A + 1.0f);
    const float k4   = k * k * k * k;
    const float _F_L = 0.2f * k4 * (5.0f * _L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * _L_A, 1.0f / 3.0f);
    F_L[stage]       = _F_L / nl_normalise; //TODO white scale?

    // # FWd Step 1
    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.
    //float3 RGB = vector_dot(CAT_CAT16, XYZ);
    //float3 RGB_c = D_RGB[conditions] * RGB; // combine with CAT16

    // Pre weight CAT16 matrix by D
    DL_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].x, CAT_CAT16, 0);
    DM_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].y, CAT_CAT16, 1);
    DS_weights[stage] = weight_matrix_row(F_L[stage] * D_RGB[stage].z, CAT_CAT16, 2);

    // # Inv Step 6
    //const float3 RGB = RGB_c / D_RGB[conditions];
    //const float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);
    const float3x3 tempmat = constuct_inverse_matrix(DL_weights[stage], DM_weights[stage], DS_weights[stage]);
    DL_weights_inv[stage] = extract_row(tempmat, 0);
    DM_weights_inv[stage] = extract_row(tempmat, 1);
    DS_weights_inv[stage] = extract_row(tempmat, 2);

    // Prescale values
    surround[stage].y = surround[stage].y * compute_base_exponential_nonlinearity(Y_b, XYZ_w_scaled.y);
    surround[stage].z = surround[stage].z * 43.0f;

    // # Computing achromatic responses for the whitepoint.
    const float3 RGB_wc = D_RGB[stage] * RGB_w;
     // Needs to use original as we have not setup alternates at this point
     // Assumes White falls on the original curve
    const float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(F_L[stage] * RGB_wc);
    const float A_w     = dot(achromatic_w, RGB_aw);

    // Viewing conditions dependent parameters, different to A_w // TODO looks like RGB_aw?
    y_to_j_A_w[stage] = _post_adaptation_non_linear_response_compression_forward(_F_L);

    achromatic_weights[stage] = achromatic_w / A_w;
    a_weights[stage]          = surround[stage].z * a_w;
    b_weights[stage]          = surround[stage].z * b_w;

    const float3 column_weights = float3(A_w, 1.0f / surround[stage].z, 1.0f / surround[stage].z);
    achromatic_weights_inv[stage]   = extract_row(panlrcm, 0) * column_weights;
    a_weights_inv[stage]            = extract_row(panlrcm, 1) * column_weights;
    b_weights_inv[stage]            = extract_row(panlrcm, 2) * column_weights;
  }

  void init()
  {
    const float log_peak = init_tonescale_constants(_peakLuminance);

    float3x3 CAT_CAT16;

    init_matrices(CAT_CAT16);

    const float3 white(1.0f, 1.0f, 1.0f);
    const float3 inputWhite = vector_dot(AP1_to_XYZ, white);
    const float3 limitWhite = vector_dot(RGB_to_XYZ_limit, white);
    const float3x3 panlrcm = generate_panlrcm(2.0f, 0.05f); // TODO: for now these are constants matching the original CAM weights.
    precompute_hellwig(inputWhite, _XYZ_w_scaler, _inputViewingConditions, L_A_in, Y_b_in, false, true, SOURCE_CONDITIONS, CAT_CAT16, panlrcm);
    precompute_hellwig(limitWhite, _XYZ_w_scaler, _outputViewingConditions, L_A_out, Y_b_out, false, true, DISPLAY_CONDITIONS, CAT_CAT16, panlrcm);

    init_chroma_compression(_peakLuminance, log_peak);
    const float2 smooth_cusp_scale = init_gamut_mapper(_peakLuminance, log_peak, limitWhite);

    // Fist find the unique hues for the cusp corners, then fill in the table uniformly between those hues
    find_reach_corners_tables(reach_cusp_corners, reach_JMh_corners, SOURCE_CONDITIONS, AP1_to_XYZ, _limitJmax, input_upper_clamp);
    build_cusp_corners_tables(display_cusp_corners, display_JMh_corners, DISPLAY_CONDITIONS, RGB_to_XYZ_limit, _peakLuminance);
    unique_hues = extract_sorted_cube_hues(cube_hues, reach_JMh_corners, display_JMh_corners);
    build_hue_table(hueTable, cube_hues, unique_hues);

    initialise_cusp_table(limitingGamutCuspTable, _peakLuminance, DISPLAY_CONDITIONS);
    smooth_cusp_table(limitingGamutCuspTable, smooth_cusp_scale);
    fill_initial_hull_gammas(limitingGamutCuspTable, upperHullGamma, lowerHullGamma);
    // Iterate gamma finding based on previous values
    for (int i = 0; i != 3; ++i)
    {
      initialise_upper_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);
      initialise_lower_hull_gamma(limitingGamutCuspTable, _midJ, _cuspMidBlend, _limitJmax, _base_slope, _focusAdjustGain, _focusGainBlend, _peakLuminance, DISPLAY_CONDITIONS);
    }
    repair_broken_gamma_values(limitingGamutCuspTable);

    precompute_reach_table(reachMTable, _limitJmax, XYZ_to_AP1, AP1_to_XYZ, SOURCE_CONDITIONS);
  }

#ifdef USE_DEGREES
  // convert radians to degrees
  inline float degrees(float radians)
  {
    return radians * 180.0f / PI;
  }

  // convert degrees to radians
  inline float to_radians(float hue)
  {
    return hue / 180.0f * PI;
  }
#endif

  inline float wrap_hue(float hue)
  {
    float y = fmod(hue, hue_limit);
    if (y < 0.0)
    {
      y = y + hue_limit;
    }
    return y;
  }

  // multiplies a 3D vector with a 3x3 matrix
  inline float3 vector_dot(const float3x3& m, const float3 v)
  {
    float3 r;
    for (int c = 0; c != 3; ++c)
    {
      r[c] = m[c][0] * v.x + m[c][1] * v.y + m[c][2] * v.z;
    }

    return r;
  }

  float3 clamp_to_AP1(float3 XYZ)
  {
    if (AP1Clamp)
    {
      float3 RGB = vector_dot(XYZ_to_AP1, XYZ);
      RGB        = clamp(RGB, float3{0.0f}, float3(input_upper_clamp));
      XYZ        = vector_dot(AP1_to_XYZ, RGB);
    }
    return XYZ;
  }

  inline float _post_adaptation_non_linear_response_compression_forward(float L)
  {
    const float F_L_L = pow(L, float(nl_gamma));
    return F_L_L / (nl_offset + F_L_L);
  }

  inline float3 _post_adaptation_non_linear_response_compression_forward(float3 RGB)
  {
    const float3 F_L_RGB = pow(RGB, float3(nl_gamma, nl_gamma, nl_gamma));
    return F_L_RGB / (nl_offset + F_L_RGB);
  }

  inline float _post_adaptation_non_linear_response_compression_inverse(float A)
  {
    const float F_L_A = (nl_offset * A) / (1.0f - A);
    return pow(F_L_A, 1.0f / nl_gamma);
  }

  inline float3 _post_adaptation_non_linear_response_compression_inverse(float3 RGB)
  {
    const float3 F_L_RGB = (nl_offset * RGB) / (1.0f - RGB);
    const float3 RGB_p   = pow(F_L_RGB, float3(1.0f / nl_gamma, 1.0f / nl_gamma, 1.0f / nl_gamma));
    return RGB_p;
  }

  inline float3 post_adaptation_non_linear_response_compression_forward(float3 RGB)
  {
    const float3 absRGB  = fabs(RGB);
    const float3 RGB_c   = sign(RGB) * _post_adaptation_non_linear_response_compression_forward(absRGB);
    return RGB_c;
  }

  inline float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB)
  {
    const float3 absRGB  = fabs(RGB);
    const float3 RGB_p   = sign(RGB) * _post_adaptation_non_linear_response_compression_inverse(absRGB);
    return RGB_p;
  }

//  // Return compression gamut cusp M scaled with an eccentricity factor
//  inline float eccentricity_factor(float hr, bool apply_eccentricity)
//  {
//    if (!apply_eccentricity)
//    {
//        return 1.0f;
//    }
//
//    // Hellwig2022/Helles2023
//    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg
//    const float _1_hr = 1 * hr; // TODO: investigate spline implementation from Luke's PhD (A.15)
//    const float _2_hr = 2 * hr;
//    const float _3_hr = 3 * hr;
//    const float _4_hr = 4 * hr;
//    // clang-format off
//    return (
//        - 0.0582f * cos(_1_hr)
//        - 0.0258f * cos(_2_hr)
//        - 0.1347f * cos(_3_hr)
//        + 0.0289f * cos(_4_hr)
//        - 0.1475f * sin(_1_hr)
//        - 0.0308f * sin(_2_hr)
//        + 0.0385f * sin(_3_hr)
//        + 0.0096f * sin(_4_hr)
//        + 1.0f
//      );
//    // clang-format on
//  }

  // XYZ to Hellwig2020 JMh
  //
  //     XYZ
  //         *CIE XYZ* tristimulus values of test sample / stimulus.
  //     XYZ_w
  //         *CIE XYZ* tristimulus values of reference white.
  //     L_A
  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken
  //         to be 20% of the luminance of a white object in the scene).
  //     Y_b
  //         Luminous factor of background :math:`Y_b` such as
  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the
  //         light source and :math:`L_b` is the luminance of the background. For
  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the
  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,
  //         approximate an :math:`L^*` of 50 is used.
  //     surround // TODO
  //         Surround viewing conditions induction factors.
  //         Truth value indicating if the illuminant should be discounted.
  //     discount_illuminant
  //
  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:
  //
  // - Custom primaries
  //
  inline float _J_from_Achromatic(float A, int conditions)
  {
    return j_scale * pow(A, surround[conditions].y);
  }

  inline float _Achromatic_from_J(float J, int conditions)
  {
    return pow(J / j_scale, 1.0f / surround[conditions].y);
  }

  inline float J_from_Achromatic(float A, int conditions)
  {
    return sign(A) * _J_from_Achromatic(fabs(A), conditions);
  }

  inline float Achromatic_from_J(float J, int conditions)
  {
    return sign(J) * _Achromatic_from_J(fabs(J), conditions);
  }

  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates
  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters
  float3 XYZ_to_JMh(float3 XYZ, int conditions)
  {
    float3 RGB_c;
    RGB_c.x = dot(DL_weights[conditions], XYZ);
    RGB_c.y = dot(DM_weights[conditions], XYZ);
    RGB_c.z = dot(DS_weights[conditions], XYZ);

    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c);

    const float A = dot(achromatic_weights[conditions], RGB_a);
    const float a = dot(a_weights[conditions], RGB_a);
    const float b = dot(b_weights[conditions], RGB_a);

    // # Computing the *hue* angle
    const float hr = atan2(b, a);
#ifdef USE_DEGREES
    const float h  = wrap_hue(degrees(hr));
#else
    const float h  = wrap_hue(hr);
#endif

    // # Step 7
    // # Computing the correlate of *Lightness*
    float J = J_from_Achromatic(A, conditions);

    //if (HK_mode[conditions])
    //{
    //  // # Computing the correlate of *chroma*
    //  const float C = 35.0f * M / A_w[conditions];
    //  J = sqrt(J * J + 66.0f * C);
    //}

    // # Step 9
    // # Computing the correlate of *colourfulness*
    //const float et = eccentricity_factor(hr, false);
    //float       M  = surround[conditions].z * et * sqrt(a * a + b * b);
    float M = sqrt(a * a + b * b); // Valid as et == 1.0

    if (J == 0.0f) // TODO: is this needed?
      M = 0.0f;
    return {J, M, h};
  }

  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values
  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters
  float3 JMh_to_XYZ(float3 JMh, int conditions)
  {
    float       J  = JMh.x;
    const float M  = JMh.y;
#ifdef USE_DEGREES
    const float hr = to_radians(JMh.z);
#else
    const float hr = JMh.z;
#endif

    // # *Helmholtz–Kohlrausch* Effect Extension.
    //if (HK_mode[conditions])
    //{
    //  const float C = (M * 35.0f) / A_w[conditions];
    //  J             = sqrt(J * J - 66.0f * C);
    //}

    // # Computing achromatic response :math:`A` for the stimulus.
    const float _A = Achromatic_from_J(J, conditions);

    // # Computing *P_p_1* to *P_p_2*.
    //const float et    = eccentricity_factor(hr, false);
    //const float P_p_1 = surround[conditions].z; // * et;
    //const float P_p_2 = A;

    // # Step 3
    // # Computing opponent colour dimensions
    const float gamma = M;
    const float a     = gamma * cos(hr);
    const float b     = gamma * sin(hr);

    // # Step 4
    // # Applying post-adaptation non-linear response compression matrix.
    const float3 Aab = float3(_A, a, b);
    //const float3 RGB_a = vector_dot(panlrcm, Aab);
    float3 RGB_a;
    RGB_a.x = dot(achromatic_weights_inv[conditions], Aab);
    RGB_a.y = dot(a_weights_inv[conditions], Aab);
    RGB_a.z = dot(b_weights_inv[conditions], Aab);

    // # Step 5
    // # Applying inverse post-adaptation non-linear response compression.
    const float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a);

    float3 XYZ;
    XYZ.x = dot(DL_weights_inv[conditions], RGB_c);
    XYZ.y = dot(DM_weights_inv[conditions], RGB_c);
    XYZ.z = dot(DS_weights_inv[conditions], RGB_c);

    return XYZ;
  }

  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)
  {
    return int(wrapped_hue / hue_limit * table_size);
  }

  // linear interpolation between two values a & b with the bias t
  inline float lerp(float a, float b, float t)
  {
    return a + t * (b - a);
  }
  inline float2 lerp(float2 a, float2 b, float t)
  {
    return a + t * (b - a);
  }
  inline float3 lerp(float3 a, float3 b, float t)
  {
    return a + t * (b - a);
  }
  inline float4 lerp(float4 a, float4 b, float t)
  {
    return a + t * (b - a);
  }

  // Smooth minimum of a and b (cubic polynomial)
  float smin(float a, float b, float s)
  {
    float h = max(s - fabs(a - b), 0.0f) / s;
    return min(a, b) - h * h * h * s * (1.0f / 6.0f);
  }

  inline float smin_s(float a, float b, float s, float normalise)
  {
    const float s_scaled     = s * normalise;
    const float scaled_delta = (s_scaled - fabs(a - b)) / s_scaled;
    const float h            = max(scaled_delta, 0.0f);
    return min(a, b) - h * h * h * s * (1.0f / 6.0f);
  }

  inline int midpoint(int low, int high)
  {
    return int((high + low) / 2); // Integer division
  }

  inline float midpoint(float low, float high)
  {
    // For our cases we ignore overflow, +/-inf, NaN etc https://hal.science/hal-00576641v2/document
    return (high + low) * 0.5f;
  }

  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'
  // cusps are very expensive to compute
  // and the DRT is only using them for lightness mapping
  // which does not require a high degree of accuracy
  // so instead we use a pre-computed table of cusp points
  // sampled at 1 degree hue intervals of the the RGB target gamut
  // and lerp between them to get the approximate J & M values
  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates
  // the samples are spaced by HSV hue increments of the limiting RGB gamut
  // so to find the correct entry for a given CAM hue (h) value
  // one must search the table entries for the matching entry.z component

  int lookupLimitingCuspHue(float wrapped_hue)
  {
    int low_i  = 0;
    int high_i = baseIndex + gamutCuspTableSize; // Allowed as we have extra entries in the table
    int i      = hue_position_in_uniform_table(wrapped_hue, gamutCuspTableSize) + baseIndex;

    while (low_i + 1 < high_i)
    {
      if (wrapped_hue > hueTable[i])
      {
        low_i = i;
      }
      else
      {
        high_i = i;
      }
      i = midpoint(low_i, high_i);
    }
    return high_i;
  }

  float limiting_lerp_fraction(float wrapped_hue, int pos)
  {
    return (wrapped_hue - hueTable[pos - 1])
          / (hueTable[pos] - hueTable[pos - 1]);
  }

  inline float4 limitingCuspFromTable(int pos, float t)
  {
    return lerp(limitingGamutCuspTable[pos - 1], limitingGamutCuspTable[pos], t);
  }

  inline float reachMFromTable(int pos, float t)
  {
    return lerp(reachMTable[pos - 1], reachMTable[pos], t);
  }

  // https://www.desmos.com/calculator/oe2fscya80
  inline float getFocusGain(float J, float limitJmax, float focusAdjustGain, float analytical_threshold)
  {
    // Assume J (0.0, limitJmax)
    
    if (J <= analytical_threshold)
      return 1.0f; // makes the analytic inverse possible below cusp

    // Approximate inverse required above threshold TODO: explain why
    float gain = (limitJmax - analytical_threshold) / max(0.0001f, (limitJmax - min(limitJmax, J)));
    return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;
  }

  inline float compute_slope_gain(const float J, const float base_slope, const float limitJmax,
                                  const float focusAdjustGain, const float analytical_threshold)
  {
    return base_slope * getFocusGain(J, limitJmax, focusAdjustGain, analytical_threshold);
  }

  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py
  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)
  {
    float a = JM.y / (focusJ * slope_gain);
    float b;
    float c;

    if (JM.x < focusJ)
    {
      b = 1.0f - JM.y / slope_gain;
      c = -JM.x;
    }
    else
    {
      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));
      c = maxJ * JM.y / slope_gain + JM.x;
    }

    const float root = sqrt(b * b - 4.0f * a * c);

    if (JM.x < focusJ)
    {
      return 2.0f * c / (-b - root);
    }
    else
    {
      return 2.0f * c / (-b + root);
    }
  }

  inline float compute_compression_vector_slope(const float intersectJ, const float focusJ, float limitJmax, float slope_gain)
  {
    float direction_scaler;
    if (intersectJ <= focusJ)
    {
      direction_scaler = intersectJ;
    }
    else
    {
       direction_scaler = (limitJmax - intersectJ);
    }

    return direction_scaler * (intersectJ - focusJ) / (focusJ * slope_gain);
  }

  inline float estimate_line_and_boundary_intersection_M(const float J_axis_intersect, const float slope,
                                                         const float inv_gamma, const float J_max, const float M_max,
                                                         const float J_intersection_reference)
  {
    // Line defined by     J = slope * x + J_axis_intersect
    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)
    // Approximate as we do not want to iteratively solve intersection of a straight line and an exponential
    
    // We calculate a shifted intersection from the original intersection using the inverse of the exponential
    // and the provided reference
    const float normalised_J        = J_axis_intersect / J_intersection_reference;
    const float shifted_intersecion = J_intersection_reference * pow(normalised_J, inv_gamma);

    // Now we find the M intersection of two lines
    // line from origin to J,M Max       l1(x) = J/M * x
    // line from J Intersect' with slope l2(x) = slope * x + Intersect'

    return shifted_intersecion / ((J_max / M_max) - slope);
    //return shifted_intersecion * M_max / (J_max - slope * M_max);
  }

  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py
  float findGamutBoundaryMIntersection(float2 JM_cusp, float J_intersect_cusp, float J_max, float J_intersect_source, float smoothness,
                                       float2 estimated_hull_gammas, const float slope)
  {
    const float gamma_top    = estimated_hull_gammas.x;
    const float gamma_bottom = estimated_hull_gammas.y;

    const float M_boundary_lower = estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom, JM_cusp.x, JM_cusp.y, J_intersect_cusp);

    // The upper hull is flipped and thus 'zerod' at J_max
    // Also note we negate the slope
    const float f_J_intersect_cusp = J_max - J_intersect_cusp;
    const float f_J_intersect_source = J_max - J_intersect_source;
    const float f_JM_cusp_J = J_max - JM_cusp.x;
    const float M_boundary_upper = estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top, f_JM_cusp_J, JM_cusp.y, f_J_intersect_cusp);

    // Smooth minimum between the two calculated values for the M component
    const float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, smoothness);
    return M_boundary;
    //return smin_s(M_boundary_lower, M_boundary_upper, smoothness, JM_cusp.y);
  }

  inline float reinhard_compress(const float scale, const float factor, const bool direction)
  {
    if (INVERSE == direction)
    {
      if (factor >= 1.0f)
        return scale;
      else
        return scale * (-(factor / (factor - 1.0f)));
    }
    return scale * (factor) / (1.0f + factor);
  }

  inline float gamut_mapped_location(const float location, const float gamutBoundary, const float reachBoundary, const bool direction)
  {
    // Assumes _compressionFuncParams in (0.0, 1.0)
    const float threshold = clamp(gamutBoundary / reachBoundary, _compressionFuncParams, 0.99999f) * gamutBoundary;

    // Values upto the threshold or when both boundaries are the same remain as is
    if (location <= threshold || gamutBoundary == reachBoundary)
      return location;

    // Translate to place threshold at zero
    const float location_offset = location - threshold;
    const float boundary_offset = gamutBoundary - threshold;
    const float reach_offset    = reachBoundary - threshold;

    // Assumes boundary != reach
    // Generaly speaking boundary should be < reach
    const float scale  = (reach_offset) / (((reach_offset) / (boundary_offset)) - 1.0f);
    const float factor = location_offset / scale;

    const float relative_location = reinhard_compress(scale, factor, direction);

    return (threshold + relative_location); // shift back to absolute
  }

  float2 gamutMapJM(float2 JM, bool direction, float limitJmax, float slope_gain,
                    float2 JMcusp, float focusJ, float2 estimated_hull_gammas, float smoothness,
                    float reachMaxM, float model_gamma)
  {
    const float intersectJ       = solve_J_intersect(JM, focusJ, limitJmax, slope_gain);
    const float slope            = compute_compression_vector_slope(intersectJ, focusJ, limitJmax, slope_gain);
    const float J_intersect_cusp = solve_J_intersect(JMcusp, focusJ, limitJmax, slope_gain);
    const float ganutBoundaryM   = findGamutBoundaryMIntersection(JMcusp, J_intersect_cusp, limitJmax, intersectJ,
                                                                  smoothness, estimated_hull_gammas, slope);

    if (ganutBoundaryM <= 0.0f) // TODO: when does this happen? Causes Nans in gamut_mapped_location, Something funny about yellowish pixels PI (or 180 degrees)
    {
      return float2(JM.x, 0.0f);
    }

    // Compress the out of gamut color along the projection line
    const float reachMax = estimate_line_and_boundary_intersection_M(intersectJ, slope, model_gamma, limitJmax, reachMaxM, limitJmax);
    const float mappedM  = gamut_mapped_location(JM.y, ganutBoundaryM, reachMax, direction);
    const float mappedJ  = slope * mappedM + intersectJ;

    return float2{mappedJ, mappedM};
  }

  inline float compute_focusJ(float J, float midJ, float cuspMidBlend, float limitJmax)
  {
    return lerp(J, midJ, min(1.0f, cuspMidBlend - (J / limitJmax)));
  }

  inline float compute_analytical_threshold(const float cuspJ, const float limitJmax, const float focusGainBlend)
  {
    return lerp(cuspJ, limitJmax, focusGainBlend);
  }

  float3 gamutMapper(float3 JMh, const float4 cusp, const float reachM, bool direction)
  {
    // Limit to +ve values // TODO test this is neededS
    if (JMh.x <= 0.0f)
    {
      JMh.x = 0.0f;
      JMh.y = 0.0f;
    }
    // Above the expected maximum we explicitly map to 0 M
    if (JMh.x >= _limitJmax)
    {
      JMh.y = 0.0f;
    }

    // We compress M only so avoid mapping near zero
    if (JMh.y == 0.0f)
      return JMh;

    // Hue dependent, but as hue does not change we can compute them equally for both directions.
    const float2 JMcusp                = float2(cusp.x, cusp.y);
    const float2 estimated_hull_gammas = float2{cusp[UPPER_GAMMA], cusp[LOWER_GAMMA]};
    const float  analytical_threshold  = compute_analytical_threshold(JMcusp.x, _limitJmax, _focusGainBlend); 
    const float  focusJ                = compute_focusJ(JMcusp.x, _midJ, _cuspMidBlend, _limitJmax);

    float  Jx         = JMh.x;
    float2 JM         = float2{JMh.x, JMh.y};
    float  slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax, _focusAdjustGain, analytical_threshold);
 
    if (INVERSE == direction)
    {
      // Inverse path is a multi-step iterative to solve for the original 'J'
      // Analytic inverse below threshold extra pass approximation above
      if (Jx > analytical_threshold)
      {
        Jx = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,
                        clamped_smoothness, reachM, _model_gamma).x;
        slope_gain = compute_slope_gain(Jx, _base_slope, _limitJmax,_focusAdjustGain, analytical_threshold);
      }
    }
    JM = gamutMapJM(JM, direction, _limitJmax, slope_gain, JMcusp, focusJ, estimated_hull_gammas,
                    clamped_smoothness, reachM, _model_gamma);

    return {JM.x, JM.y, JMh.z};
  }

  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates
  float3 linear_RGB_to_JMh(const float3 RGB, const float3x3& matrix, const int conditions)
  {
    const float3 XYZ = vector_dot(matrix, RGB);
    const float3 JMh = XYZ_to_JMh(XYZ, conditions);
    return JMh;
  }

  float3 JMh_to_linear_RGB(const float3 JMh, const float3x3& matrix, const int conditions)
  {
    const float3 XYZ = JMh_to_XYZ(JMh, conditions);
    const float3 RGB = vector_dot(matrix, XYZ);
    return RGB;
  }

  float init_tonescale_constants(float peakLuminance)
  {
    // pre-calculate aces_ts  constants
    // TODO: this is a mess, tidy up 100.0 and 10000 constants, plus factor out equations into clearer functions

    const float aces_ts_n      = peakLuminance;
    const float aces_ts_m_0    = aces_ts_n / aces_ts_n_r;
    const float aces_ts_r_hit  = aces_ts_r_hit_min + (aces_ts_r_hit_max - aces_ts_r_hit_min) * (log(aces_ts_m_0) / log(10000.0f / 100.0f));
    input_upper_clamp = aces_ts_r_hit * 8.0f * _XYZ_w_scaler;  // limit to nice power of 2 (3 stops) above that needed to max out // TODO magic 8 ball factor needs assessing

    const float aces_ts_m_1    = 0.5f * (aces_ts_m_0 + sqrt(aces_ts_m_0 * (aces_ts_m_0 + 4.0f * aces_ts_t_1)));
    const float aces_ts_u      = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + 1.0f), aces_ts_g);
    const float aces_ts_m      = aces_ts_m_1 / aces_ts_u;
    const float aces_ts_w_i    = log(aces_ts_n / 100.0f) / log(2.0f);
    aces_ts_c_t                = aces_ts_c_d * (1.0f + aces_ts_w_i * aces_ts_w_g) / aces_ts_n_r;
    const float aces_ts_g_ip   = 0.5f * (aces_ts_c_t + sqrt(aces_ts_c_t * (aces_ts_c_t + 4.0f * aces_ts_t_1)));
    const float aces_ts_g_ipp2 = -aces_ts_m_1 * pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) / (pow(aces_ts_g_ip / aces_ts_m, 1.0f / aces_ts_g) - 1.0f);
    const float aces_ts_w_2    = aces_ts_c / aces_ts_g_ipp2;
    aces_ts_s_2                = (aces_ts_w_2 * aces_ts_m_1) * referenceLuminance; // Factor in our reference
    const float aces_ts_u_2    = pow((aces_ts_r_hit / aces_ts_m_1) / ((aces_ts_r_hit / aces_ts_m_1) + aces_ts_w_2), aces_ts_g);
    aces_ts_m_2                = aces_ts_m_1 / aces_ts_u_2;
    aces_ts_inv_upper_limit    = (aces_ts_n * aces_ts_n) / (aces_ts_u_2 * aces_ts_n_r); // TODO Need better name Is it even needed?
    return log10(aces_ts_m_0);
  }

  // ACES Tonescale function, proposed by Daniele Siragusano
  inline float aces_ts_fwd(const float Y)
  {
    // Assumes Y is >= +0.0
    const float f = aces_ts_m_2 * pow(Y / (Y + aces_ts_s_2), aces_ts_g);
    const float h = max(0.0f, f * f / (f + aces_ts_t_1)); // max serves 2 purposes, prevents -ve values being output also handles division by zero possibility
    return h * _XYZ_w_scaler; // TODO: another normalised number
  }

  inline float aces_ts_rev(const float Y)
  {
    //Y       = clamp(Y, 0.0f, aces_ts_inv_upper_limit); // TODO; clamp needed?
    const float h = Y / _XYZ_w_scaler;
    const float f = (h + sqrt(h * (4.0f * aces_ts_t_1 + h))) / 2.0f;
    return  aces_ts_s_2 / (pow((aces_ts_m_2 / f), (1.0f / aces_ts_g)) - 1.0f);
  }

  // Short cut functions used to convert knwon mono-chromatic Y<->J rather than the full model
  inline float _Y_to_Hellwig_J(float Y, int conditions)
  {
    // Assumes Y is >= +0.0
    const float A = _post_adaptation_non_linear_response_compression_forward(F_L[conditions] * Y) / y_to_j_A_w[conditions];
    return _J_from_Achromatic(A, conditions);
  }

  inline float _Hellwig_J_to_Y(float J, int conditions)
  {
    // Assumes J is >= +0.0
    const float A = y_to_j_A_w[conditions] * _Achromatic_from_J(J, conditions);
    return _post_adaptation_non_linear_response_compression_inverse(A) / F_L[conditions];
  }

//  inline float Y_to_Hellwig_J(float Y, int conditions)
//  {
//    const float absY = fabs(Y);
//    return sign(Y) * _Y_to_Hellwig_J(absY, conditions);  // TODO: can we eliminate the fabs and sign calls?
//  }
//
//  inline float Hellwig_J_to_Y(float J, int conditions)
//  {
//    const float absJ = fabs(J);
//    return sign(J) * _Hellwig_J_to_Y(absJ, conditions); // TODO: can we eliminate the fabs and sign calls?
//  }

  float3 forwardTonescale(float3 inputJMh, int conditions)
  {
    const float  inputJ        = inputJMh.x; //max(0.0f, inputJMh.x); // TODO still needed? does mean we can avoid calling sign and fabs calls below
    const float  inputY        = _Hellwig_J_to_Y(inputJ, conditions);
    const float  luminanceTS   = aces_ts_fwd(inputY);
    const float  tonemappedJ   = _Y_to_Hellwig_J(luminanceTS, conditions);
    return float3(tonemappedJ, inputJMh.y, inputJMh.z);
  }

float3 inverseTonescale(float3 JMh, int conditions)
  {
    const float  luminance       = _Hellwig_J_to_Y(JMh.x, conditions);
    const float  linear          = aces_ts_rev(luminance);
    const float  untonemappedJ   = _Y_to_Hellwig_J(linear, conditions);
    return float3(untonemappedJ, JMh.y, JMh.z);
  }

  // A "toe" function that remaps the given value x between 0 and limit.
  // The k1 and k2 parameters change the size and shape of the toe.
  // https://www.desmos.com/calculator/6vplvw14ti
  float toe(float x, float limit, float k1, float k2, bool inverse)
  {
    if (x > limit)
      return x;

    k2             = max(k2, 0.001f); // TODO; magic constant
    k1             = sqrt(k1 * k1 + k2 * k2);
    const float k3 = (limit + k1) / (limit + k2);

    if (!inverse)
    {
      const float minus_b = k3 * x - k1;
      const float minus_c = k2 * k3 * x;
      return 0.5f * (minus_b + sqrt(minus_b * minus_b + 4 * minus_c)); // a is 1.0, mins_b squared == b^2
    }
    else
      return (x * x + k1 * x) / (k3 * (x + k2));
  }

  // Chroma compression
  //
  // Compresses colors inside the gamut with the aim for colorfulness to have an
  // appropriate rate of change from display black to display white, and from
  // achromatic outward to purer colors.
  //
  float chromaCompressionNorm(float h)
  {
#ifdef USE_DEGREES
    const float hr = to_radians(h);
#else
    const float hr = h;
#endif
    float a = cos(hr);
    float b = sin(hr);
    float cos_hr2 = a * a - b * b;
    float sin_hr2 = 2.0f * a * b;
    float cos_hr3 = 4.0f * a * a * a - 3.0f * a;
    float sin_hr3 = 3.0f * b - 4.0f * b * b * b;

    float M = 11.34072f * a +
              16.46899f * cos_hr2 +
               7.88380f * cos_hr3 +
              14.66441f * b +
              -6.37224f * sin_hr2 +
               9.19364f * sin_hr3 +
              77.12896f;

    return M * chromaCompressScale;
  }

  inline float chromaCompression(float3 JMh, const float origJ, const float reachMMax, const bool inverse,
                                 const float limitJmax, const float model_gamma,
                                 const float sat, const float sat_thr, const float compr)
  {
    // Assumes 'h' component is wrapped [0.0, hue_limit)
    float M = JMh.y;
    if (M == 0.0f)
      return M;

    const float nJ                   = JMh.x / limitJmax;
    const float snJ                  = max(0.0f, 1.0f - nJ);

    const float normalisation_factor = chromaCompressionNorm(JMh.z); // reachCuspM; // pow(nJ, model_gamma) * reachMMax; //
    const float limit                = pow(nJ, model_gamma) * reachMMax / normalisation_factor; // 1.0f; //

    const float toe_limit           = limit - 0.001f;  // TODO; magic constantl
    const float toe_snJ_sat         = snJ * sat;
    const float toe_sqrt_nJ_sat_thr = sqrt(nJ * nJ + sat_thr);
    const float toe_nJ_compr        = nJ * compr;
    if (!inverse)
    {
      // Rescaling of M with the tonescaled J to get the M to the same range as
      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to
      // keep the M/J ratio correct (keeping the chromaticities constant).
      M *= pow(JMh.x / origJ, model_gamma);

      // Normalize M with the rendering space cusp M
      M /= normalisation_factor;

      // Expand the colorfulness by running the toe function in reverse.  The goal is to
      // expand less saturated colors less and more saturated colors more.  The expansion
      // increases saturation in the shadows and mid-tones but not in the highlights.
      // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes
      // the toe less aggressive near black to reduce the expansion of noise.
      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, FORWARDS);

      // Compress the colorfulness.  The goal is to compress less saturated colors more and
      // more saturated colors less, especially in the highlights.  This step creates the
      // saturation roll-off in the highlights, but attemps to preserve pure colors.  This
      // mostly affects highlights and mid-tones, and does not compress shadows.
      M = toe(M, limit, toe_nJ_compr, snJ, FORWARDS);

      // Denormalize
      M *= normalisation_factor;
    }
    else
    {
      M /= normalisation_factor;
      M = toe(M, limit, toe_nJ_compr, snJ, INVERSE);
      M = limit - toe(limit - M, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, INVERSE);
      M *= normalisation_factor;
      M *= pow(JMh.x / origJ, -model_gamma);
    }

    return M;
  }

  float3 compressChroma(float3 JMh, const float originalJ, const float reachM, const bool inverse)
  {
    JMh.y = chromaCompression(JMh, originalJ, reachM, inverse, _limitJmax, _model_gamma, _sat, _sat_thr, _compr);
    if (inverse)
      JMh.x = originalJ;
    return JMh;
  }

  float3 apply_DRT(float3 src)
  {
    float3 JMh;
    float3 tonemappedJMh;
    float3 compressedJMh;
    float3 gamutMappedJMh;
    float3 output;

     if (invert)
      {
        gamutMappedJMh      = XYZ_to_JMh(src, DISPLAY_CONDITIONS);
        const int    pos    = lookupLimitingCuspHue(gamutMappedJMh.z);
        const float  t      = limiting_lerp_fraction(gamutMappedJMh.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float  reachM = reachMFromTable(pos, t);
        compressedJMh       = gamutMapper(gamutMappedJMh, cusp, reachM, INVERSE);
        tonemappedJMh       = inverseTonescale(compressedJMh, SOURCE_CONDITIONS);
        JMh                 = compressChroma(compressedJMh, tonemappedJMh.x, reachM, INVERSE);
        output              = JMh_to_XYZ(JMh, SOURCE_CONDITIONS);
      }
      else
      {
        float3 clamped      = clamp_to_AP1(src);
        JMh                 = XYZ_to_JMh(clamped, SOURCE_CONDITIONS);
        const int    pos    = lookupLimitingCuspHue(JMh.z);
        const float  t      = limiting_lerp_fraction(JMh.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float  reachM = reachMFromTable(pos, t);
        tonemappedJMh       = forwardTonescale(JMh, SOURCE_CONDITIONS);
        compressedJMh       = compressChroma(tonemappedJMh, JMh.x, reachM, FORWARDS);
        gamutMappedJMh      = gamutMapper(compressedJMh, cusp, reachM, FORWARDS);
        output              = JMh_to_XYZ(gamutMappedJMh, DISPLAY_CONDITIONS);
      }
    return output;
  }

  void process()
  {
    SampleType(src) source = src();
    const float3 src(source.x, source.y, source.z);
    float3 output;

#ifdef COMPILE_DIAGNOSTICS
    if (APPLY_DRT == diagnosticMode)
    {
        output = apply_DRT(src);
    }
    else if (FORWARDS_clamp_to_AP1 == diagnosticMode)
    {
        output = clamp_to_AP1(src);
    }
    else if (FORWARDS_XYZ_to_JMh == diagnosticMode)
    {
        output = XYZ_to_JMh(src, SOURCE_CONDITIONS);
    }
    else if (FORWARDS_forwardTonescale == diagnosticMode)
    {
        output = forwardTonescale(src, SOURCE_CONDITIONS);
    }
    else if (FORWARDS_compressChroma == diagnosticMode)
    {
        const int    pos    = lookupLimitingCuspHue(src.z);
        const float  t      = limiting_lerp_fraction(src.z, pos);
        const float  reachM = reachMFromTable(pos, t);
        float3 JMh          = inverseTonescale(src, SOURCE_CONDITIONS);
        output              = compressChroma(src, JMh.x, reachM, FORWARDS);
    }
    else if (FORWARDS_gamutMapper == diagnosticMode)
    {
        const int    pos    = lookupLimitingCuspHue(src.z);
        const float  t      = limiting_lerp_fraction(src.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float  reachM = reachMFromTable(pos, t);
        output = gamutMapper(src, cusp, reachM, FORWARDS);
    }
    else if (FORWARDS_JMh_to_XYZ == diagnosticMode)
    {
        output = JMh_to_XYZ(src, DISPLAY_CONDITIONS);
    }
    else if (INVERSE_XYZ_to_JMh == diagnosticMode)
    {
        output = XYZ_to_JMh(src, DISPLAY_CONDITIONS);
    }
    else if (INVERSE_gamutMapper == diagnosticMode)
    {
        const int    pos    = lookupLimitingCuspHue(src.z);
        const float  t      = limiting_lerp_fraction(src.z, pos);
        const float4 cusp   = limitingCuspFromTable(pos, t);
        const float  reachM = reachMFromTable(pos, t);
        output = gamutMapper(src, cusp, reachM, INVERSE);
    }
    else if (INVERSE_inverseTonescale == diagnosticMode)
    {
        output = inverseTonescale(src, SOURCE_CONDITIONS);
    }
    else if (INVERSE_compressChroma == diagnosticMode)
    {
        const int    pos  = lookupLimitingCuspHue(src.z);
        const float  t    = limiting_lerp_fraction(src.z, pos);
        const float  reachM = reachMFromTable(pos, t);
        float3 JMh        = inverseTonescale(src, SOURCE_CONDITIONS);
        output            = compressChroma(src, JMh.x, reachM, INVERSE);
    }
    else if (INVERSE_JMh_to_XYZ == diagnosticMode)
    {
        output = JMh_to_XYZ(src, SOURCE_CONDITIONS);
    }
    else if (DEBUG_limitingGamutCuspTable == diagnosticMode)
    {
        const float  wrapped_hue = wrap_hue(src.z);
        const int    pos         = lookupLimitingCuspHue(wrapped_hue);
        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
        const float4 cusp        = limitingCuspFromTable(pos, t);
        output = float3(cusp.x, cusp.y, src.z);
    }
    else if (DEBUG_limitingGamutGammas == diagnosticMode)
    {
        const float  wrapped_hue = wrap_hue(src.z);
        const int    pos         = lookupLimitingCuspHue(wrapped_hue);
        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
        const float4 cusp        = limitingCuspFromTable(pos, t);
        output = float3(cusp[UPPER_GAMMA], cusp[LOWER_GAMMA], t);
    }
    else if (DEBUG_reachGamutCuspTable == diagnosticMode)
    {
        const float wrapped_hue = wrap_hue(src.z);
        const int   pos         = lookupLimitingCuspHue(wrapped_hue);
        const float t           = limiting_lerp_fraction(wrapped_hue, pos);
        const float reachM      = reachMFromTable(pos, t);
        output = float3(chromaCompressionNorm(src.z), reachM, wrapped_hue);
    }
    else if (DEBUG_limitingGamutCuspTableRaw == diagnosticMode)
    {
        int index = clamp(int(src.z), 0, totalTableSize);
        float4 cusp = limitingGamutCuspTable[index];
        output = float3(cusp.x, cusp.y, cusp.z);
    }
    else if (DEBUG_limitingGamutCuspTableRaw2 == diagnosticMode)
    {
        int index = clamp(int(src.z), 0, totalTableSize);
        float4 cusp = limitingGamutCuspTable[index];
        output = float3(cusp.x, cusp.y, cusp.w);
    }
    else if (DEBUG_reachMTableRaw == diagnosticMode)
    {
        int index = clamp(int(src.z), 0, totalTableSize);
        float reachM = reachMTable[index];
        output = float3(reachM, src.z, index);
    }
    
    else if (DEBUG_Jconstants == diagnosticMode)
    {
        output = float3(_midJ, _limitJmax, _focusDist);
    }
    else if (DEBUG_FocusConstants == diagnosticMode)
    {
        output = float3(_cuspMidBlend, _focusGainBlend, _focusAdjustGain);
    }
    else if (DEBUG_reachMConditions == diagnosticMode)
    {
        const float wrapped_hue = wrap_hue(src.z);
        const float sM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, SOURCE_CONDITIONS);
        const float dM = find_reach_boundaryM(wrapped_hue, _limitJmax, XYZ_to_AP1, 1e-4, DISPLAY_CONDITIONS);

        output = float3(sM, dM, wrapped_hue); 
    }
    else if (DEBUG_gamutCompressAlphaFORWARDS == diagnosticMode)
    {
        const float gml = gamut_mapped_location(src.x, src.y, src.z, FORWARDS);
        output = float3(gml, src.y, src.z); 
    }
    else if (DEBUG_gamutCompressAlphaINVERSE == diagnosticMode)
    {
        const float gml = gamut_mapped_location(src.x, src.y, src.z, INVERSE);
        output = float3(gml, src.y, src.z); 
    }
    else if (100 == diagnosticMode)
    {
        const float sm  = src.z * smin(src.x / src.z, src.y / src.z, clamped_smoothness);
        const float sms = smin_s(src.x, src.y, clamped_smoothness, src.z);
        output = float3(sm, sms, src.z); 
    }
    else if (102 == diagnosticMode)
    {
        const float  wrapped_hue = wrap_hue(src.z);
        const float2 found       = find_reach_cusp_for_hue(wrapped_hue, SOURCE_CONDITIONS, hueFindingTollerance);
        const float  norm        = chromaCompressionNorm(wrapped_hue);
        output = float3(found.x, found.y, norm);
    }
    else if (103 == diagnosticMode)
    {
        const int index = int(src.z) % totalCornerCount;
        output = reach_JMh_corners[index];
    }
    else if (104 == diagnosticMode)
    {
        const int index = int(src.z) % totalCornerCount;
        output = reach_cusp_corners[index];
    }
    else if (105 == diagnosticMode)
    {
        const int index = int(src.z) % totalCornerCount;
        output = display_JMh_corners[index];
    }
    else if (106 == diagnosticMode)
    {
        output = float3(input_upper_clamp / _XYZ_w_scaler);
    }
    else if (107 == diagnosticMode)
    {
        const int index = int(src.z) % (2 * cuspCornerCount);
        output = float3(cube_hues[index], index, unique_hues);
    }
    else if (108 == diagnosticMode)
    {
        const float  wrapped_hue = wrap_hue(src.z);
        const int    pos         = lookupLimitingCuspHue(wrapped_hue);
        const float  t           = limiting_lerp_fraction(wrapped_hue, pos);
        output = float3(float(pos), pos + t, wrapped_hue);
    }
    else if (109 == diagnosticMode)
    {
        int index = clamp(int(src.z), 0, totalTableSize);
        float hue = hueTable[index];
        output = float3(float(index), hue, hue);
    }
    else
    {
        output = src;
    }
#else
    output = apply_DRT(src);
#endif
    dst() = float4(output.x, output.y, output.z, source.w);
  }
};
